{"version":3,"file":"node-build.mjs","sources":["../../server/config/database.ts","../../server/routes/demo.ts","../../server/models/Meeting.ts","../../server/models/MeetingHistory.ts","../../server/models/Attendance.ts","../../server/models/TrackingSession.ts","../../server/models/Employee.ts","../../server/models/RouteSnapshot.ts","../../server/routes/employees.ts","../../server/routes/meetings.ts","../../server/routes/tracking.ts","../../server/routes/analytics.ts","../../server/routes/data-sync.ts","../../server/routes/debug.ts","../../server/routes/route-snapshots.ts","../../server/routes/follow-ups.ts","../../server/index.ts","../../server/node-build.ts"],"sourcesContent":["import mongoose from 'mongoose';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\ninterface DatabaseConfig {\n  MONGODB_URI: string;\n  DB_NAME: string;\n}\n\n// Default configuration - replace these with your local MongoDB URLs\nexport const dbConfig: DatabaseConfig = {\n  MONGODB_URI: process.env.MONGODB_URI || 'mongodb+srv://powerjbds:powerjbds@jbds.hk6xeqm.mongodb.net/',\n  DB_NAME: process.env.DB_NAME || 'employee-tracking'\n};\n\nclass Database {\n  private static instance: Database;\n  private isConnected = false;\n\n  private constructor() {}\n\n  public static getInstance(): Database {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n\n  public async connect(): Promise<void> {\n    if (this.isConnected) {\n      console.log('üì¶ Database: Already connected to MongoDB');\n      return;\n    }\n\n    try {\n      console.log('ÔøΩÔøΩÔøΩÔøΩ Database: Connecting to MongoDB...');\n      console.log('üì¶ Database: URI:', dbConfig.MONGODB_URI);\n      \n      await mongoose.connect(dbConfig.MONGODB_URI, {\n        dbName: dbConfig.DB_NAME,\n      });\n\n      this.isConnected = true;\n      console.log('‚úÖ Database: Successfully connected to MongoDB');\n      \n      // Handle connection events\n      mongoose.connection.on('error', (error) => {\n        console.error('‚ùå Database: MongoDB connection error:', error);\n        this.isConnected = false;\n      });\n\n      mongoose.connection.on('disconnected', () => {\n        console.log('üì¶ Database: MongoDB disconnected');\n        this.isConnected = false;\n      });\n\n      mongoose.connection.on('reconnected', () => {\n        console.log('üì¶ Database: MongoDB reconnected');\n        this.isConnected = true;\n      });\n\n    } catch (error) {\n      console.error('‚ùå Database: Failed to connect to MongoDB:', error);\n      this.isConnected = false;\n      throw error;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.isConnected) {\n      return;\n    }\n\n    try {\n      await mongoose.disconnect();\n      this.isConnected = false;\n      console.log('üì¶ Database: Disconnected from MongoDB');\n    } catch (error) {\n      console.error('‚ùå Database: Error disconnecting from MongoDB:', error);\n    }\n  }\n\n  public isConnectionActive(): boolean {\n    return this.isConnected && mongoose.connection.readyState === 1;\n  }\n\n  public getConnection() {\n    return mongoose.connection;\n  }\n}\n\nexport default Database;\n","import { RequestHandler } from \"express\";\nimport { DemoResponse } from \"@shared/api\";\n\nexport const handleDemo: RequestHandler = (req, res) => {\n  const response: DemoResponse = {\n    message: \"Hello from Express server\",\n  };\n  res.status(200).json(response);\n};\n","import mongoose, { Schema, Document } from 'mongoose';\n\n\n// Customer contact interface\ninterface CustomerContact {\n customerName: string;\n customerEmployeeName: string;\n customerEmail?: string;\n customerMobile?: string;\n customerDesignation?: string;\n customerDepartment?: string;\n}\n\n\n// Meeting details interface\ninterface MeetingDetails {\n customers: CustomerContact[];\n discussion: string;\n // Legacy fields for backward compatibility\n customerName?: string;\n customerEmployeeName?: string;\n customerEmail?: string;\n customerMobile?: string;\n customerDesignation?: string;\n customerDepartment?: string;\n}\n\n\n// Location interface\ninterface Location {\n lat: number;\n lng: number;\n address: string;\n timestamp: string;\n}\n\n\n// Meeting document interface\nexport interface IMeeting extends Document {\n employeeId: string;\n location: Location;\n startTime: string;\n endTime?: string;\n clientName?: string;\n notes?: string;\n status: 'started' | 'in-progress' | 'completed';\n trackingSessionId?: string;\n leadId?: string;\n leadInfo?: {\n   id: string;\n   companyName: string;\n   contactName: string;\n };\n followUpId?: string; // Follow-up meeting ID from external API\n meetingDetails?: MeetingDetails;\n externalMeetingStatus?: string; // Status from external follow-up API\n approvalStatus?: 'ok' | 'not_ok'; // Meeting approval status\n approvalReason?: string; // Reason for approval/rejection\n createdAt: Date;\n updatedAt: Date;\n}\n\n\n// Customer contact schema\nconst CustomerContactSchema = new Schema({\n customerName: { type: String, required: true },\n customerEmployeeName: { type: String, required: true },\n customerEmail: { type: String },\n customerMobile: { type: String },\n customerDesignation: { type: String },\n customerDepartment: { type: String }\n});\n\n\n// Meeting details schema\nconst MeetingDetailsSchema = new Schema({\n customers: [CustomerContactSchema],\n discussion: { type: String, required: true },\n // Legacy fields\n customerName: { type: String },\n customerEmployeeName: { type: String },\n customerEmail: { type: String },\n customerMobile: { type: String },\n customerDesignation: { type: String },\n customerDepartment: { type: String }\n});\n\n\n// Location schema\nconst CoordinateSchema = new Schema({\n lat: { type: Number, required: true },\n lng: { type: Number, required: true },\n address: { type: String, required: true },\n timestamp: { type: String }\n}, { _id: false });\n\n\nconst LocationSchema = new Schema({\n lat: { type: Number, required: true },\n lng: { type: Number, required: true },\n address: { type: String, required: true },\n endLocation: { type: CoordinateSchema },\n timestamp: { type: String, required: true }\n});\n\n\n\n\n// Lead info schema\nconst LeadInfoSchema = new Schema({\n id: { type: String, required: true },\n companyName: { type: String, required: true },\n contactName: { type: String, required: true }\n});\n\n\n// Main meeting schema\nconst MeetingSchema = new Schema({\n employeeId: {\n   type: String,\n   required: true,\n   index: true\n },\n location: {\n   type: LocationSchema,\n   required: true\n },\n startTime: {\n   type: String,\n   required: true,\n   index: true\n },\n endTime: {\n   type: String\n },\n clientName: {\n   type: String\n },\n notes: {\n   type: String\n },\n status: {\n   type: String,\n   enum: ['started', 'in-progress', 'completed'],\n   default: 'in-progress',\n   index: true\n },\n trackingSessionId: {\n   type: String\n },\n leadId: {\n   type: String,\n   index: true\n },\n leadInfo: LeadInfoSchema,\n followUpId: {\n   type: String,\n   index: true\n },\n meetingDetails: MeetingDetailsSchema,\n externalMeetingStatus: {\n   type: String\n },\n approvalStatus: {\n   type: String,\n   enum: ['ok', 'not_ok'],\n   index: true\n },\n approvalReason: {\n   type: String\n }\n}, {\n timestamps: true,\n collection: 'meetings'\n});\n\n\n// Create indexes for better query performance\nMeetingSchema.index({ employeeId: 1, startTime: -1 });\nMeetingSchema.index({ leadId: 1, startTime: -1 });\nMeetingSchema.index({ status: 1, startTime: -1 });\n\n\nexport const Meeting = mongoose.model<IMeeting>('Meeting', MeetingSchema);\n\n\n\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Meeting details interface (reused from Meeting model)\ninterface MeetingDetails {\n  customers: Array<{\n    customerName: string;\n    customerEmployeeName: string;\n    customerEmail?: string;\n    customerMobile?: string;\n    customerDesignation?: string;\n    customerDepartment?: string;\n  }>;\n  discussion: string;\n  // Incomplete meeting tracking\n  incomplete?: boolean;\n  incompleteReason?: string;\n  // Legacy fields\n  customerName?: string;\n  customerEmployeeName?: string;\n  customerEmail?: string;\n  customerMobile?: string;\n  customerDesignation?: string;\n  customerDepartment?: string;\n}\n\n// Meeting history document interface\nexport interface IMeetingHistory extends Document {\n  sessionId: string;\n  employeeId: string;\n  meetingDetails: MeetingDetails;\n  timestamp: string;\n  leadId?: string;\n  leadInfo?: {\n    id: string;\n    companyName: string;\n    contactName: string;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Customer contact schema (reused)\nconst CustomerContactSchema = new Schema({\n  customerName: { type: String, required: true },\n  customerEmployeeName: { type: String, required: true },\n  customerEmail: { type: String },\n  customerMobile: { type: String },\n  customerDesignation: { type: String },\n  customerDepartment: { type: String }\n});\n\n// Meeting details schema (reused)\nconst MeetingDetailsSchema = new Schema({\n  customers: [CustomerContactSchema],\n  discussion: { type: String, required: true },\n  // Incomplete meeting tracking\n  incomplete: { type: Boolean, default: false, index: true },\n  incompleteReason: { type: String },\n  // Legacy fields\n  customerName: { type: String },\n  customerEmployeeName: { type: String },\n  customerEmail: { type: String },\n  customerMobile: { type: String },\n  customerDesignation: { type: String },\n  customerDepartment: { type: String }\n});\n\n// Lead info schema (reused)\nconst LeadInfoSchema = new Schema({\n  id: { type: String, required: true },\n  companyName: { type: String, required: true },\n  contactName: { type: String, required: true }\n});\n\n// Meeting history schema\nconst MeetingHistorySchema = new Schema({\n  sessionId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  meetingDetails: { \n    type: MeetingDetailsSchema, \n    required: true \n  },\n  timestamp: { \n    type: String, \n    required: true,\n    index: true \n  },\n  leadId: { \n    type: String,\n    index: true \n  },\n  leadInfo: LeadInfoSchema\n}, {\n  timestamps: true,\n  collection: 'meeting_history'\n});\n\n// Create indexes for better query performance\nMeetingHistorySchema.index({ employeeId: 1, timestamp: -1 });\nMeetingHistorySchema.index({ leadId: 1, timestamp: -1 });\nMeetingHistorySchema.index({ sessionId: 1, timestamp: -1 });\n\nexport const MeetingHistory = mongoose.model<IMeetingHistory>('MeetingHistory', MeetingHistorySchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Attendance document interface\nexport interface IAttendance extends Document {\n  employeeId: string;\n  date: string; // YYYY-MM-DD format\n  attendanceStatus: 'full_day' | 'half_day' | 'off' | 'short_leave' | 'ot';\n  attendanceReason: string;\n  attendenceCreated: string | null; // userId who created the attendance (null for tracking employee)\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Attendance schema\nconst AttendanceSchema = new Schema({\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  date: { \n    type: String, \n    required: true,\n    index: true,\n    match: /^\\d{4}-\\d{2}-\\d{2}$/ // YYYY-MM-DD format validation\n  },\n  attendanceStatus: { \n    type: String, \n    enum: ['full_day', 'half_day', 'off', 'short_leave', 'ot'],\n    required: true,\n    default: 'full_day'\n  },\n  attendanceReason: { \n    type: String,\n    default: ''\n  },\n  attendenceCreated: {\n    type: String,\n    default: null // null for tracking employee, userId from CRM dashboard\n  }\n}, {\n  timestamps: true,\n  collection: 'attendance'\n});\n\n// Create compound unique index to prevent duplicate attendance records for same employee-date\nAttendanceSchema.index({ employeeId: 1, date: 1 }, { unique: true });\n\n// Create indexes for better query performance\nAttendanceSchema.index({ employeeId: 1, date: -1 });\nAttendanceSchema.index({ date: -1, attendanceStatus: 1 });\n\nexport const Attendance = mongoose.model<IAttendance>('Attendance', AttendanceSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location data interface\ninterface LocationData {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Tracking session document interface\nexport interface ITrackingSession extends Document {\n  id: string;\n  employeeId: string;\n  startTime: string;\n  endTime?: string;\n  startLocation: LocationData;\n  endLocation?: LocationData;\n  route: LocationData[];\n  totalDistance: number;\n  duration?: number;\n  status: 'active' | 'completed' | 'paused';\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location data schema\nconst LocationDataSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Tracking session schema\nconst TrackingSessionSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  startTime: { \n    type: String, \n    required: true,\n    index: true \n  },\n  endTime: { \n    type: String \n  },\n  startLocation: { \n    type: LocationDataSchema, \n    required: true \n  },\n  endLocation: { \n    type: LocationDataSchema \n  },\n  route: [LocationDataSchema],\n  totalDistance: { \n    type: Number, \n    default: 0 \n  },\n  duration: { \n    type: Number // Duration in seconds\n  },\n  status: { \n    type: String, \n    enum: ['active', 'completed', 'paused'],\n    default: 'active',\n    index: true \n  }\n}, {\n  timestamps: true,\n  collection: 'tracking_sessions'\n});\n\n// Create indexes for better query performance\nTrackingSessionSchema.index({ employeeId: 1, startTime: -1 });\nTrackingSessionSchema.index({ status: 1, startTime: -1 });\nTrackingSessionSchema.index({ employeeId: 1, status: 1, startTime: -1 });\n\nexport const TrackingSession = mongoose.model<ITrackingSession>('TrackingSession', TrackingSessionSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location interface\ninterface Location {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Employee document interface\nexport interface IEmployee extends Document {\n  id: string;\n  name: string;\n  email: string;\n  phone?: string;\n  status: 'active' | 'inactive' | 'meeting';\n  location?: Location;\n  lastUpdate?: string;\n  currentTask?: string;\n  deviceId?: string;\n  designation?: string;\n  department?: string;\n  companyName?: string;\n  reportTo?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location schema\nconst LocationSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Employee schema\nconst EmployeeSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  name: { \n    type: String, \n    required: true,\n    index: true \n  },\n  email: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  phone: { \n    type: String \n  },\n  status: { \n    type: String, \n    enum: ['active', 'inactive', 'meeting'],\n    default: 'inactive',\n    index: true \n  },\n  location: LocationSchema,\n  lastUpdate: { \n    type: String \n  },\n  currentTask: { \n    type: String \n  },\n  deviceId: { \n    type: String,\n    index: true \n  },\n  designation: { \n    type: String \n  },\n  department: { \n    type: String \n  },\n  companyName: { \n    type: String \n  },\n  reportTo: { \n    type: String \n  }\n}, {\n  timestamps: true,\n  collection: 'employees'\n});\n\n// Create indexes for better query performance\nEmployeeSchema.index({ status: 1, name: 1 });\nEmployeeSchema.index({ companyName: 1, department: 1 });\nEmployeeSchema.index({ name: 'text', email: 'text' }); // Text search index\n\nexport const Employee = mongoose.model<IEmployee>('Employee', EmployeeSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location data interface\ninterface LocationData {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Meeting snapshot data interface\ninterface MeetingSnapshot {\n  id: string;\n  location: LocationData;\n  clientName?: string;\n  startTime: string;\n  endTime?: string;\n  status: string;\n}\n\n// Route snapshot document interface\nexport interface IRouteSnapshot extends Document {\n  id: string;\n  employeeId: string;\n  employeeName: string;\n  trackingSessionId?: string;\n  captureTime: string;\n  startLocation: LocationData;\n  endLocation?: LocationData;\n  route: LocationData[];\n  meetings: MeetingSnapshot[];\n  totalDistance: number;\n  duration?: number;\n  status: 'active' | 'completed';\n  title: string;\n  description?: string;\n  mapBounds: {\n    north: number;\n    south: number;\n    east: number;\n    west: number;\n  };\n  snapshotMetadata: {\n    routeColor: string;\n    mapZoom: number;\n    routePointsCount: number;\n    meetingsCount: number;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location data schema\nconst LocationDataSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Meeting snapshot schema\nconst MeetingSnapshotSchema = new Schema({\n  id: { type: String, required: true },\n  location: { type: LocationDataSchema, required: true },\n  clientName: { type: String },\n  startTime: { type: String, required: true },\n  endTime: { type: String },\n  status: { type: String, required: true }\n});\n\n// Map bounds schema\nconst MapBoundsSchema = new Schema({\n  north: { type: Number, required: true },\n  south: { type: Number, required: true },\n  east: { type: Number, required: true },\n  west: { type: Number, required: true }\n});\n\n// Snapshot metadata schema\nconst SnapshotMetadataSchema = new Schema({\n  routeColor: { type: String, default: '#3b82f6' },\n  mapZoom: { type: Number, default: 12 },\n  routePointsCount: { type: Number, default: 0 },\n  meetingsCount: { type: Number, default: 0 }\n});\n\n// Route snapshot schema\nconst RouteSnapshotSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  employeeName: {\n    type: String,\n    required: true\n  },\n  trackingSessionId: { \n    type: String,\n    index: true \n  },\n  captureTime: { \n    type: String, \n    required: true,\n    index: true \n  },\n  startLocation: { \n    type: LocationDataSchema, \n    required: true \n  },\n  endLocation: { \n    type: LocationDataSchema \n  },\n  route: [LocationDataSchema],\n  meetings: [MeetingSnapshotSchema],\n  totalDistance: { \n    type: Number, \n    default: 0 \n  },\n  duration: { \n    type: Number // Duration in seconds\n  },\n  status: { \n    type: String, \n    enum: ['active', 'completed'],\n    default: 'active',\n    index: true \n  },\n  title: {\n    type: String,\n    required: true\n  },\n  description: {\n    type: String\n  },\n  mapBounds: {\n    type: MapBoundsSchema,\n    required: true\n  },\n  snapshotMetadata: {\n    type: SnapshotMetadataSchema,\n    required: true\n  }\n}, {\n  timestamps: true,\n  collection: 'route_snapshots'\n});\n\n// Create indexes for better query performance\nRouteSnapshotSchema.index({ employeeId: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ trackingSessionId: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ status: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ employeeId: 1, status: 1, captureTime: -1 });\n\nexport const RouteSnapshot = mongoose.model<IRouteSnapshot>('RouteSnapshot', RouteSnapshotSchema);\n","import { RequestHandler } from \"express\";\nimport axios from \"axios\";\nimport {\n  Employee,\n  ExternalUser,\n  EmployeesResponse,\n  LocationUpdate,\n  LocationUpdateResponse,\n} from \"@shared/api\";\nimport {\n  Employee as EmployeeModel,\n  IEmployee,\n  TrackingSession,\n} from \"../models\";\n\n// Configuration\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\nconst NOMINATIM_URL = \"https://nominatim.openstreetmap.org/reverse\";\nconst GEOCACHE_TTL = 60 * 60 * 1000; // 1 hour cache TTL\n\n// Types\ninterface EmployeeStatus {\n  status: \"active\" | \"inactive\" | \"meeting\";\n  location: {\n    lat: number;\n    lng: number;\n    address: string;\n    timestamp: string;\n  };\n  lastUpdate: string;\n  currentTask?: string;\n}\n\ninterface GeocodeCacheItem {\n  address: string;\n  expires: number;\n}\n\n// State\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\n\n// Utility Functions\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n\n  if (cached && cached.expires > Date.now()) {\n    return cached.address;\n  }\n\n  try {\n    const response = await axios.get(NOMINATIM_URL, {\n      params: {\n        format: \"json\",\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1,\n      },\n      headers: {\n        \"User-Agent\": \"FieldTracker/1.0 (contact@yourdomain.com)\",\n      },\n      timeout: 5000,\n    });\n\n    const address =\n      response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n\n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL,\n    });\n\n    return address;\n  } catch (error) {\n    console.error(\"Geocoding failed:\", error);\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  }\n}\n\n// Replace your getAddressFromCoordinates function with this:\nasync function getAddressFromCoordinates(\n  lat: number,\n  lng: number,\n): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n\n  const fallbackAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n\n  // Return cached address if available and not expired\n  if (cached && cached.expires > Date.now()) {\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\n    return cached.address;\n  }\n\n  // üîπ FIX: Wait for geocoding instead of returning fallback immediately\n  try {\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\n    const response = await axios.get(NOMINATIM_URL, {\n      params: {\n        format: \"json\",\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1,\n      },\n      headers: {\n        \"User-Agent\": \"EmployeeTrackingApp/1.0\",\n      },\n      timeout: 5000, // 5 second timeout\n    });\n\n    const address = response.data?.display_name || fallbackAddress;\n    console.log(`‚úÖ Address resolved: ${address}`);\n\n    // Cache the result for future use\n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL,\n    });\n\n    return address;\n  } catch (error) {\n    console.warn(`‚ö†Ô∏è Geocoding failed for ${lat}, ${lng}, using coordinates:`, error.message);\n    // Return fallback if geocoding fails\n    return fallbackAddress;\n  }\n}\n\nasync function getEmployeeLatestLocation(employeeId: string) {\n  try {\n    // First try Employee model with timeout\n    const employee = (await Promise.race([\n      EmployeeModel.findOne({ id: employeeId }).lean(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\n      ),\n    ])) as any;\n\n    if (employee?.location?.lat && employee.location.lng !== 0) {\n      const address =\n        employee.location.address ||\n        `${employee.location.lat.toFixed(6)}, ${employee.location.lng.toFixed(6)}`;\n\n      return {\n        lat: employee.location.lat,\n        lng: employee.location.lng,\n        address,\n        timestamp: employee.location.timestamp,\n        lastUpdate: employee.lastUpdate || \"Recently updated\",\n      };\n    }\n\n    // Quick fallback to tracking sessions\n    const latestSession = (await Promise.race([\n      TrackingSession.findOne({\n        employeeId,\n        $or: [{ status: \"active\" }, { status: \"completed\" }],\n      })\n        .sort({ startTime: -1 })\n        .lean(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\n      ),\n    ])) as any;\n\n    if (latestSession) {\n      const latestLocation = latestSession.route?.length\n        ? latestSession.route[latestSession.route.length - 1]\n        : latestSession.startLocation;\n\n      if (latestLocation?.lat !== 0 && latestLocation?.lng !== 0) {\n        const address =\n          latestLocation.address ||\n          `${latestLocation.lat.toFixed(6)}, ${latestLocation.lng.toFixed(6)}`;\n\n        return {\n          lat: latestLocation.lat,\n          lng: latestLocation.lng,\n          address,\n          timestamp: latestLocation.timestamp,\n          lastUpdate:\n            latestSession.status === \"active\"\n              ? \"Currently tracking\"\n              : \"From last session\",\n        };\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.warn(`Location lookup failed for ${employeeId}:`, error.message);\n    return null;\n  }\n}\n\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\n  try {\n    geocodeCache.clear();\n    res.json({ success: true, message: \"Geocode cache cleared\" });\n  } catch (error) {\n    console.error(\"Error clearing cache:\", error);\n    res.status(500).json({ error: \"Failed to clear cache\" });\n  }\n};\n\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 15000);\n\n    const response = await fetch(EXTERNAL_API_URL, {\n      signal: controller.signal,\n      headers: { Accept: \"application/json\" },\n    });\n\n    clearTimeout(timeout);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const data = await response.json();\n    return Array.isArray(data) ? data : [];\n  } catch (error) {\n    console.error(\"External API fetch failed:\", error);\n    return [];\n  }\n}\n\nasync function mapExternalUserToEmployee(\n  user: ExternalUser,\n  index: number,\n): Promise<Employee> {\n  const userId = user._id;\n\n  // Try to get location but don't block on it\n  let realLocation = null;\n  try {\n    realLocation = (await Promise.race([\n      getEmployeeLatestLocation(userId),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"timeout\")), 1000),\n      ),\n    ])) as any;\n  } catch (error) {\n    // Use default location if lookup fails/times out\n    realLocation = null;\n  }\n\n  // Initialize or update status\n  if (!employeeStatuses[userId]) {\n    employeeStatuses[userId] = {\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\n      location: realLocation || {\n        lat: 28.6139 + (Math.random() - 0.5) * 0.1, // Delhi area with variation\n        lng: 77.209 + (Math.random() - 0.5) * 0.1,\n        address: `Employee ${index + 1} Location`,\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: realLocation?.lastUpdate || \"Recently\",\n      currentTask:\n        index === 0\n          ? \"Client meeting\"\n          : index === 1\n            ? \"Equipment installation\"\n            : undefined,\n    };\n  } else if (realLocation) {\n    employeeStatuses[userId].location = {\n      lat: realLocation.lat,\n      lng: realLocation.lng,\n      address: realLocation.address,\n      timestamp: realLocation.timestamp,\n    };\n    employeeStatuses[userId].lastUpdate = realLocation.lastUpdate;\n  }\n\n  const status = employeeStatuses[userId];\n\n  return {\n    id: userId,\n    name: user.name,\n    email: user.email,\n    phone: user.mobileNumber,\n    status: status.status,\n    location: status.location,\n    lastUpdate: status.lastUpdate,\n    currentTask: status.currentTask,\n    deviceId: `device_${userId.slice(-6)}`,\n    designation: user.designation,\n    department: user.department,\n    companyName: user.companyName[0]?.companyName,\n    reportTo: user.report?.name,\n  };\n}\n\n// API Handlers\nexport const getEmployees: RequestHandler = async (req, res) => {\n  try {\n    if (req.query.clearCache === \"true\") {\n      employeeStatuses = {};\n      geocodeCache.clear();\n    }\n\n    const externalUsers = await fetchExternalUsers();\n    if (externalUsers.length > 0) {\n      const employees = await Promise.all(\n        externalUsers.map((user, index) =>\n          mapExternalUserToEmployee(user, index),\n        ),\n      );\n\n      // Sync to MongoDB\n      try {\n        await Promise.all(\n          employees.map((employee) =>\n            EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\n              upsert: true,\n              new: true,\n            }),\n          ),\n        );\n      } catch (dbError) {\n        console.warn(\"MongoDB sync failed:\", dbError);\n      }\n\n      return res.json({ employees, total: employees.length });\n    }\n\n    // Fallback to MongoDB\n    try {\n      const mongoEmployees = await EmployeeModel.find({}).lean();\n      return res.json({\n        employees: mongoEmployees,\n        total: mongoEmployees.length,\n      });\n    } catch (dbError) {\n      console.warn(\"MongoDB fallback failed:\", dbError);\n      return res.json({ employees: [], total: 0 });\n    }\n  } catch (error) {\n    console.error(\"Employee fetch failed:\", error);\n    res.status(500).json({ error: \"Failed to fetch employees\" });\n  }\n};\n\nexport const getEmployee: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const externalUsers = await fetchExternalUsers();\n\n    if (externalUsers.length > 0) {\n      const user = externalUsers.find((u) => u._id === id);\n      if (user) {\n        const employee = await mapExternalUserToEmployee(\n          user,\n          externalUsers.indexOf(user),\n        );\n\n        try {\n          await EmployeeModel.findOneAndUpdate({ id }, employee, {\n            upsert: true,\n            new: true,\n          });\n        } catch (dbError) {\n          console.warn(\"MongoDB update failed:\", dbError);\n        }\n\n        return res.json(employee);\n      }\n    }\n\n    // Fallback to MongoDB\n    try {\n      const employee = await EmployeeModel.findOne({ id }).lean();\n      if (employee) return res.json(employee);\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed:\", dbError);\n    }\n\n    return res.status(404).json({ error: \"Employee not found\" });\n  } catch (error) {\n    console.error(\"Employee fetch failed:\", error);\n    res.status(500).json({ error: \"Failed to fetch employee\" });\n  }\n};\n\nexport const updateEmployeeLocation: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { lat, lng } = req.body;\n\n    // Get human-readable address\n    const address = await getAddressFromCoordinates(lat, lng);\n\n    const locationUpdate = {\n      location: {\n        lat,\n        lng,\n        address, // Now contains human-readable address\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: \"Just now\",\n      status: \"active\",\n    };\n\n    // Rest of your existing implementation...\n    try {\n      const updatedEmployee = await EmployeeModel.findOneAndUpdate(\n        { id },\n        { $set: locationUpdate },\n        { new: true },\n      );\n\n      if (updatedEmployee) {\n        return res.json({ success: true, employee: updatedEmployee });\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed:\", dbError);\n    }\n\n    // Fallback to in-memory\n    const externalUsers = await fetchExternalUsers();\n    const userIndex = externalUsers.findIndex((user) => user._id === id);\n\n    if (userIndex === -1) {\n      return res.status(404).json({ error: \"Employee not found\" });\n    }\n\n    employeeStatuses[id] = employeeStatuses[id]\n      ? { ...employeeStatuses[id], ...locationUpdate }\n      : { ...locationUpdate, status: \"active\", currentTask: undefined };\n\n    const employee = await mapExternalUserToEmployee(\n      externalUsers[userIndex],\n      userIndex,\n    );\n    res.json({ success: true, employee });\n  } catch (error) {\n    console.error(\"Error updating location:\", error);\n    res.status(500).json({ error: \"Failed to update location\" });\n  }\n};\n\nexport const updateEmployeeStatus: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { status, currentTask } = req.body;\n    const update = { status, currentTask, lastUpdate: \"Just now\" };\n\n    try {\n      const employee = await EmployeeModel.findOneAndUpdate(\n        { id },\n        { $set: update },\n        { new: true },\n      );\n\n      if (employee) return res.json(employee);\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed:\", dbError);\n    }\n\n    // Fallback to in-memory\n    const externalUsers = await fetchExternalUsers();\n    const user = externalUsers.find((u) => u._id === id);\n\n    if (!user) return res.status(404).json({ error: \"Employee not found\" });\n\n    if (!employeeStatuses[id]) {\n      const location = await getEmployeeLatestLocation(id);\n      employeeStatuses[id] = {\n        status: \"active\",\n        location: location || {\n          lat: 0,\n          lng: 0,\n          address: \"Location not available\",\n          timestamp: new Date().toISOString(),\n        },\n        lastUpdate: location?.lastUpdate || \"Location not tracked\",\n      };\n    }\n\n    employeeStatuses[id] = { ...employeeStatuses[id], ...update };\n    const employee = await mapExternalUserToEmployee(\n      user,\n      externalUsers.indexOf(user),\n    );\n    res.json(employee);\n  } catch (error) {\n    console.error(\"Status update failed:\", error);\n    res.status(500).json({ error: \"Failed to update status\" });\n  }\n};\n\nexport const clearLocationCache: RequestHandler = async (req, res) => {\n  try {\n    employeeStatuses = {};\n    geocodeCache.clear();\n    res.json({ success: true, message: \"Cache cleared successfully\" });\n  } catch (error) {\n    console.error(\"Cache clear failed:\", error);\n    res.status(500).json({ error: \"Failed to clear cache\" });\n  }\n};\n\nexport const refreshEmployeeLocations: RequestHandler = async (req, res) => {\n  try {\n    employeeStatuses = {};\n    const externalUsers = await fetchExternalUsers();\n    const employees = await Promise.all(\n      externalUsers.map((user, index) =>\n        mapExternalUserToEmployee(user, index),\n      ),\n    );\n\n    try {\n      await Promise.all(\n        employees.map((employee) =>\n          EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\n            upsert: true,\n            new: true,\n          }),\n        ),\n      );\n    } catch (dbError) {\n      console.warn(\"MongoDB sync failed:\", dbError);\n    }\n\n    res.json({\n      success: true,\n      message: `Refreshed ${employees.length} employees`,\n      employees,\n    });\n  } catch (error) {\n    console.error(\"Refresh failed:\", error);\n    res.status(500).json({ error: \"Failed to refresh locations\" });\n  }\n};\n\n// Placeholder handlers\nexport const createEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for creation\" });\n\nexport const updateEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for updates\" });\n\nexport const deleteEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for deletion\" });\n","import { RequestHandler } from \"express\";\r\nimport axios from 'axios';\r\nimport NodeCache from 'node-cache';\r\nimport {\r\n  MeetingLog,\r\n  MeetingLogsResponse,\r\n  CreateMeetingRequest,\r\n} from \"@shared/api\";\r\nimport { Meeting, IMeeting } from \"../models\";\r\n\r\n// Initialize cache with 1 hour TTL\r\nconst geocodeCache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });\r\n\r\n// Helper function for reverse geocoding\r\n// Rate limiting for Nominatim API (max 1 request per second)\r\nlet lastGeocodingTime = 0;\r\nconst GEOCODING_DELAY = 1000; // 1 second\r\n\r\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\r\n  if (lat === 0 && lng === 0) return \"Location not available\";\r\n  \r\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\r\n  const cachedAddress = geocodeCache.get<string>(cacheKey);\r\n  if (cachedAddress) {\r\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cachedAddress}`);\r\n    return cachedAddress;\r\n  }\r\n\r\n  try {\r\n    // Rate limiting: wait if needed\r\n    const now = Date.now();\r\n    const timeSinceLastRequest = now - lastGeocodingTime;\r\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\r\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\r\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\r\n      await new Promise(resolve => setTimeout(resolve, waitTime));\r\n    }\r\n    lastGeocodingTime = Date.now();\r\n\r\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\r\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\r\n      params: {\r\n        format: 'json',\r\n        lat,\r\n        lon: lng,\r\n        zoom: 18,\r\n        addressdetails: 1\r\n      },\r\n      headers: {\r\n        'User-Agent': 'EmployeeTrackingApp/1.0'\r\n      },\r\n      timeout: 5000\r\n    });\r\n\r\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n    console.log(`‚úÖ Address resolved: ${address}`);\r\n    geocodeCache.set(cacheKey, address);\r\n    return address;\r\n  } catch (error) {\r\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\r\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n  }\r\n}\r\n\r\n// Enhanced meeting conversion with address handling\r\nasync function convertMeetingToMeetingLog(meeting: IMeeting): Promise<MeetingLog> {\r\n  const location = meeting.location;\r\n  const address = await reverseGeocode(location.lat, location.lng);\r\n\r\n  return {\r\n    id: meeting._id.toString(),\r\n    employeeId: meeting.employeeId,\r\n    location: {\r\n      ...location,\r\n      address // Use the geocoded address\r\n    },\r\n    startTime: meeting.startTime,\r\n    endTime: meeting.endTime,\r\n    clientName: meeting.clientName,\r\n    notes: meeting.notes,\r\n    status: meeting.status as \"started\" | \"in-progress\" | \"completed\",\r\n    trackingSessionId: meeting.trackingSessionId,\r\n    leadId: meeting.leadId,\r\n    leadInfo: meeting.leadInfo,\r\n    followUpId: meeting.followUpId, // üîπ Include follow-up ID\r\n    meetingDetails: meeting.meetingDetails,\r\n    approvalStatus: meeting.approvalStatus, // Meeting approval status\r\n    approvalReason: meeting.approvalReason, // Meeting approval reason\r\n  };\r\n}\r\n\r\n// In-memory fallback storage\r\nlet inMemoryMeetings: MeetingLog[] = [];\r\n\r\n// Export for analytics fallback\r\nexport { inMemoryMeetings };\r\n\r\nexport const getMeetings: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\r\n\r\n    // Build query\r\n    const query: any = {};\r\n    if (employeeId) query.employeeId = employeeId;\r\n    if (status) query.status = status;\r\n\r\n    if (startDate || endDate) {\r\n      query.startTime = {};\r\n      if (startDate) query.startTime.$gte = new Date(startDate as string);\r\n      if (endDate) query.startTime.$lte = new Date(endDate as string);\r\n    }\r\n\r\n    console.log(\"üì• Fetching meetings with query:\", JSON.stringify(query, null, 2));\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      // üîπ DEBUG: Count total meetings for this employee\r\n      if (employeeId) {\r\n        const totalCount = await Meeting.countDocuments({ employeeId });\r\n        console.log(`üìä Total meetings in DB for employee ${employeeId}:`, totalCount);\r\n      }\r\n      \r\n      const mongoMeetings = await Meeting.find(query)\r\n        .sort({ startTime: -1 })\r\n        .limit(parseInt(limit as string))\r\n        .lean();\r\n\r\n      // Convert all meetings with proper addresses\r\n      const meetingLogs = await Promise.all(\r\n        mongoMeetings.map(meeting => convertMeetingToMeetingLog(meeting))\r\n      );\r\n\r\n      const response: MeetingLogsResponse = {\r\n        meetings: meetingLogs,\r\n        total: meetingLogs.length,\r\n      };\r\n\r\n      console.log(`‚úÖ Found ${meetingLogs.length} meetings matching query:`, \r\n        meetingLogs.map(m => ({ id: m.id, status: m.status, followUpId: m.followUpId, client: m.clientName }))\r\n      );\r\n      \r\n      // üîπ DEBUG: If no meetings found but we expected some\r\n      if (meetingLogs.length === 0 && employeeId) {\r\n        console.warn(\"‚ö†Ô∏è No meetings found for query, checking all statuses...\");\r\n        const allMeetings = await Meeting.find({ employeeId }).lean();\r\n        console.log(\"üìã All meetings for this employee:\", \r\n          allMeetings.map(m => ({ id: m._id, status: m.status, followUpId: m.followUpId }))\r\n        );\r\n      }\r\n      \r\n      res.json(response);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    let filteredMeetings = inMemoryMeetings;\r\n\r\n    if (employeeId) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => meeting.employeeId === employeeId,\r\n      );\r\n    }\r\n\r\n    if (status) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => meeting.status === status,\r\n      );\r\n    }\r\n\r\n    if (startDate) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => new Date(meeting.startTime) >= new Date(startDate as string),\r\n      );\r\n    }\r\n\r\n    if (endDate) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => new Date(meeting.startTime) <= new Date(endDate as string),\r\n      );\r\n    }\r\n\r\n    filteredMeetings.sort(\r\n      (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\r\n    );\r\n\r\n    if (limit) {\r\n      filteredMeetings = filteredMeetings.slice(0, parseInt(limit as string));\r\n    }\r\n\r\n    const response: MeetingLogsResponse = {\r\n      meetings: filteredMeetings,\r\n      total: filteredMeetings.length,\r\n    };\r\n\r\n    console.log(`Found ${filteredMeetings.length} meetings in memory`);\r\n    res.json(response);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meetings:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch meetings\" });\r\n  }\r\n};\r\n\r\nexport const getMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const meeting = await Meeting.findById(id).lean();\r\n      if (!meeting) {\r\n        return res.status(404).json({ error: \"Meeting not found in database\" });\r\n      }\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(meeting);\r\n      console.log(\"Meeting found in MongoDB:\", meeting._id);\r\n      res.json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const meeting = inMemoryMeetings.find((meeting) => meeting.id === id);\r\n\r\n    if (!meeting) {\r\n      return res.status(404).json({ error: \"Meeting not found\" });\r\n    }\r\n\r\n    console.log(\"Meeting found in memory:\", meeting.id);\r\n    res.json(meeting);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch meeting\" });\r\n  }\r\n};\r\n\r\nexport const createMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, location, clientName, notes, leadId, leadInfo, followUpId, externalMeetingStatus } = req.body;\r\n\r\n    if (!employeeId || !location) {\r\n      return res.status(400).json({ error: \"Employee ID and location are required\" });\r\n    }\r\n\r\n    // Get human-readable address\r\n    const address = await reverseGeocode(location.lat, location.lng);\r\n\r\n    const meetingData = {\r\n      employeeId,\r\n      location: {\r\n        ...location,\r\n        address,\r\n        timestamp: new Date().toISOString()\r\n      },\r\n      startTime: new Date().toISOString(),\r\n      clientName,\r\n      notes,\r\n      status: \"in-progress\" as const,\r\n      leadId: leadId || undefined,\r\n      leadInfo: leadInfo || undefined,\r\n      followUpId: followUpId || undefined, // üîπ Store follow-up meeting ID\r\n      externalMeetingStatus: externalMeetingStatus || undefined, // üîπ NEW: Store external meeting status\r\n    };\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const newMeeting = new Meeting(meetingData);\r\n      const savedMeeting = await newMeeting.save();\r\n      const meetingLog = await convertMeetingToMeetingLog(savedMeeting);\r\n\r\n      console.log(\"‚úÖ Meeting saved to MongoDB:\", {\r\n        id: savedMeeting._id,\r\n        employeeId: savedMeeting.employeeId,\r\n        followUpId: savedMeeting.followUpId,\r\n        status: savedMeeting.status,\r\n        clientName: savedMeeting.clientName\r\n      });\r\n      \r\n      // üîπ VERIFICATION: Immediately query to confirm it was saved\r\n      try {\r\n        const verification = await Meeting.findById(savedMeeting._id);\r\n        if (verification) {\r\n          console.log(\"‚úÖ VERIFIED: Meeting exists in database\");\r\n          console.log(\"‚úÖ VERIFIED followUpId:\", verification.followUpId);\r\n          console.log(\"‚úÖ VERIFIED status:\", verification.status);\r\n          \r\n          // Also verify we can find it by followUpId\r\n          if (verification.followUpId) {\r\n            const byFollowUpId = await Meeting.findOne({ \r\n              followUpId: verification.followUpId,\r\n              status: { $in: [\"in-progress\", \"started\"] }\r\n            });\r\n            if (byFollowUpId) {\r\n              console.log(\"‚úÖ VERIFIED: Can find meeting by followUpId\");\r\n            } else {\r\n              console.error(\"‚ùå VERIFICATION FAILED: Cannot find meeting by followUpId!\");\r\n            }\r\n          }\r\n        } else {\r\n          console.error(\"‚ùå VERIFICATION FAILED: Meeting not found after save!\");\r\n        }\r\n      } catch (verifyError) {\r\n        console.error(\"‚ùå VERIFICATION ERROR:\", verifyError);\r\n      }\r\n      \r\n      res.status(201).json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const meetingId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const meetingLog: MeetingLog = {\r\n      id: meetingId,\r\n      employeeId: meetingData.employeeId,\r\n      location: meetingData.location,\r\n      startTime: meetingData.startTime,\r\n      clientName: meetingData.clientName,\r\n      notes: meetingData.notes,\r\n      status: meetingData.status,\r\n      leadId: meetingData.leadId,\r\n      leadInfo: meetingData.leadInfo,\r\n    };\r\n\r\n    inMemoryMeetings.push(meetingLog);\r\n\r\n    console.log(\"Meeting saved to memory:\", meetingId);\r\n    res.status(201).json(meetingLog);\r\n  } catch (error) {\r\n    console.error(\"Error creating meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to create meeting\" });\r\n  }\r\n};\r\n\r\nexport const updateMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const updates = req.body;\r\n\r\n    console.log(`üìù Updating meeting ${id} with status: ${updates.status}`);\r\n    console.log(`üìç End location in request:`, updates.endLocation);\r\n\r\n    // Handle meeting completion\r\n    if (updates.status === \"completed\" && !updates.endTime) {\r\n      updates.endTime = new Date().toISOString();\r\n    }\r\n\r\n    // Validate meeting details\r\n    if (updates.meetingDetails && !updates.meetingDetails.discussion?.trim()) {\r\n      return res.status(400).json({ error: \"Discussion details are required\" });\r\n    }\r\n\r\n    // üîπ CRITICAL FIX: Capture end location when meeting is completed\r\n    if (updates.status === \"completed\" && updates.endLocation) {\r\n      console.log(\"üìç Capturing end location for meeting:\", JSON.stringify(updates.endLocation, null, 2));\r\n      // Store end location in the location.endLocation field\r\n      updates[\"location.endLocation\"] = {\r\n        lat: updates.endLocation.lat,\r\n        lng: updates.endLocation.lng,\r\n        address: updates.endLocation.address || `${updates.endLocation.lat.toFixed(6)}, ${updates.endLocation.lng.toFixed(6)}`,\r\n        timestamp: updates.endLocation.timestamp || new Date().toISOString(),\r\n      };\r\n      console.log(\"‚úÖ End location formatted:\", JSON.stringify(updates[\"location.endLocation\"], null, 2));\r\n      // Remove the top-level endLocation field as it's now nested\r\n      delete updates.endLocation;\r\n    } else if (updates.status === \"completed\") {\r\n      console.warn(\"‚ö†Ô∏è Meeting completed but no endLocation provided in request!\");\r\n    }\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n        id,\r\n        { $set: updates },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedMeeting) {\r\n        return res.status(404).json({ error: \"Meeting not found in database\" });\r\n      }\r\n\r\n      console.log(\"Meeting updated in MongoDB:\", updatedMeeting._id);\r\n      if (updatedMeeting.location?.endLocation) {\r\n        console.log(\"‚úÖ End location saved:\", updatedMeeting.location.endLocation);\r\n      }\r\n      \r\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n      res.json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const meetingIndex = inMemoryMeetings.findIndex((meeting) => meeting.id === id);\r\n    if (meetingIndex === -1) {\r\n      return res.status(404).json({ error: \"Meeting not found\" });\r\n    }\r\n\r\n    inMemoryMeetings[meetingIndex] = {\r\n      ...inMemoryMeetings[meetingIndex],\r\n      ...updates,\r\n    };\r\n\r\n    console.log(\"Meeting updated in memory:\", id);\r\n    res.json(inMemoryMeetings[meetingIndex]);\r\n  } catch (error) {\r\n    console.error(\"Error updating meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to update meeting\" });\r\n  }\r\n};\r\n\r\nexport const deleteMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const deletedMeeting = await Meeting.findByIdAndDelete(id);\r\n      if (!deletedMeeting) {\r\n        return res.status(404).json({ error: \"Meeting not found\" });\r\n      }\r\n\r\n      res.status(204).send();\r\n      return;\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB delete failed:\", dbError);\r\n      throw dbError;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error deleting meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to delete meeting\" });\r\n  }\r\n};\r\n\r\n// üîπ NEW ENDPOINT: Get active meeting for employee (by employeeId or followUpId)\r\nexport const getActiveMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, followUpId } = req.query;\r\n\r\n    if (!employeeId && !followUpId) {\r\n      return res.status(400).json({ \r\n        error: \"Either employeeId or followUpId is required\" \r\n      });\r\n    }\r\n\r\n    console.log(\"üîç Searching for active meeting:\", { employeeId, followUpId });\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      // Build query to find active meetings\r\n      const query: any = {\r\n        status: { $in: [\"in-progress\", \"started\"] }\r\n      };\r\n\r\n      if (followUpId) {\r\n        // If followUpId is provided, search by it (most specific)\r\n        query.followUpId = followUpId;\r\n      } else if (employeeId) {\r\n        // Otherwise search by employeeId\r\n        query.employeeId = employeeId;\r\n      }\r\n\r\n      console.log(\"üì• Query:\", JSON.stringify(query, null, 2));\r\n\r\n      const activeMeeting = await Meeting.findOne(query)\r\n        .sort({ startTime: -1 }) // Get the most recent one\r\n        .lean();\r\n\r\n      if (!activeMeeting) {\r\n        console.log(\"‚ö†Ô∏è No active meeting found with query:\", JSON.stringify(query, null, 2));\r\n        \r\n        // üîπ DEBUG: Check what meetings exist for this employee\r\n        if (employeeId) {\r\n          const allMeetings = await Meeting.find({ employeeId }).lean();\r\n          console.log(\"üìã All meetings for employee:\", allMeetings.map(m => ({\r\n            id: m._id,\r\n            status: m.status,\r\n            followUpId: m.followUpId,\r\n            startTime: m.startTime\r\n          })));\r\n        }\r\n        \r\n        // üîπ DEBUG: Check if there are ANY active meetings\r\n        const anyActiveMeetings = await Meeting.find({ \r\n          status: { $in: [\"in-progress\", \"started\"] } \r\n        }).lean();\r\n        console.log(\"üìã All active meetings in database:\", anyActiveMeetings.map(m => ({\r\n          id: m._id,\r\n          employeeId: m.employeeId,\r\n          followUpId: m.followUpId,\r\n          status: m.status\r\n        })));\r\n        \r\n        return res.status(404).json({ \r\n          error: \"No active meeting found\",\r\n          employeeId,\r\n          followUpId,\r\n          debug: {\r\n            totalMeetingsForEmployee: allMeetings?.length || 0,\r\n            totalActiveMeetings: anyActiveMeetings?.length || 0\r\n          }\r\n        });\r\n      }\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(activeMeeting);\r\n      console.log(\"‚úÖ Active meeting found:\", {\r\n        id: meetingLog.id,\r\n        followUpId: meetingLog.followUpId,\r\n        status: meetingLog.status,\r\n        client: meetingLog.clientName\r\n      });\r\n\r\n      res.json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB query failed:\", dbError);\r\n      return res.status(500).json({ error: \"Database query failed\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error getting active meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to get active meeting\" });\r\n  }\r\n};\r\n\r\n// Add this endpoint to clear geocoding cache\r\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\r\n  try {\r\n    geocodeCache.flushAll();\r\n    res.json({ success: true, message: \"Geocode cache cleared\" });\r\n  } catch (error) {\r\n    console.error(\"Error clearing cache:\", error);\r\n    res.status(500).json({ error: \"Failed to clear cache\" });\r\n  }\r\n};\r\n\r\n// Update meeting approval status\r\nexport const updateMeetingApproval: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { approvalStatus, approvalReason } = req.body;\r\n\r\n    // Validate inputs\r\n    if (!approvalStatus || !['ok', 'not_ok'].includes(approvalStatus)) {\r\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok) is required\" });\r\n    }\r\n\r\n    if (!approvalReason || !approvalReason.trim()) {\r\n      return res.status(400).json({ error: \"Approval reason is required\" });\r\n    }\r\n\r\n    console.log(`üìù Updating meeting approval ${id}:`, { approvalStatus, approvalReason });\r\n\r\n    try {\r\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n        id,\r\n        { \r\n          $set: { \r\n            approvalStatus, \r\n            approvalReason: approvalReason.trim() \r\n          } \r\n        },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedMeeting) {\r\n        return res.status(404).json({ error: \"Meeting not found\" });\r\n      }\r\n\r\n      console.log(\"‚úÖ Meeting approval updated:\", updatedMeeting._id);\r\n      \r\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n      res.json({ \r\n        success: true, \r\n        meeting: meetingLog,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason\r\n      });\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB update failed:\", dbError);\r\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating meeting approval:\", error);\r\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n  }\r\n};\r\n\r\n// Update meeting approval by composite details (when meetingId is not available)\r\nexport const updateMeetingApprovalByDetails: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, date, companyName, meetingInTime, approvalStatus, approvalReason } = req.body;\r\n\r\n    // Validate inputs\r\n    if (!employeeId || !date || !companyName || !meetingInTime) {\r\n      return res.status(400).json({ error: \"Employee ID, date, company name, and meeting time are required\" });\r\n    }\r\n\r\n    if (!approvalStatus || !['ok', 'not_ok'].includes(approvalStatus)) {\r\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok) is required\" });\r\n    }\r\n\r\n    if (!approvalReason || !approvalReason.trim()) {\r\n      return res.status(400).json({ error: \"Approval reason is required\" });\r\n    }\r\n\r\n    console.log(`üìù Updating meeting approval by details:`, { \r\n      employeeId, \r\n      date, \r\n      companyName, \r\n      meetingInTime,\r\n      approvalStatus, \r\n      approvalReason \r\n    });\r\n\r\n    try {\r\n      // Parse the date and time to create a date range for the query\r\n      const startOfDayDate = new Date(date);\r\n      startOfDayDate.setHours(0, 0, 0, 0);\r\n      \r\n      const endOfDayDate = new Date(date);\r\n      endOfDayDate.setHours(23, 59, 59, 999);\r\n\r\n      // Find the meeting by composite details\r\n      const meeting = await Meeting.findOne({\r\n        employeeId: employeeId,\r\n        clientName: companyName,\r\n        startTime: {\r\n          $gte: startOfDayDate.toISOString(),\r\n          $lte: endOfDayDate.toISOString()\r\n        }\r\n      }).lean();\r\n\r\n      if (!meeting) {\r\n        console.error(\"‚ùå Meeting not found with details:\", { employeeId, date, companyName });\r\n        return res.status(404).json({ \r\n          error: \"Meeting not found\",\r\n          details: { employeeId, date, companyName, meetingInTime }\r\n        });\r\n      }\r\n\r\n      console.log(`‚úÖ Found meeting by details: ${meeting._id}`);\r\n\r\n      // Update the meeting\r\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n        meeting._id,\r\n        { \r\n          $set: { \r\n            approvalStatus, \r\n            approvalReason: approvalReason.trim() \r\n          } \r\n        },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedMeeting) {\r\n        return res.status(404).json({ error: \"Failed to update meeting\" });\r\n      }\r\n\r\n      console.log(\"‚úÖ Meeting approval updated by details:\", updatedMeeting._id);\r\n      \r\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n      res.json({ \r\n        success: true, \r\n        meeting: meetingLog,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason\r\n      });\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB update failed:\", dbError);\r\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating meeting approval by details:\", error);\r\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\nimport axios from \"axios\";\nimport {\n  TrackingSession as TrackingSessionType,\n  TrackingSessionResponse,\n  LocationData,\n  MeetingDetails,\n  MeetingHistoryResponse,\n} from \"@shared/api\";\nimport { MeetingHistory, TrackingSession as TrackingSessionModel } from \"../models\";\nimport type { IMeetingHistory, ITrackingSession } from \"../models\";\n\n// Rate limiting for Nominatim API (max 1 request per second)\nlet lastGeocodingTime = 0;\nconst GEOCODING_DELAY = 1000; // 1 second\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\nconst GEOCACHE_TTL = 3600000; // 1 hour\n\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n  \n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n  if (cached && cached.expires > Date.now()) {\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\n    return cached.address;\n  }\n\n  try {\n    // Rate limiting: wait if needed\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastGeocodingTime;\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    lastGeocodingTime = Date.now();\n\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\n      params: {\n        format: 'json',\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1\n      },\n      headers: {\n        'User-Agent': 'EmployeeTrackingApp/1.0'\n      },\n      timeout: 5000\n    });\n\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n    console.log(`‚úÖ Address resolved: ${address}`);\n    \n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL\n    });\n    \n    return address;\n  } catch (error) {\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  }\n}\n\n// In-memory storage for demo purposes\nlet trackingSessions: TrackingSessionType[] = [];\nlet sessionIdCounter = 1;\n\n// In-memory storage for meeting history with customer details\nlet meetingHistory: Array<{\n  id: string;\n  sessionId: string;\n  employeeId: string;\n  meetingDetails: MeetingDetails;\n  timestamp: string;\n  leadId?: string;\n  leadInfo?: any;\n}> = [];\nlet historyIdCounter = 1;\n\nexport const getTrackingSessions: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\n\n    // Build MongoDB query\n    const query: any = {};\n\n    if (employeeId) {\n      query.employeeId = employeeId;\n    }\n\n    if (status) {\n      query.status = status;\n    }\n\n    if (startDate || endDate) {\n      query.startTime = {};\n      if (startDate) {\n        query.startTime.$gte = new Date(startDate as string).toISOString();\n      }\n      if (endDate) {\n        query.startTime.$lte = new Date(endDate as string).toISOString();\n      }\n    }\n\n    console.log(\"Fetching tracking sessions with query:\", query);\n\n    // Try to fetch from MongoDB first\n    try {\n      const mongoSessions = await TrackingSessionModel.find(query)\n        .sort({ startTime: -1 })\n        .limit(parseInt(limit as string))\n        .lean();\n\n      const response: TrackingSessionResponse = {\n        sessions: mongoSessions as any as TrackingSessionType[],\n        total: mongoSessions.length,\n      };\n\n      console.log(`Found ${mongoSessions.length} tracking sessions in MongoDB`);\n      res.json(response);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    let filteredSessions = trackingSessions;\n\n    if (employeeId) {\n      filteredSessions = filteredSessions.filter(\n        (session) => session.employeeId === employeeId,\n      );\n    }\n\n    if (status) {\n      filteredSessions = filteredSessions.filter(\n        (session) => session.status === status,\n      );\n    }\n\n    if (startDate) {\n      filteredSessions = filteredSessions.filter(\n        (session) =>\n          new Date(session.startTime) >= new Date(startDate as string),\n      );\n    }\n\n    if (endDate) {\n      filteredSessions = filteredSessions.filter(\n        (session) => new Date(session.startTime) <= new Date(endDate as string),\n      );\n    }\n\n    filteredSessions.sort(\n      (a, b) =>\n        new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\n    );\n\n    if (limit) {\n      filteredSessions = filteredSessions.slice(0, parseInt(limit as string));\n    }\n\n    const response: TrackingSessionResponse = {\n      sessions: filteredSessions,\n      total: filteredSessions.length,\n    };\n\n    console.log(`Found ${filteredSessions.length} tracking sessions in memory`);\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error fetching tracking sessions:\", error);\n    res.status(500).json({ error: \"Failed to fetch tracking sessions\" });\n  }\n};\n\nexport const createTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id, employeeId, startTime, startLocation, route, totalDistance, status } = req.body;\n\n    if (!employeeId || !startLocation) {\n      return res.status(400).json({\n        error: \"Employee ID and start location are required\",\n      });\n    }\n\n    console.log(\"üìç Creating tracking session:\", { id, employeeId, startTime });\n\n    // üîπ Resolve start location address if not already resolved\n    let resolvedStartLocation = { ...startLocation };\n    if (startLocation.lat && startLocation.lng) {\n      try {\n        console.log(\"üó∫Ô∏è Resolving start location address...\");\n        const address = await reverseGeocode(startLocation.lat, startLocation.lng);\n        resolvedStartLocation.address = address;\n        console.log(\"‚úÖ Start location address resolved:\", address);\n      } catch (error) {\n        console.warn(\"‚ö†Ô∏è Failed to resolve start location address:\", error);\n        // Keep the address as-is\n      }\n    }\n\n    const sessionData = {\n      id: id || `session_${String(sessionIdCounter++).padStart(3, \"0\")}`,\n      employeeId,\n      startTime: startTime || new Date().toISOString(),\n      startLocation: {\n        ...resolvedStartLocation,\n        timestamp: resolvedStartLocation.timestamp || new Date().toISOString(),\n      },\n      route: route || [resolvedStartLocation],\n      totalDistance: totalDistance || 0,\n      status: status || \"active\" as const,\n    };\n\n    // Try to save to MongoDB first\n    try {\n      const newSession = new TrackingSessionModel(sessionData);\n      const savedSession = await newSession.save();\n\n      console.log(\"Tracking session saved to MongoDB:\", savedSession.id);\n      res.status(201).json(savedSession);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const newSession = sessionData;\n    trackingSessions.push(newSession);\n\n    console.log(\"Tracking session saved to memory:\", newSession.id);\n    res.status(201).json(newSession);\n  } catch (error) {\n    console.error(\"Error creating tracking session:\", error);\n    res.status(500).json({ error: \"Failed to create tracking session\" });\n  }\n};\n\nexport const updateTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n\n    console.log(\"üìç Updating tracking session:\", id);\n    console.log(\"üìç Updates:\", JSON.stringify(updates, null, 2));\n\n    // If ending the session, set end time and calculate duration\n    if (updates.status === \"completed\" && !updates.endTime) {\n      updates.endTime = new Date().toISOString();\n      // Duration calculation will be done in the database or after fetch\n    }\n\n    // üîπ CRITICAL FIX: Resolve end location address if coordinates provided\n    if (updates.endLocation && updates.endLocation.lat && updates.endLocation.lng) {\n      try {\n        console.log(\"üó∫Ô∏è Resolving end location address...\");\n        const address = await reverseGeocode(updates.endLocation.lat, updates.endLocation.lng);\n        updates.endLocation.address = address;\n        console.log(\"‚úÖ End location address resolved:\", address);\n      } catch (error) {\n        console.warn(\"‚ö†Ô∏è Failed to resolve end location address:\", error);\n        // Keep the address as-is (might be coordinates)\n      }\n    }\n\n    // Try to update in MongoDB first\n    try {\n      const updatedSession = await TrackingSessionModel.findOneAndUpdate(\n        { id },\n        { $set: updates },\n        { new: true, runValidators: true }\n      );\n\n      if (!updatedSession) {\n        console.warn(\"‚ö†Ô∏è Tracking session not found in database:\", id);\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\n      }\n\n      // Calculate duration if completing session\n      if (updates.status === \"completed\" && updatedSession.startTime && updatedSession.endTime) {\n        const startTime = new Date(updatedSession.startTime).getTime();\n        const endTime = new Date(updatedSession.endTime).getTime();\n        const duration = Math.floor((endTime - startTime) / 1000);\n\n        await TrackingSessionModel.findOneAndUpdate(\n          { id },\n          { $set: { duration } },\n          { new: true }\n        );\n        updatedSession.duration = duration;\n        console.log(\"‚úÖ Duration calculated:\", duration, \"seconds\");\n      }\n\n      console.log(\"‚úÖ Tracking session updated in MongoDB:\", updatedSession.id);\n      if (updatedSession.endLocation) {\n        console.log(\"‚úÖ End location saved:\", updatedSession.endLocation);\n      }\n      res.json(updatedSession);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    // Calculate duration for in-memory sessions\n    if (updates.status === \"completed\" && !trackingSessions[sessionIndex].endTime) {\n      const startTime = new Date(trackingSessions[sessionIndex].startTime).getTime();\n      const endTime = new Date(updates.endTime).getTime();\n      updates.duration = Math.floor((endTime - startTime) / 1000);\n    }\n\n    trackingSessions[sessionIndex] = {\n      ...trackingSessions[sessionIndex],\n      ...updates,\n    };\n\n    console.log(\"Tracking session updated in memory:\", trackingSessions[sessionIndex].id);\n    res.json(trackingSessions[sessionIndex]);\n  } catch (error) {\n    console.error(\"Error updating tracking session:\", error);\n    res.status(500).json({ error: \"Failed to update tracking session\" });\n  }\n};\n\nexport const addLocationToRoute: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { location } = req.body;\n\n    if (!location) {\n      return res.status(400).json({ error: \"Location is required\" });\n    }\n\n    // Add timestamp to location if not provided\n    const locationWithTimestamp: LocationData = {\n      ...location,\n      timestamp: location.timestamp || new Date().toISOString(),\n    };\n\n    // Try to update in MongoDB first\n    try {\n      const session = await TrackingSessionModel.findOne({ id });\n      if (!session) {\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\n      }\n\n      // Add to route\n      session.route.push(locationWithTimestamp);\n\n      // Calculate distance if this isn't the first location\n      if (session.route.length > 1) {\n        const prevLocation = session.route[session.route.length - 2];\n        const distance = calculateDistance(\n          prevLocation.lat,\n          prevLocation.lng,\n          location.lat,\n          location.lng,\n        );\n        session.totalDistance += distance;\n      }\n\n      await session.save();\n\n      console.log(\"Location added to route in MongoDB:\", session.id);\n      res.json(session);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    const session = trackingSessions[sessionIndex];\n\n    // Add to route\n    session.route.push(locationWithTimestamp);\n\n    // Calculate distance if this isn't the first location\n    if (session.route.length > 1) {\n      const prevLocation = session.route[session.route.length - 2];\n      const distance = calculateDistance(\n        prevLocation.lat,\n        prevLocation.lng,\n        location.lat,\n        location.lng,\n      );\n      session.totalDistance += distance;\n    }\n\n    console.log(\"Location added to route in memory:\", session.id);\n    res.json(session);\n  } catch (error) {\n    console.error(\"Error adding location to route:\", error);\n    res.status(500).json({ error: \"Failed to add location to route\" });\n  }\n};\n\nexport const getTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Try to fetch from MongoDB first\n    try {\n      const session = await TrackingSessionModel.findOne({ id });\n      if (session) {\n        console.log(\"Tracking session found in MongoDB:\", session.id);\n        res.json(session);\n        return;\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const session = trackingSessions.find((session) => session.id === id);\n\n    if (!session) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    console.log(\"Tracking session found in memory:\", session.id);\n    res.json(session);\n  } catch (error) {\n    console.error(\"Error fetching tracking session:\", error);\n    res.status(500).json({ error: \"Failed to fetch tracking session\" });\n  }\n};\n\nexport const deleteTrackingSession: RequestHandler = (req, res) => {\n  try {\n    const { id } = req.params;\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    trackingSessions.splice(sessionIndex, 1);\n    res.status(204).send();\n  } catch (error) {\n    console.error(\"Error deleting tracking session:\", error);\n    res.status(500).json({ error: \"Failed to delete tracking session\" });\n  }\n};\n\n// Meeting History endpoints\nexport const getMeetingHistory: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, page = 1, limit = 50, dateRange, startDate, endDate, leadId } = req.query;\n\n    // Build MongoDB query\n    const query: any = {};\n    if (employeeId) {\n      query.employeeId = employeeId;\n    }\n    if (leadId) {\n      query.leadId = leadId;\n    }\n\n    // Add date filtering\n    if (dateRange || startDate || endDate) {\n      const now = new Date();\n      let start: Date, end: Date;\n\n      if (dateRange && dateRange !== \"custom\") {\n        switch (dateRange) {\n          case \"all\":\n            // Don't set start/end to include all meetings\n            break;\n          case \"today\":\n            start = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\n            break;\n          case \"yesterday\":\n            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n            start = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());\n            end = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);\n            break;\n          case \"week\":\n            const startOfWeek = new Date(now.getTime() - (now.getDay() || 7) * 24 * 60 * 60 * 1000);\n            start = new Date(startOfWeek.getFullYear(), startOfWeek.getMonth(), startOfWeek.getDate());\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\n            break;\n          case \"month\":\n            start = new Date(now.getFullYear(), now.getMonth(), 1);\n            end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);\n            break;\n        }\n      } else if (startDate && endDate) {\n        start = new Date(startDate as string);\n        end = new Date(endDate as string);\n        end.setHours(23, 59, 59, 999);\n      }\n\n      if (start && end) {\n        query.timestamp = {\n          $gte: start.toISOString(),\n          $lte: end.toISOString()\n        };\n        console.log(`Meeting history date filter: ${start.toISOString()} to ${end.toISOString()}`);\n      }\n    }\n\n    console.log(\"=== MEETING HISTORY REQUEST ===\");\n    console.log(\"Meeting history params:\", { employeeId, leadId, dateRange, startDate, endDate });\n    console.log(\"Built MongoDB query:\", JSON.stringify(query, null, 2));\n\n    // Debug: Check what data exists in the database\n    if (!employeeId && dateRange === \"all\") {\n      try {\n        const totalMeetings = await MeetingHistory.countDocuments();\n        const uniqueEmployeeIds = await MeetingHistory.distinct('employeeId');\n        const uniqueLeadIds = await MeetingHistory.distinct('leadId');\n        console.log(\"=== DATABASE DEBUG INFO ===\");\n        console.log(`Total meetings in database: ${totalMeetings}`);\n        console.log(`Unique employee IDs (${uniqueEmployeeIds.length}):`, uniqueEmployeeIds);\n        console.log(`Unique lead IDs (${uniqueLeadIds.filter(id => id).length}):`, uniqueLeadIds.filter(id => id));\n\n        // Check for the specific lead IDs mentioned by user\n        const specificLeads = await MeetingHistory.find({\n          leadId: { $in: ['JBDSL-0044', 'JBDSL-0001'] }\n        }).lean();\n        console.log(`Meetings with JBDSL-0044 or JBDSL-0001: ${specificLeads.length}`);\n        specificLeads.forEach((meeting) => {\n          console.log(`  - Lead: ${meeting.leadId}, Employee: ${meeting.employeeId}, Customer: ${meeting.meetingDetails?.customerName || meeting.meetingDetails?.customers?.[0]?.customerName}`);\n        });\n      } catch (debugError) {\n        console.log(\"Debug info failed:\", debugError.message);\n      }\n    }\n\n    // Try to fetch from MongoDB first\n    try {\n      const pageNum = parseInt(page as string);\n      const limitNum = parseInt(limit as string);\n      const skip = (pageNum - 1) * limitNum;\n\n      const mongoHistory = await MeetingHistory.find(query)\n        .sort({ timestamp: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await MeetingHistory.countDocuments(query);\n\n      const response = {\n        meetings: mongoHistory,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${mongoHistory.length} meeting history entries in MongoDB for employeeId: ${employeeId}`);\n      if (mongoHistory.length > 0) {\n        console.log(\"Sample meeting data:\", {\n          firstMeeting: {\n            employeeId: mongoHistory[0].employeeId,\n            leadId: mongoHistory[0].leadId,\n            customerName: mongoHistory[0].meetingDetails?.customerName,\n            timestamp: mongoHistory[0].timestamp\n          }\n        });\n        // Show all unique employee IDs in the results\n        const uniqueEmployeeIds = [...new Set(mongoHistory.map(m => m.employeeId))];\n        console.log(\"All employee IDs in results:\", uniqueEmployeeIds);\n      }\n      res.json(response);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    let filteredHistory = meetingHistory;\n\n    if (employeeId) {\n      filteredHistory = filteredHistory.filter(\n        (history) => history.employeeId === employeeId,\n      );\n    }\n\n    if (leadId) {\n      filteredHistory = filteredHistory.filter(\n        (history) => history.leadId === leadId,\n      );\n    }\n\n    filteredHistory.sort(\n      (a, b) =>\n        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\n    );\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const startIndex = (pageNum - 1) * limitNum;\n    const endIndex = startIndex + limitNum;\n    const paginatedHistory = filteredHistory.slice(startIndex, endIndex);\n\n    const response = {\n      meetings: paginatedHistory,\n      total: filteredHistory.length,\n      page: pageNum,\n      totalPages: Math.ceil(filteredHistory.length / limitNum),\n    };\n\n    console.log(`Found ${paginatedHistory.length} meeting history entries in memory`);\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error fetching meeting history:\", error);\n    res.status(500).json({ error: \"Failed to fetch meeting history\" });\n  }\n};\n\nexport const addMeetingToHistory: RequestHandler = async (req, res) => {\n  try {\n    const { sessionId, employeeId, meetingDetails, leadId, leadInfo } = req.body;\n\n    console.log(\"Adding meeting to history:\", {\n      sessionId,\n      employeeId,\n      meetingDetails,\n      leadId,\n      leadInfo,\n    });\n\n    if (!sessionId || !employeeId || !meetingDetails) {\n      return res.status(400).json({\n        error: \"Session ID, employee ID, and meeting details are required\",\n      });\n    }\n\n    // Validate that discussion is provided (mandatory field)\n    if (!meetingDetails.discussion || !meetingDetails.discussion.trim()) {\n      return res.status(400).json({\n        error: \"Discussion details are required\",\n      });\n    }\n\n    // Validate customers array or legacy customer fields\n    if (!meetingDetails.customers || meetingDetails.customers.length === 0) {\n      // Check if legacy fields are provided for backward compatibility\n      if (!meetingDetails.customerName || !meetingDetails.customerEmployeeName) {\n        return res.status(400).json({\n          error: \"At least one customer contact is required\",\n        });\n      }\n\n      // Convert legacy fields to new format\n      meetingDetails.customers = [{\n        customerName: meetingDetails.customerName,\n        customerEmployeeName: meetingDetails.customerEmployeeName,\n        customerEmail: meetingDetails.customerEmail || \"\",\n        customerMobile: meetingDetails.customerMobile || \"\",\n        customerDesignation: meetingDetails.customerDesignation || \"\",\n        customerDepartment: meetingDetails.customerDepartment || \"\",\n      }];\n    }\n\n    const historyData = {\n      sessionId,\n      employeeId,\n      meetingDetails,\n      timestamp: new Date().toISOString(),\n      leadId: leadId || undefined,\n      leadInfo: leadInfo || undefined,\n    };\n\n    // Try to save to MongoDB first\n    try {\n      const newHistoryEntry = new MeetingHistory(historyData);\n      const savedHistory = await newHistoryEntry.save();\n\n      console.log(\"Meeting history saved to MongoDB:\", savedHistory._id);\n\n      // Format the response to match the expected structure\n      const formattedResponse = {\n        id: savedHistory._id.toString(),\n        sessionId: savedHistory.sessionId,\n        employeeId: savedHistory.employeeId,\n        meetingDetails: savedHistory.meetingDetails,\n        timestamp: savedHistory.timestamp,\n        leadId: savedHistory.leadId,\n        leadInfo: savedHistory.leadInfo,\n        _id: savedHistory._id,\n        createdAt: savedHistory.createdAt,\n        updatedAt: savedHistory.updatedAt\n      };\n\n      res.status(201).json(formattedResponse);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\n      // Log the exact error for debugging\n      console.error(\"MongoDB error details:\", {\n        message: dbError.message,\n        stack: dbError.stack,\n        data: historyData\n      });\n    }\n\n    // Fallback to in-memory storage\n    const newHistoryEntry = {\n      id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\n      ...historyData,\n    };\n\n    meetingHistory.push(newHistoryEntry);\n\n    console.log(\"Meeting history entry added to memory:\", newHistoryEntry);\n    console.log(\"Total meeting history entries:\", meetingHistory.length);\n\n    res.status(201).json(newHistoryEntry);\n  } catch (error) {\n    console.error(\"Error adding meeting to history:\", error);\n    res.status(500).json({ error: \"Failed to add meeting to history\" });\n  }\n};\n\n// Save incomplete meeting remarks (called on logout with pending meetings)\nexport const saveIncompleteMeetingRemark: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, reason, pendingMeetings } = req.body;\n\n    if (!employeeId || !pendingMeetings || pendingMeetings.length === 0) {\n      return res.status(400).json({\n        error: \"Employee ID and at least one pending meeting are required\",\n      });\n    }\n\n    console.log(\"=== SAVING INCOMPLETE MEETING REMARKS ===\");\n    console.log(\"Employee ID:\", employeeId, \"Type:\", typeof employeeId);\n    console.log(\"General reason:\", reason);\n    console.log(\"Pending meetings count:\", pendingMeetings.length);\n\n    // Save a history entry for each incomplete meeting with its individual reason\n    const savedEntries = await Promise.all(\n      pendingMeetings.map(async (meeting: any, idx: number) => {\n        // Use individual meeting reason if provided, otherwise fall back to general reason\n        const meetingReason = meeting.incompleteReason || reason || \"Meeting not completed\";\n        \n        const meetingDetails = {\n          discussion: meetingReason,\n          incomplete: true,\n          incompleteReason: meetingReason,\n          customers: [\n            {\n              customerName: meeting.customerName || \"\",\n              customerEmployeeName: meeting.customerName || \"\",\n              customerEmail: meeting.customerEmail || \"\",\n              customerMobile: meeting.customerMobile || \"\",\n              customerDesignation: meeting.customerDesignation || \"\",\n              customerDepartment: \"\",\n            },\n          ],\n        };\n\n        const historyData = {\n          sessionId: `logout_incomplete_${Date.now()}_${idx}`,\n          employeeId: String(employeeId), // Ensure it's a string\n          meetingDetails,\n          timestamp: new Date().toISOString(),\n          leadId: meeting.leadId,\n          leadInfo: {\n            id: meeting.leadId,\n            companyName: meeting.companyName,\n          },\n        };\n\n        console.log(`Processing meeting ${idx + 1}:`, {\n          employeeId: historyData.employeeId,\n          companyName: meeting.companyName,\n          customerName: meeting.customerName,\n          leadId: meeting.leadId,\n          reason: meetingReason,\n        });\n\n        // Try to save to MongoDB first\n        try {\n          const newEntry = new MeetingHistory(historyData);\n          const saved = await newEntry.save();\n          console.log(\"‚úì Incomplete meeting remark saved to MongoDB:\", saved._id);\n          console.log(\"  - Company:\", meeting.companyName);\n          console.log(\"  - Saved employeeId:\", saved.employeeId);\n          console.log(\"  - Saved incomplete flag:\", saved.meetingDetails?.incomplete);\n          console.log(\"  - Reason:\", meetingReason);\n          return {\n            success: true,\n            meetingId: meeting._id,\n            historyId: saved._id,\n            companyName: meeting.companyName,\n            reason: meetingReason,\n          };\n        } catch (dbError) {\n          console.warn(\"MongoDB save failed for incomplete meeting remark:\", dbError);\n          // Fallback: save to in-memory\n          meetingHistory.push({\n            id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\n            ...historyData,\n          });\n          console.log(\"‚úì Incomplete meeting remark saved to in-memory storage\");\n          return { \n            success: true, \n            meetingId: meeting._id,\n            companyName: meeting.companyName,\n            reason: meetingReason,\n          };\n        }\n      }),\n    );\n\n    console.log(\"=== SAVED INCOMPLETE MEETING REMARKS ===\");\n    console.log(\"Total entries saved:\", savedEntries.length);\n    savedEntries.forEach((entry, idx) => {\n      console.log(`  ${idx + 1}. ${entry.companyName}: ${entry.reason}`);\n    });\n\n    res.status(201).json({\n      success: true,\n      reason,\n      meetingsProcessed: savedEntries.length,\n      entries: savedEntries,\n    });\n  } catch (error) {\n    console.error(\"Error saving incomplete meeting remarks:\", error);\n    res.status(500).json({ error: \"Failed to save incomplete meeting remarks\" });\n  }\n};\n\n\nexport const getIncompleteMeetingRemark: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.query;\n\n    if (!employeeId) {\n      return res.status(400).json({\n        error: \"Employee ID is required\",\n      });\n    }\n\n    console.log(\"Fetching incomplete meeting remarks for employee:\", employeeId);\n    console.log(\"Query filter - employeeId type:\", typeof employeeId, \"value:\", employeeId);\n\n    // Try to fetch from MongoDB first\n    try {\n      // Build query - ensure employeeId is a string for comparison\n      const query = {\n        employeeId: String(employeeId),\n        \"meetingDetails.incomplete\": true,\n      };\n      \n      console.log(\"MongoDB query:\", JSON.stringify(query, null, 2));\n\n      const incompleteMeetings = await MeetingHistory.find(query).lean();\n\n      console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in MongoDB`);\n      \n      // Debug: Show all incomplete meetings regardless of employeeId\n      const allIncomplete = await MeetingHistory.find({\n        \"meetingDetails.incomplete\": true,\n      }).lean();\n      console.log(`Total incomplete meetings in DB (all employees): ${allIncomplete.length}`);\n      \n      res.json({ meetings: incompleteMeetings });\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const incompleteMeetings = meetingHistory.filter(\n      (history) =>\n        String(history.employeeId) === String(employeeId) &&\n        history.meetingDetails.incomplete,\n    );\n\n    console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in memory`);\n    res.json({ meetings: incompleteMeetings });\n  } catch (error) {\n    console.error(\"Error fetching incomplete meeting remarks:\", error);\n    res.status(500).json({ error: \"Failed to fetch incomplete meeting remarks\" });\n  }\n};\n\n// Helper function to calculate distance between two points using Haversine formula\nfunction calculateDistance(\n  lat1: number,\n  lng1: number,\n  lat2: number,\n  lng2: number,\n): number {\n  const R = 6371e3; // Earth's radius in meters\n  const œÜ1 = (lat1 * Math.PI) / 180;\n  const œÜ2 = (lat2 * Math.PI) / 180;\n  const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;\n  const ŒîŒª = ((lng1 - lng2) * Math.PI) / 180;\n\n  const a =\n    Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +\n    Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return R * c; // Distance in meters\n}\n","import { RequestHandler } from \"express\";\nimport {\n  format,\n  startOfDay,\n  endOfDay,\n  subDays,\n  startOfWeek,\n  endOfWeek,\n  startOfMonth,\n  endOfMonth,\n  isToday,\n  parseISO,\n} from \"date-fns\";\n// We'll create our own functions here since the employees module doesn't export what we need\nimport { ExternalUser, Employee } from \"@shared/api\";\nimport { Meeting, MeetingHistory, Attendance } from \"../models\";\n\n// Replicate the external API fetch function\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\n\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\n  try {\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000);\n\n    const response = await fetch(EXTERNAL_API_URL, {\n      signal: controller.signal,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const users: ExternalUser[] = await response.json();\n    console.log(\n      `External API response: { count: ${users.length}, sample: ${JSON.stringify(users[0] || {}, null, 2)} }`,\n    );\n\n    return users;\n  } catch (error) {\n    console.error(\"Error fetching external users:\", error);\n    if (error.name === \"AbortError\") {\n      console.error(\"External API request timed out after 30 seconds\");\n    } else if (error.message.includes(\"fetch\")) {\n      console.error(\"Network error connecting to external API\");\n    }\n    return [];\n  }\n}\n\n// Replicate the mapping function\ninterface EmployeeStatus {\n  status: \"active\" | \"inactive\" | \"meeting\";\n  location: {\n    lat: number;\n    lng: number;\n    address: string;\n    timestamp: string;\n  };\n  lastUpdate: string;\n  currentTask?: string;\n}\n\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\n\nfunction getRealisticIndianLocation(index: number) {\n  const locations = [\n    { lat: 28.6139, lng: 77.209, address: \"New Delhi, India\" },\n    { lat: 19.076, lng: 72.8777, address: \"Mumbai, Maharashtra\" },\n    { lat: 12.9716, lng: 77.5946, address: \"Bangalore, Karnataka\" },\n    { lat: 13.0827, lng: 80.2707, address: \"Chennai, Tamil Nadu\" },\n    { lat: 22.5726, lng: 88.3639, address: \"Kolkata, West Bengal\" },\n    { lat: 26.9124, lng: 75.7873, address: \"Jaipur, Rajasthan\" },\n    { lat: 21.1458, lng: 79.0882, address: \"Nagpur, Maharashtra\" },\n    { lat: 23.0225, lng: 72.5714, address: \"Ahmedabad, Gujarat\" },\n    { lat: 17.385, lng: 78.4867, address: \"Hyderabad, Telangana\" },\n    { lat: 18.5204, lng: 73.8567, address: \"Pune, Maharashtra\" },\n  ];\n  return locations[index % locations.length];\n}\n\nfunction mapExternalUserToEmployee(\n  user: ExternalUser,\n  index: number,\n): Employee {\n  const userId = user._id;\n\n  if (!employeeStatuses[userId]) {\n    const realisticLocation = getRealisticIndianLocation(index);\n    employeeStatuses[userId] = {\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\n      location: {\n        ...realisticLocation,\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: `${Math.floor(Math.random() * 15) + 1} minutes ago`,\n      currentTask:\n        index === 0\n          ? \"Client meeting\"\n          : index === 1\n            ? \"Equipment installation\"\n            : undefined,\n    };\n  }\n\n  const status = employeeStatuses[userId];\n\n  return {\n    id: userId,\n    name: user.name,\n    email: user.email,\n    phone: user.mobileNumber,\n    status: status.status,\n    location: status.location,\n    lastUpdate: status.lastUpdate,\n    currentTask: status.currentTask,\n    deviceId: `device_${userId.slice(-6)}`,\n    designation: user.designation,\n    department: user.department,\n    companyName: user.companyName[0]?.companyName,\n    reportTo: user.report?.name,\n  };\n}\n\n// Function to get date range based on filter\nfunction getDateRange(dateRange: string, startDate?: string, endDate?: string) {\n  const now = new Date();\n\n  switch (dateRange) {\n    case \"all\":\n      // Return a very wide date range to include all meetings\n      return {\n        start: new Date(\"2020-01-01\"), // Far past date\n        end: new Date(\"2030-12-31\"), // Far future date\n      };\n    case \"today\":\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n    case \"yesterday\":\n      const yesterday = subDays(now, 1);\n      return {\n        start: startOfDay(yesterday),\n        end: endOfDay(yesterday),\n      };\n    case \"week\":\n      return {\n        start: startOfWeek(now, { weekStartsOn: 1 }), // Monday\n        end: endOfWeek(now, { weekStartsOn: 1 }),\n      };\n    case \"month\":\n      return {\n        start: startOfMonth(now),\n        end: endOfMonth(now),\n      };\n    case \"custom\":\n      if (startDate && endDate) {\n        return {\n          start: startOfDay(parseISO(startDate)),\n          end: endOfDay(parseISO(endDate)),\n        };\n      }\n      // Fallback to today\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n    default:\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n  }\n}\n\n// Function to calculate meeting duration in hours\nfunction calculateMeetingDuration(startTime: string, endTime?: string): number {\n  const start = new Date(startTime);\n  const end = endTime ? new Date(endTime) : new Date();\n  const durationMs = end.getTime() - start.getTime();\n  return durationMs / (1000 * 60 * 60); // Convert to hours\n}\n\n// Function to calculate duty hours (placeholder - would need tracking data)\nfunction calculateDutyHours(\n  employeeId: string,\n  dateRange: { start: Date; end: Date },\n): number {\n  // This is a placeholder calculation\n  // In a real app, this would calculate based on tracking sessions, check-ins, etc.\n  // For now, we'll assume 8 hours per working day in the date range\n  const daysInRange = Math.ceil(\n    (dateRange.end.getTime() - dateRange.start.getTime()) /\n      (1000 * 60 * 60 * 24),\n  );\n  return Math.min(daysInRange * 8, 40); // Max 40 hours per week\n}\n\nexport const getEmployeeAnalytics: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      dateRange = \"today\",\n      startDate,\n      endDate,\n      search,\n    } = req.query;\n\n    // Get date range\n    const { start, end } = getDateRange(\n    dateRange as string,\n    startDate as string,\n    endDate as string,\n  );\n\n  console.log(`Analytics date filter - Range: ${dateRange}, Start: ${startDate}, End: ${endDate}`);\n  console.log(`Calculated date range: ${start.toISOString()} to ${end.toISOString()}`);\n\n    // Fetch all employees\n    const externalUsers = await fetchExternalUsers();\n    let employees = externalUsers.map((user, index) =>\n      mapExternalUserToEmployee(user, index),\n    );\n\n    // Filter by employee if specified\n    if (employeeId && employeeId !== \"all\") {\n      employees = employees.filter((emp) => emp.id === employeeId);\n    }\n\n    // Filter by search term if specified\n    if (search) {\n      const searchTerm = (search as string).toLowerCase();\n      employees = employees.filter(\n        (emp) =>\n          emp.name.toLowerCase().includes(searchTerm) ||\n          emp.email.toLowerCase().includes(searchTerm),\n      );\n    }\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      // Try to get meetings from MongoDB first\n      // Get ALL meetings for total counts, but we'll filter them properly later\n      const mongoMeetings = await Meeting.find({}).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => ({\n        id: meeting._id.toString(),\n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime,\n        clientName: meeting.clientName,\n        leadId: meeting.leadId,\n        status: meeting.status,\n        meetingDetails: meeting.meetingDetails,\n        location: meeting.location\n      }));\n\n      console.log(`Found ${actualMeetings.length} total meetings in MongoDB`);\n      console.log(`Date range filter: ${start.toISOString()} to ${end.toISOString()}`);\n\n      // If no MongoDB data, fallback to in-memory\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import(\"./meetings\");\n        actualMeetings = inMemoryMeetings || [];\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import(\"./meetings\");\n      actualMeetings = inMemoryMeetings || [];\n    }\n\n    console.log(\"Using meetings data:\", actualMeetings.length, \"meetings\");\n    console.log(\"Available employees:\", employees.map(e => ({ id: e.id, name: e.name })));\n    console.log(\"Meeting employee IDs:\", actualMeetings.map(m => m.employeeId));\n\n    // Calculate analytics for each employee\n    const analytics = employees.map((employee) => {\n      // Get meetings for this employee\n      const employeeMeetings = actualMeetings.filter(\n        (meeting) => meeting.employeeId === employee.id,\n      );\n\n      console.log(`Employee ${employee.name} (${employee.id}): found ${employeeMeetings.length} meetings`);\n\n      // Filter meetings by date range for the specific metrics\n      const meetingsInRange = employeeMeetings.filter((meeting) => {\n        const meetingDate = new Date(meeting.startTime);\n        const meetingTime = meetingDate.getTime();\n        const startTime = start.getTime();\n        const endTime = end.getTime();\n        const inRange = meetingTime >= startTime && meetingTime <= endTime;\n\n        if (inRange) {\n          console.log(`‚úÖ Meeting ${meeting.id} IN range: ${meeting.startTime} (${meeting.clientName || 'No client'})`);\n        } else {\n          console.log(`‚ùå Meeting ${meeting.id} OUT of range: ${meeting.startTime} (not between ${start.toISOString()} and ${end.toISOString()})`);\n        }\n        return inRange;\n      });\n\n      // Calculate today's meetings\n      const todayMeetings = employeeMeetings.filter((meeting) =>\n        isToday(new Date(meeting.startTime)),\n      ).length;\n\n      // Calculate total meeting hours for the filtered range\n      // For \"all\" filter, this will be total hours across all meetings\n      const totalMeetingHours = meetingsInRange.reduce((total, meeting) => {\n        return (\n          total + calculateMeetingDuration(meeting.startTime, meeting.endTime)\n        );\n      }, 0);\n\n      console.log(`Employee ${employee.name} (${employee.id}): ${employeeMeetings.length} total meetings, ${meetingsInRange.length} in date range (${dateRange}), ${totalMeetingHours.toFixed(1)}h meeting time`);\n\n      // Calculate duty hours\n      const totalDutyHours = calculateDutyHours(employee.id, { start, end });\n\n      return {\n        employeeId: employee.id,\n        employeeName: employee.name,\n        totalMeetings: employeeMeetings.length, // Total meetings for this employee (all time, never filtered)\n        todayMeetings,\n        totalMeetingHours, // This uses filtered range which is correct\n        totalDutyHours,\n        status: employee.status,\n      };\n    });\n\n    // Calculate summary statistics\n    const summary = {\n      totalEmployees: employees.length,\n      activeMeetings: employees.filter((emp) => emp.status === \"meeting\")\n        .length,\n      totalMeetingsToday: analytics.reduce(\n        (sum, emp) => sum + emp.todayMeetings,\n        0,\n      ),\n      avgMeetingDuration:\n        analytics.length > 0\n          ? analytics.reduce((sum, emp) => sum + emp.totalMeetingHours, 0) /\n            Math.max(\n              analytics.reduce((sum, emp) => sum + emp.totalMeetings, 0),\n              1,\n            )\n          : 0,\n    };\n\n    res.json({\n      analytics,\n      summary,\n      dateRange: {\n        start: start.toISOString(),\n        end: end.toISOString(),\n        label: dateRange,\n      },\n    });\n  } catch (error) {\n    console.error(\"Error fetching employee analytics:\", error);\n    res.status(500).json({ error: \"Failed to fetch analytics\" });\n  }\n};\n\n// Mock meeting data generator for demonstration\nfunction generateMockMeetings(\n  employees: any[],\n  startDate: Date,\n  endDate: Date,\n) {\n  const meetings: any[] = [];\n  const customers = [\n    \"Tech Corp\",\n    \"ABC Industries\",\n    \"XYZ Solutions\",\n    \"Global Systems\",\n    \"Innovation Ltd\",\n  ];\n  const leadIds = [\"LEAD-001\", \"LEAD-002\", \"LEAD-003\", \"LEAD-004\", \"LEAD-005\"];\n\n  employees.forEach((employee, empIndex) => {\n    // Generate 1-5 meetings per employee in the date range\n    const meetingCount = Math.floor(Math.random() * 5) + 1;\n\n    for (let i = 0; i < meetingCount; i++) {\n      // Random date within range\n      const randomTime = new Date(\n        startDate.getTime() +\n          Math.random() * (endDate.getTime() - startDate.getTime()),\n      );\n\n      // Random meeting duration (30 minutes to 3 hours)\n      const durationHours = Math.random() * 2.5 + 0.5;\n      const endTime = new Date(\n        randomTime.getTime() + durationHours * 60 * 60 * 1000,\n      );\n\n      meetings.push({\n        id: `meeting_${empIndex}_${i}`,\n        employeeId: employee.id,\n        startTime: randomTime.toISOString(),\n        endTime: endTime.toISOString(),\n        clientName: customers[Math.floor(Math.random() * customers.length)],\n        leadId: leadIds[Math.floor(Math.random() * leadIds.length)],\n        status: \"completed\",\n        location: employee.location,\n      });\n    }\n  });\n\n  return meetings;\n}\n\nexport const getEmployeeDetails: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.params;\n    const { dateRange = \"today\", startDate, endDate } = req.query;\n\n    // Get date range\n    const { start, end } = getDateRange(\n    dateRange as string,\n    startDate as string,\n    endDate as string,\n  );\n\n  console.log(`Employee details date filter - Range: ${dateRange}, Start: ${startDate}, End: ${endDate}`);\n  console.log(`Employee ${employeeId} calculated date range: ${start.toISOString()} to ${end.toISOString()}`);\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      // Try to get meetings from MongoDB first\n      // Get ALL meetings for this employee, then filter by date range\n      const mongoMeetings = await Meeting.find({ employeeId }).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => {\n        if (!meeting._id) {\n          console.error(`‚ùå Meeting from MongoDB has no _id:`, meeting);\n        }\n        return {\n          id: meeting._id ? meeting._id.toString() : undefined,\n          employeeId: meeting.employeeId,\n          startTime: meeting.startTime,\n          endTime: meeting.endTime,\n          clientName: meeting.clientName,\n          leadId: meeting.leadId,\n          status: meeting.status,\n          meetingDetails: meeting.meetingDetails,\n          location: meeting.location,\n          approvalStatus: meeting.approvalStatus,\n          approvalReason: meeting.approvalReason\n        };\n      });\n\n      console.log(`Found ${actualMeetings.length} total meetings in MongoDB for employee ${employeeId}`);\n      \n      // Debug: Log IDs of all meetings\n      if (actualMeetings.length > 0) {\n        console.log(`üìã Meeting IDs from MongoDB:`, actualMeetings.map(m => ({ id: m.id, hasId: !!m.id })));\n      }\n      console.log(`Employee details date range: ${start.toISOString()} to ${end.toISOString()}`);\n\n      // If no MongoDB data, fallback to in-memory\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import(\"./meetings\");\n        actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.employeeId === employeeId);\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory for employee ${employeeId}`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import(\"./meetings\");\n      actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.employeeId === employeeId);\n    }\n\n    // Filter meetings for this employee within date range\n    // üîπ IMPORTANT: Include ALL meetings (completed, in-progress, started) that fall within the date range\n    const employeeMeetings = actualMeetings.filter((meeting) => {\n      const meetingDate = new Date(meeting.startTime);\n      const meetingTime = meetingDate.getTime();\n      const startTime = start.getTime();\n      const endTime = end.getTime();\n      const inDateRange = meetingTime >= startTime && meetingTime <= endTime;\n\n      if (inDateRange) {\n        console.log(`‚úÖ Employee meeting ${meeting.id} included: ${meeting.startTime} (${meeting.clientName || 'No client'}) [Status: ${meeting.status}]`);\n      } else {\n        console.log(`‚ùå Employee meeting ${meeting.id} excluded: ${meeting.startTime} (outside ${start.toISOString()} to ${end.toISOString()}) [Status: ${meeting.status}]`);\n      }\n\n      return inDateRange;\n    });\n\n    console.log(`Filtered to ${employeeMeetings.length} meetings in date range for employee ${employeeId}`);\n    \n    // Debug: Check if filtered meetings still have IDs\n    if (employeeMeetings.length > 0) {\n      console.log(`üìã Filtered meeting IDs:`, employeeMeetings.map(m => ({ \n        id: m.id, \n        hasId: !!m.id,\n        client: m.clientName \n      })));\n    }\n\n    // üîπ NEW: Get tracking sessions for attendance (login/logout)\n    let trackingSessions: any[] = [];\n    try {\n      const { TrackingSession } = await import(\"../models\");\n      const mongoSessions = await TrackingSession.find({ \n        employeeId,\n        startTime: { $gte: start.toISOString(), $lte: end.toISOString() }\n      }).lean();\n      \n      trackingSessions = mongoSessions.map(session => ({\n        id: session.id,\n        employeeId: session.employeeId,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        startLocation: session.startLocation,\n        endLocation: session.endLocation,\n        status: session.status,\n        duration: session.duration,\n      }));\n      \n      console.log(`Found ${trackingSessions.length} tracking sessions for employee ${employeeId}`);\n    } catch (dbError) {\n      console.warn(\"Failed to fetch tracking sessions:\", dbError);\n    }\n\n    // Group meetings by date\n    const dateGroups = employeeMeetings.reduce(\n      (groups, meeting) => {\n        const date = format(new Date(meeting.startTime), \"yyyy-MM-dd\");\n        if (!groups[date]) groups[date] = [];\n        groups[date].push(meeting);\n        return groups;\n      },\n      {} as Record<string, any[]>,\n    );\n\n    // Group tracking sessions by date\n    const sessionDateGroups = trackingSessions.reduce(\n      (groups, session) => {\n        const date = format(new Date(session.startTime), \"yyyy-MM-dd\");\n        if (!groups[date]) groups[date] = [];\n        groups[date].push(session);\n        return groups;\n      },\n      {} as Record<string, any[]>,\n    );\n\n    // Get all unique dates from both meetings and sessions\n    const allDates = new Set([\n      ...Object.keys(dateGroups),\n      ...Object.keys(sessionDateGroups)\n    ]);\n\n    // üîπ NEW: Fetch attendance records for the date range to get attendenceCreated info\n    let attendanceRecords: any[] = [];\n    try {\n      const mongoAttendance = await Attendance.find({\n        employeeId,\n        date: { \n          $gte: format(start, \"yyyy-MM-dd\"), \n          $lte: format(end, \"yyyy-MM-dd\") \n        }\n      }).lean();\n      \n      attendanceRecords = mongoAttendance.map(att => ({\n        date: att.date,\n        attendenceCreated: att.attendenceCreated,\n        attendanceStatus: att.attendanceStatus,\n        attendanceReason: att.attendanceReason\n      }));\n      \n      console.log(`Found ${attendanceRecords.length} attendance records for employee ${employeeId}`);\n    } catch (dbError) {\n      console.warn(\"Failed to fetch attendance records:\", dbError);\n    }\n\n    // üîπ NEW: Fetch external users to map attendenceCreated IDs to names\n    const externalUsers = await fetchExternalUsers();\n    const userMap = new Map(externalUsers.map(user => [user._id, user.name]));\n\n    // Generate day records combining meetings and tracking sessions\n    const dayRecords = Array.from(allDates).map((date) => {\n      const meetings = dateGroups[date] || [];\n      const sessions = sessionDateGroups[date] || [];\n      \n      const totalMeetings = meetings.length;\n      const totalMeetingHours = meetings.reduce((total, meeting) => {\n        return (\n          total + calculateMeetingDuration(meeting.startTime, meeting.endTime)\n        );\n      }, 0);\n\n      // Sort meetings by start time to get first and last\n      const sortedMeetings = [...meetings].sort((a, b) => \n        new Date(a.startTime).getTime() - new Date(b.startTime).getTime()\n      );\n      const firstMeeting = sortedMeetings[0];\n      const lastMeeting = sortedMeetings[sortedMeetings.length - 1];\n\n      // Use tracking session for duty hours calculation\n      const firstSession = sessions[0];\n      const lastSession = sessions[sessions.length - 1];\n\n      // ‚úÖ MEETING-BASED TRACKING: Start location time from first meeting start\n      const startLocationTime = firstMeeting?.startTime || \"\";\n      const startLocationAddress = firstMeeting?.location?.address || \"\";\n\n      // ‚úÖ MEETING-BASED TRACKING: Out location time from last meeting end\n      const outLocationTime = lastMeeting?.endTime || \"\";\n      const outLocationAddress = lastMeeting?.endTime && lastMeeting?.location?.endLocation?.address\n        ? lastMeeting.location.endLocation.address\n        : (lastMeeting?.location?.address || \"\"); // Fallback to start location if end location not available\n\n      // Calculate total duty hours from first meeting start to last meeting end\n      let totalDutyHours = 8; // Default\n      if (firstMeeting && lastMeeting?.endTime) {\n        const dutyDuration = (new Date(lastMeeting.endTime).getTime() - new Date(firstMeeting.startTime).getTime()) / (1000 * 60 * 60);\n        totalDutyHours = Math.max(0, dutyDuration);\n      }\n\n      // üîπ NEW: Get attendance info for this date\n      const attendance = attendanceRecords.find(att => att.date === date);\n      const attendanceAddedBy = attendance?.attendenceCreated \n        ? userMap.get(attendance.attendenceCreated) || attendance.attendenceCreated\n        : null;\n\n      console.log(`Day record for ${date}:`);\n      console.log(`  - Meetings: ${totalMeetings}, Meeting hours: ${totalMeetingHours.toFixed(2)}h`);\n      console.log(`  - ‚úÖ Start Location Time: ${startLocationTime || 'N/A'} (from FIRST MEETING START)`);\n      console.log(`  - ‚úÖ Out Location Time: ${outLocationTime || 'N/A'} (from LAST MEETING END)`);\n      console.log(`  - Tracking sessions: ${sessions.length}, Attendance added by: ${attendanceAddedBy || 'N/A'}`);\n      \n      return {\n        date,\n        totalMeetings,\n        startLocationTime,\n        startLocationAddress,\n        outLocationTime,\n        outLocationAddress,\n        totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\n        meetingTime: totalMeetingHours,\n        travelAndLunchTime: Math.max(0, totalDutyHours - totalMeetingHours),\n        attendanceAddedBy // üîπ NEW: Person who added the attendance\n      };\n    });\n\n    // Generate meeting records - Include ALL meetings (completed, in-progress, started)\n    const meetingRecords = employeeMeetings.map((meeting) => {\n      console.log(`üìã Generating meeting record for meeting ${meeting.id}:`, {\n        id: meeting.id,\n        hasId: !!meeting.id,\n        status: meeting.status,\n        clientName: meeting.clientName,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime || 'N/A (active meeting)',\n        hasDetails: !!meeting.meetingDetails,\n        approvalStatus: meeting.approvalStatus || 'Not reviewed'\n      });\n      \n      if (!meeting.id) {\n        console.error(`‚ùå WARNING: Meeting has no ID!`, meeting);\n      }\n      \n      return {\n        meetingId: meeting.id, // Include meeting ID for approval updates\n        employeeName: \"\", // Will be filled by client\n        companyName: meeting.clientName || \"Unknown Company\",\n        date: format(new Date(meeting.startTime), \"yyyy-MM-dd\"),\n        leadId: meeting.leadId || \"\",\n        meetingInTime: format(new Date(meeting.startTime), \"HH:mm\"),\n        meetingInLocation: meeting.location?.address || \"\",\n        meetingOutTime: meeting.endTime\n          ? format(new Date(meeting.endTime), \"HH:mm\")\n          : \"In Progress\", // Show \"In Progress\" for active meetings\n        // üîπ FIX: Only show end location if meeting has ended, use endLocation field\n        meetingOutLocation: meeting.endTime && meeting.location?.endLocation?.address\n          ? meeting.location.endLocation.address\n          : (meeting.status === \"completed\" ? \"\" : \"Meeting in progress\"),\n        totalStayTime: calculateMeetingDuration(\n          meeting.startTime,\n          meeting.endTime,\n        ),\n        discussion: meeting.meetingDetails?.discussion || meeting.notes || (meeting.status !== \"completed\" ? \"Meeting in progress\" : \"\"),\n        meetingPerson:\n          meeting.meetingDetails?.customers?.length > 0\n            ? meeting.meetingDetails.customers\n                .map((customer) => customer.customerEmployeeName)\n                .join(\", \")\n            : meeting.meetingDetails?.customerEmployeeName || (meeting.status !== \"completed\" ? \"TBD\" : \"Unknown\"),\n        meetingStatus: meeting.status || \"completed\", // Internal meeting status\n        externalMeetingStatus: meeting.externalMeetingStatus || \"\", // üîπ NEW: Status from external follow-up API\n        incomplete: meeting.meetingDetails?.incomplete || false, // Include incomplete flag\n        incompleteReason: meeting.meetingDetails?.incompleteReason || \"\", // Include incomplete reason\n        approvalStatus: meeting.approvalStatus || undefined, // Meeting approval status\n        approvalReason: meeting.approvalReason || undefined, // Meeting approval reason\n      };\n    });\n\n    const finalResult = {\n      dayRecords: dayRecords.sort(\n        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),\n      ),\n      meetingRecords: meetingRecords.sort(\n        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),\n      ),\n    };\n\n    console.log(`Employee details result: ${finalResult.dayRecords.length} day records, ${finalResult.meetingRecords.length} meeting records`);\n\n    res.json(finalResult);\n  } catch (error) {\n    console.error(\"Error fetching employee details:\", error);\n    res.status(500).json({ error: \"Failed to fetch employee details\" });\n  }\n};\n\nexport const getLeadHistory: RequestHandler = async (req, res) => {\n  try {\n    const { leadId } = req.params;\n\n    console.log(`Fetching history for lead: ${leadId}`);\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      // Try to get meetings from MongoDB first\n      const mongoMeetings = await Meeting.find({ leadId }).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => ({\n        id: meeting._id.toString(),\n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime,\n        clientName: meeting.clientName,\n        leadId: meeting.leadId,\n        status: meeting.status,\n        meetingDetails: meeting.meetingDetails,\n        location: meeting.location,\n        leadInfo: meeting.leadInfo\n      }));\n\n      console.log(`Found ${actualMeetings.length} meetings in MongoDB for lead ${leadId}`);\n\n      // If no MongoDB data, fallback to in-memory\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import('./meetings');\n        actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory for lead ${leadId}`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import('./meetings');\n      actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\n    }\n\n    // Filter meetings by lead ID\n    const leadMeetings = actualMeetings.filter(meeting => meeting.leadId === leadId);\n\n    console.log(`Found ${leadMeetings.length} meetings for lead ${leadId}`);\n\n    // Get employee data for names\n    const externalUsers = await fetchExternalUsers();\n    const employees = externalUsers.map((user, index) => mapExternalUserToEmployee(user, index));\n\n    // Generate history records\n    const history = leadMeetings.map(meeting => {\n      const employee = employees.find(emp => emp.id === meeting.employeeId);\n      const duration = calculateMeetingDuration(meeting.startTime, meeting.endTime);\n\n      return {\n        date: meeting.startTime,\n        employeeName: employee?.name || \"Unknown Employee\",\n        companyName: meeting.clientName || \"Unknown Company\",\n        duration,\n        meetingPerson: meeting.meetingDetails?.customers?.length > 0\n          ? meeting.meetingDetails.customers.map(customer => customer.customerEmployeeName).join(\", \")\n          : meeting.meetingDetails?.customerEmployeeName || \"Unknown\",\n        discussion: meeting.meetingDetails?.discussion || meeting.notes || \"\",\n        status: meeting.status || \"completed\",\n        location: meeting.location?.address || \"\",\n        leadInfo: meeting.leadInfo,\n      };\n    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n    res.json({\n      leadId,\n      history,\n      totalMeetings: history.length,\n      totalDuration: history.reduce((sum, record) => sum + record.duration, 0),\n    });\n\n  } catch (error) {\n    console.error(\"Error fetching lead history:\", error);\n    res.status(500).json({ error: \"Failed to fetch lead history\" });\n  }\n};\n\nexport const saveAttendance: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, date, attendanceStatus, attendanceReason, attendenceCreated } = req.body;\n\n    console.log(`Saving attendance for employee ${employeeId} on ${date}:`, {\n      attendanceStatus,\n      attendanceReason,\n      attendenceCreated\n    });\n\n    // Validate required fields\n    if (!employeeId || !date || !attendanceStatus) {\n      return res.status(400).json({\n        error: \"Employee ID, date, and attendance status are required\"\n      });\n    }\n\n    // Validate attendance status\n    const validStatuses = [\"full_day\", \"half_day\", \"off\", \"short_leave\", \"ot\"];\n    if (!validStatuses.includes(attendanceStatus)) {\n      return res.status(400).json({\n        error: \"Invalid attendance status\"\n      });\n    }\n\n    // Validate date format (YYYY-MM-DD)\n    if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n      return res.status(400).json({\n        error: \"Date must be in YYYY-MM-DD format\"\n      });\n    }\n\n    try {\n      // Try to save to MongoDB using upsert (update if exists, create if not)\n      const savedAttendance = await Attendance.findOneAndUpdate(\n        { employeeId, date },\n        {\n          employeeId,\n          date,\n          attendanceStatus,\n          attendanceReason: attendanceReason || \"\",\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null // Default to null if not provided\n        },\n        {\n          new: true,\n          upsert: true,\n          runValidators: true\n        }\n      );\n\n      console.log(\"Attendance saved to MongoDB:\", savedAttendance._id);\n      console.log(\"Attendance attendenceCreated value:\", savedAttendance.attendenceCreated);\n\n      res.json({\n        success: true,\n        message: \"Attendance saved successfully\",\n        data: {\n          id: savedAttendance._id,\n          employeeId: savedAttendance.employeeId,\n          date: savedAttendance.date,\n          attendanceStatus: savedAttendance.attendanceStatus,\n          attendanceReason: savedAttendance.attendanceReason,\n          attendenceCreated: savedAttendance.attendenceCreated,\n          savedAt: savedAttendance.updatedAt\n        }\n      });\n\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, using fallback:\", dbError);\n\n      // Fallback response (in real app, might save to alternative storage)\n      res.json({\n        success: true,\n        message: \"Attendance saved successfully (fallback mode)\",\n        data: {\n          employeeId,\n          date,\n          attendanceStatus,\n          attendanceReason,\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null,\n          savedAt: new Date().toISOString()\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error(\"Error saving attendance:\", error);\n    res.status(500).json({ error: \"Failed to save attendance\" });\n  }\n};\n\nexport const getMeetingTrends: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, period = \"week\" } = req.query;\n\n    // This would calculate meeting trends over time\n    // For now, return mock data\n    const trends = {\n      labels: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n      datasets: [\n        {\n          label: \"Meetings\",\n          data: [2, 4, 3, 5, 2, 1, 0],\n        },\n        {\n          label: \"Hours\",\n          data: [4, 8, 6, 10, 4, 2, 0],\n        },\n      ],\n    };\n\n    res.json(trends);\n  } catch (error) {\n    console.error(\"Error fetching meeting trends:\", error);\n    res.status(500).json({ error: \"Failed to fetch trends\" });\n  }\n};\n\nexport const getAttendance: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, startDate, endDate, date } = req.query;\n\n    console.log(`Fetching attendance records:`, {\n      employeeId,\n      startDate,\n      endDate,\n      date\n    });\n\n    // Build query filter\n    const filter: any = {};\n\n    if (employeeId) {\n      filter.employeeId = employeeId;\n    }\n\n    if (date) {\n      // Single date query\n      filter.date = date;\n    } else if (startDate && endDate) {\n      // Date range query\n      filter.date = {\n        $gte: startDate,\n        $lte: endDate\n      };\n    }\n\n    try {\n      // Fetch from MongoDB\n      const attendanceRecords = await Attendance.find(filter)\n        .sort({ date: -1 })\n        .lean();\n\n      console.log(`Found ${attendanceRecords.length} attendance records`);\n\n      // Fetch external users to map attendenceCreated IDs to names\n      const externalUsers = await fetchExternalUsers();\n      const userMap = new Map(externalUsers.map(user => [user._id, user.name]));\n\n      // Format the response\n      const formattedRecords = attendanceRecords.map(record => ({\n        id: record._id.toString(),\n        employeeId: record.employeeId,\n        date: record.date,\n        attendanceStatus: record.attendanceStatus,\n        attendanceReason: record.attendanceReason || \"\",\n        attendenceCreated: record.attendenceCreated,\n        attendenceCreatedName: record.attendenceCreated \n          ? userMap.get(record.attendenceCreated) || record.attendenceCreated\n          : null,\n        savedAt: record.updatedAt || record.createdAt\n      }));\n\n      res.json({\n        success: true,\n        count: formattedRecords.length,\n        data: formattedRecords\n      });\n\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed:\", dbError);\n      \n      // Fallback response\n      res.json({\n        success: true,\n        count: 0,\n        data: [],\n        message: \"No attendance records found (database unavailable)\"\n      });\n    }\n\n  } catch (error) {\n    console.error(\"Error fetching attendance:\", error);\n    res.status(500).json({ \n      success: false,\n      error: \"Failed to fetch attendance records\" \n    });\n  }\n};\n\n// New endpoint: Get all employees' attendance and meeting details\nexport const getAllEmployeesDetails: RequestHandler = async (req, res) => {\n  try {\n    const { dateRange = \"today\", startDate, endDate } = req.query;\n\n    // Get date range\n    const { start, end } = getDateRange(\n      dateRange as string,\n      startDate as string,\n      endDate as string,\n    );\n\n    console.log(`All employees details date filter - Range: ${dateRange}, Start: ${startDate}, End: ${endDate}`);\n    console.log(`Calculated date range: ${start.toISOString()} to ${end.toISOString()}`);\n\n    // Fetch all employees\n    const externalUsers = await fetchExternalUsers();\n    const employees = externalUsers.map((user, index) =>\n      mapExternalUserToEmployee(user, index),\n    );\n\n    console.log(`Processing ${employees.length} employees`);\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      const mongoMeetings = await Meeting.find({}).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => ({\n        id: meeting._id.toString(),\n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime,\n        clientName: meeting.clientName,\n        leadId: meeting.leadId,\n        status: meeting.status,\n        meetingDetails: meeting.meetingDetails,\n        location: meeting.location\n      }));\n\n      console.log(`Found ${actualMeetings.length} total meetings in MongoDB`);\n\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import(\"./meetings\");\n        actualMeetings = inMemoryMeetings || [];\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import(\"./meetings\");\n      actualMeetings = inMemoryMeetings || [];\n    }\n\n    // Get tracking sessions for all employees\n    let trackingSessions: any[] = [];\n    try {\n      const { TrackingSession } = await import(\"../models\");\n      const mongoSessions = await TrackingSession.find({ \n        startTime: { $gte: start.toISOString(), $lte: end.toISOString() }\n      }).lean();\n      \n      trackingSessions = mongoSessions.map(session => ({\n        id: session.id,\n        employeeId: session.employeeId,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        startLocation: session.startLocation,\n        endLocation: session.endLocation,\n        status: session.status,\n        duration: session.duration,\n      }));\n      \n      console.log(`Found ${trackingSessions.length} tracking sessions`);\n    } catch (dbError) {\n      console.warn(\"Failed to fetch tracking sessions:\", dbError);\n    }\n\n    // Fetch attendance records for the date range\n    let attendanceRecords: any[] = [];\n    try {\n      const mongoAttendance = await Attendance.find({\n        date: { \n          $gte: format(start, \"yyyy-MM-dd\"), \n          $lte: format(end, \"yyyy-MM-dd\") \n        }\n      }).lean();\n      \n      attendanceRecords = mongoAttendance.map(att => ({\n        employeeId: att.employeeId,\n        date: att.date,\n        attendenceCreated: att.attendenceCreated,\n        attendanceStatus: att.attendanceStatus,\n        attendanceReason: att.attendanceReason\n      }));\n      \n      console.log(`Found ${attendanceRecords.length} attendance records`);\n    } catch (dbError) {\n      console.warn(\"Failed to fetch attendance records:\", dbError);\n    }\n\n    // Fetch external users to map attendenceCreated IDs to names\n    const userMap = new Map(externalUsers.map(user => [user._id, user.name]));\n\n    // Process each employee\n    const allEmployeesData = employees.map((employee) => {\n      // Get meetings for this employee\n      const employeeMeetings = actualMeetings.filter(\n        (meeting) => meeting.employeeId === employee.id,\n      );\n\n      // Filter meetings by date range\n      const meetingsInRange = employeeMeetings.filter((meeting) => {\n        const meetingDate = new Date(meeting.startTime);\n        const meetingTime = meetingDate.getTime();\n        const startTime = start.getTime();\n        const endTime = end.getTime();\n        return meetingTime >= startTime && meetingTime <= endTime;\n      });\n\n      // Get tracking sessions for this employee\n      const employeeSessions = trackingSessions.filter(\n        (session) => session.employeeId === employee.id,\n      );\n\n      // Group meetings by date\n      const dateGroups = meetingsInRange.reduce(\n        (groups, meeting) => {\n          const date = format(new Date(meeting.startTime), \"yyyy-MM-dd\");\n          if (!groups[date]) groups[date] = [];\n          groups[date].push(meeting);\n          return groups;\n        },\n        {} as Record<string, any[]>,\n      );\n\n      // Group tracking sessions by date\n      const sessionDateGroups = employeeSessions.reduce(\n        (groups, session) => {\n          const date = format(new Date(session.startTime), \"yyyy-MM-dd\");\n          if (!groups[date]) groups[date] = [];\n          groups[date].push(session);\n          return groups;\n        },\n        {} as Record<string, any[]>,\n      );\n\n      // Get all unique dates from both meetings and sessions\n      const allDates = new Set([\n        ...Object.keys(dateGroups),\n        ...Object.keys(sessionDateGroups)\n      ]);\n\n      // Generate day records\n      const dayRecords = Array.from(allDates).map((date) => {\n        const meetings = dateGroups[date] || [];\n        const sessions = sessionDateGroups[date] || [];\n        \n        const totalMeetings = meetings.length;\n        const totalMeetingHours = meetings.reduce((total, meeting) => {\n          return (\n            total + calculateMeetingDuration(meeting.startTime, meeting.endTime)\n          );\n        }, 0);\n\n        // Sort meetings by start time to get first and last\n        const sortedMeetings = [...meetings].sort((a, b) => \n          new Date(a.startTime).getTime() - new Date(b.startTime).getTime()\n        );\n        const firstMeeting = sortedMeetings[0];\n        const lastMeeting = sortedMeetings[sortedMeetings.length - 1];\n\n        const firstSession = sessions[0];\n        const lastSession = sessions[sessions.length - 1];\n\n        // Start location time from first meeting start\n        const startLocationTime = firstMeeting?.startTime || \"\";\n        const startLocationAddress = firstMeeting?.location?.address || \"\";\n\n        // Out location time from last meeting end\n        const outLocationTime = lastMeeting?.endTime || \"\";\n        const outLocationAddress = lastMeeting?.endTime && lastMeeting?.location?.endLocation?.address\n          ? lastMeeting.location.endLocation.address\n          : (lastMeeting?.location?.address || \"\");\n\n        // Calculate total duty hours from first meeting start to last meeting end\n        let totalDutyHours = 8; // Default\n        if (firstMeeting && lastMeeting?.endTime) {\n          const dutyDuration = (new Date(lastMeeting.endTime).getTime() - new Date(firstMeeting.startTime).getTime()) / (1000 * 60 * 60);\n          totalDutyHours = Math.max(0, dutyDuration);\n        }\n\n        // Get attendance info for this date\n        const attendance = attendanceRecords.find(att => att.date === date && att.employeeId === employee.id);\n        const attendanceAddedBy = attendance?.attendenceCreated \n          ? userMap.get(attendance.attendenceCreated) || attendance.attendenceCreated\n          : null;\n        \n        return {\n          date,\n          totalMeetings,\n          startLocationTime,\n          startLocationAddress,\n          outLocationTime,\n          outLocationAddress,\n          totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\n          meetingTime: totalMeetingHours,\n          travelAndLunchTime: Math.max(0, totalDutyHours - totalMeetingHours),\n          attendanceAddedBy\n        };\n      });\n\n      // Generate meeting records\n      const meetingRecords = meetingsInRange.map((meeting) => {\n        return {\n          employeeName: employee.name,\n          companyName: meeting.clientName || \"Unknown Company\",\n          date: format(new Date(meeting.startTime), \"yyyy-MM-dd\"),\n          leadId: meeting.leadId || \"\",\n          meetingInTime: format(new Date(meeting.startTime), \"HH:mm\"),\n          meetingInLocation: meeting.location?.address || \"\",\n          meetingOutTime: meeting.endTime\n            ? format(new Date(meeting.endTime), \"HH:mm\")\n            : \"In Progress\",\n          meetingOutLocation: meeting.endTime && meeting.location?.endLocation?.address\n            ? meeting.location.endLocation.address\n            : (meeting.status === \"completed\" ? \"\" : \"Meeting in progress\"),\n          totalStayTime: calculateMeetingDuration(\n            meeting.startTime,\n            meeting.endTime,\n          ),\n          discussion: meeting.meetingDetails?.discussion || meeting.notes || (meeting.status !== \"completed\" ? \"Meeting in progress\" : \"\"),\n          meetingPerson:\n            meeting.meetingDetails?.customers?.length > 0\n              ? meeting.meetingDetails.customers\n                  .map((customer) => customer.customerEmployeeName)\n                  .join(\", \")\n              : meeting.meetingDetails?.customerEmployeeName || (meeting.status !== \"completed\" ? \"TBD\" : \"Unknown\"),\n          meetingStatus: meeting.status || \"completed\",\n          externalMeetingStatus: meeting.externalMeetingStatus || \"\",\n          incomplete: meeting.meetingDetails?.incomplete || false,\n          incompleteReason: meeting.meetingDetails?.incompleteReason || \"\",\n        };\n      });\n\n      return {\n        employeeId: employee.id,\n        employeeName: employee.name,\n        email: employee.email,\n        phone: employee.phone,\n        designation: employee.designation,\n        department: employee.department,\n        companyName: employee.companyName,\n        reportTo: employee.reportTo,\n        dayRecords: dayRecords.sort(\n          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),\n        ),\n        meetingRecords: meetingRecords.sort(\n          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),\n        ),\n      };\n    });\n\n    console.log(`Processed ${allEmployeesData.length} employees with their details`);\n\n    res.json({\n      success: true,\n      dateRange: {\n        start: start.toISOString(),\n        end: end.toISOString(),\n        label: dateRange,\n      },\n      totalEmployees: allEmployeesData.length,\n      employees: allEmployeesData,\n    });\n  } catch (error) {\n    console.error(\"Error fetching all employees details:\", error);\n    res.status(500).json({ error: \"Failed to fetch all employees details\" });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { Meeting, MeetingHistory, Employee, TrackingSession } from \"../models\";\n\n// Endpoint to synchronize all data sources and ensure consistency\nexport const syncAllData: RequestHandler = async (req, res) => {\n  try {\n    console.log(\"Starting data synchronization...\");\n    \n    const { employeeId } = req.query;\n    \n    // Get all data from MongoDB\n    const mongoMeetings = await Meeting.find(employeeId ? { employeeId } : {}).lean();\n    const mongoHistory = await MeetingHistory.find(employeeId ? { employeeId } : {}).lean();\n    \n    console.log(`Found ${mongoMeetings.length} meetings and ${mongoHistory.length} history entries in MongoDB`);\n    \n    // Get in-memory data for comparison\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    \n    console.log(`Found ${inMemoryMeetings.length} meetings in memory`);\n    \n    // Synchronize missing data\n    let syncedMeetings = 0;\n    let syncedHistory = 0;\n    \n    // Sync in-memory meetings to MongoDB\n    for (const meeting of inMemoryMeetings) {\n      if (employeeId && meeting.employeeId !== employeeId) continue;\n      \n      const exists = await Meeting.findOne({ \n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime \n      });\n      \n      if (!exists) {\n        try {\n          const newMeeting = new Meeting({\n            employeeId: meeting.employeeId,\n            location: meeting.location,\n            startTime: meeting.startTime,\n            endTime: meeting.endTime,\n            clientName: meeting.clientName,\n            notes: meeting.notes,\n            status: meeting.status,\n            trackingSessionId: meeting.trackingSessionId,\n            leadId: meeting.leadId,\n            leadInfo: meeting.leadInfo,\n            meetingDetails: meeting.meetingDetails\n          });\n          \n          await newMeeting.save();\n          syncedMeetings++;\n          \n          // Also add to meeting history if completed\n          if (meeting.status === 'completed' && meeting.meetingDetails) {\n            const historyExists = await MeetingHistory.findOne({\n              employeeId: meeting.employeeId,\n              'meetingDetails.discussion': meeting.meetingDetails.discussion\n            });\n            \n            if (!historyExists) {\n              const newHistory = new MeetingHistory({\n                sessionId: meeting.trackingSessionId || `sync_${Date.now()}`,\n                employeeId: meeting.employeeId,\n                meetingDetails: meeting.meetingDetails,\n                timestamp: meeting.endTime || meeting.startTime,\n                leadId: meeting.leadId,\n                leadInfo: meeting.leadInfo\n              });\n              \n              await newHistory.save();\n              syncedHistory++;\n            }\n          }\n        } catch (syncError) {\n          console.warn(`Failed to sync meeting ${meeting.id}:`, syncError);\n        }\n      }\n    }\n    \n    // Get final counts\n    const finalMeetings = await Meeting.countDocuments(employeeId ? { employeeId } : {});\n    const finalHistory = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\n    \n    const result = {\n      success: true,\n      message: \"Data synchronization completed\",\n      stats: {\n        totalMeetingsInMongoDB: finalMeetings,\n        totalHistoryInMongoDB: finalHistory,\n        meetingsSynced: syncedMeetings,\n        historySynced: syncedHistory,\n        employeeId: employeeId || \"all\"\n      }\n    };\n    \n    console.log(\"Data sync result:\", result);\n    res.json(result);\n    \n  } catch (error) {\n    console.error(\"Error synchronizing data:\", error);\n    res.status(500).json({ \n      error: \"Failed to synchronize data\",\n      details: error.message \n    });\n  }\n};\n\n// Endpoint to get comprehensive data status\nexport const getDataStatus: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.query;\n    \n    // MongoDB counts\n    const mongoMeetingsCount = await Meeting.countDocuments(employeeId ? { employeeId } : {});\n    const mongoHistoryCount = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\n    const mongoEmployeesCount = await Employee.countDocuments();\n    const mongoTrackingCount = await TrackingSession.countDocuments(employeeId ? { employeeId } : {});\n    \n    // In-memory counts\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    const filteredInMemoryMeetings = employeeId \n      ? inMemoryMeetings.filter(m => m.employeeId === employeeId)\n      : inMemoryMeetings;\n    \n    // Sample data for debugging\n    const sampleMongoMeeting = await Meeting.findOne(employeeId ? { employeeId } : {}).lean();\n    const sampleMongoHistory = await MeetingHistory.findOne(employeeId ? { employeeId } : {}).lean();\n    \n    const status = {\n      employeeId: employeeId || \"all\",\n      mongoDB: {\n        meetings: mongoMeetingsCount,\n        history: mongoHistoryCount,\n        employees: mongoEmployeesCount,\n        trackingSessions: mongoTrackingCount,\n        sampleMeeting: sampleMongoMeeting ? {\n          id: sampleMongoMeeting._id,\n          employeeId: sampleMongoMeeting.employeeId,\n          status: sampleMongoMeeting.status,\n          hasDetails: !!sampleMongoMeeting.meetingDetails,\n          leadId: sampleMongoMeeting.leadId\n        } : null,\n        sampleHistory: sampleMongoHistory ? {\n          id: sampleMongoHistory._id,\n          employeeId: sampleMongoHistory.employeeId,\n          hasCustomers: sampleMongoHistory.meetingDetails?.customers?.length > 0,\n          discussion: sampleMongoHistory.meetingDetails?.discussion?.substring(0, 100)\n        } : null\n      },\n      inMemory: {\n        meetings: filteredInMemoryMeetings.length,\n        sampleMeeting: filteredInMemoryMeetings[0] ? {\n          id: filteredInMemoryMeetings[0].id,\n          employeeId: filteredInMemoryMeetings[0].employeeId,\n          status: filteredInMemoryMeetings[0].status,\n          hasDetails: !!filteredInMemoryMeetings[0].meetingDetails\n        } : null\n      }\n    };\n    \n    res.json(status);\n    \n  } catch (error) {\n    console.error(\"Error getting data status:\", error);\n    res.status(500).json({ \n      error: \"Failed to get data status\",\n      details: error.message \n    });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { Meeting, MeetingHistory } from \"../models\";\n\nexport const debugEmployeeData: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.params;\n    \n    console.log(`Debugging data for employee: ${employeeId}`);\n    \n    // Get MongoDB meetings\n    const mongoMeetings = await Meeting.find({ employeeId }).lean();\n    console.log(`Found ${mongoMeetings.length} meetings in MongoDB for employee ${employeeId}`);\n    \n    // Get MongoDB meeting history\n    const mongoHistory = await MeetingHistory.find({ employeeId }).lean();\n    console.log(`Found ${mongoHistory.length} history entries in MongoDB for employee ${employeeId}`);\n    \n    // Get in-memory meetings\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    const filteredInMemory = inMemoryMeetings.filter(m => m.employeeId === employeeId);\n    console.log(`Found ${filteredInMemory.length} meetings in memory for employee ${employeeId}`);\n    \n    const debugData = {\n      employeeId,\n      mongoDB: {\n        meetings: {\n          count: mongoMeetings.length,\n          data: mongoMeetings.map(m => ({\n            id: m._id.toString(),\n            startTime: m.startTime,\n            endTime: m.endTime,\n            status: m.status,\n            clientName: m.clientName,\n            leadId: m.leadId,\n            hasDetails: !!m.meetingDetails,\n            detailsCustomers: m.meetingDetails?.customers?.length || 0\n          }))\n        },\n        history: {\n          count: mongoHistory.length,\n          data: mongoHistory.map(h => ({\n            id: h._id.toString(),\n            timestamp: h.timestamp,\n            sessionId: h.sessionId,\n            leadId: h.leadId,\n            hasDetails: !!h.meetingDetails,\n            discussion: h.meetingDetails?.discussion?.substring(0, 100),\n            customers: h.meetingDetails?.customers?.length || 0,\n            customerNames: h.meetingDetails?.customers?.map(c => c.customerEmployeeName) || []\n          }))\n        }\n      },\n      inMemory: {\n        meetings: {\n          count: filteredInMemory.length,\n          data: filteredInMemory.map(m => ({\n            id: m.id,\n            startTime: m.startTime,\n            endTime: m.endTime,\n            status: m.status,\n            clientName: m.clientName,\n            leadId: m.leadId,\n            hasDetails: !!m.meetingDetails\n          }))\n        }\n      },\n      recommendations: []\n    };\n    \n    // Add recommendations based on data analysis\n    if (mongoMeetings.length === 0 && filteredInMemory.length > 0) {\n      debugData.recommendations.push(\"Meetings exist in memory but not in MongoDB - run data sync\");\n    }\n    \n    if (mongoMeetings.length > mongoHistory.length) {\n      debugData.recommendations.push(\"More meetings than history entries - some meetings may not have been completed properly\");\n    }\n    \n    if (mongoHistory.length === 0) {\n      debugData.recommendations.push(\"No meeting history found - check if meetings are being ended with proper details\");\n    }\n    \n    console.log(\"Debug data prepared:\", JSON.stringify(debugData, null, 2));\n    \n    res.json(debugData);\n    \n  } catch (error) {\n    console.error(\"Error in debug endpoint:\", error);\n    res.status(500).json({ error: \"Debug failed\", details: error.message });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { RouteSnapshot, IRouteSnapshot } from \"../models\";\n\n// In-memory fallback storage for route snapshots\nlet inMemorySnapshots: any[] = [];\nexport { inMemorySnapshots };\n\n// Get route snapshots with filtering\nexport const getRouteSnapshots: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      trackingSessionId,\n      status,\n      startDate,\n      endDate,\n      page = 1,\n      limit = 20\n    } = req.query;\n\n    console.log(\"Fetching route snapshots with query:\", { employeeId, trackingSessionId, status, startDate, endDate });\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const skip = (pageNum - 1) * limitNum;\n\n    try {\n      // Build MongoDB query\n      const query: any = {};\n\n      if (employeeId) {\n        query.employeeId = employeeId;\n      }\n\n      if (trackingSessionId) {\n        query.trackingSessionId = trackingSessionId;\n      }\n\n      if (status) {\n        query.status = status;\n      }\n\n      if (startDate || endDate) {\n        query.captureTime = {};\n        if (startDate) {\n          query.captureTime.$gte = new Date(startDate as string).toISOString();\n        }\n        if (endDate) {\n          query.captureTime.$lte = new Date(endDate as string).toISOString();\n        }\n      }\n\n      const snapshots = await RouteSnapshot.find(query)\n        .sort({ captureTime: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await RouteSnapshot.countDocuments(query);\n\n      const response = {\n        snapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${snapshots.length} route snapshots from MongoDB`);\n      res.json(response);\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      let filteredSnapshots = [...inMemorySnapshots];\n\n      // Apply filters\n      if (employeeId) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.employeeId === employeeId);\n      }\n\n      if (trackingSessionId) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.trackingSessionId === trackingSessionId);\n      }\n\n      if (status) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.status === status);\n      }\n\n      if (startDate || endDate) {\n        filteredSnapshots = filteredSnapshots.filter(s => {\n          const captureTime = new Date(s.captureTime);\n          if (startDate && captureTime < new Date(startDate as string)) return false;\n          if (endDate && captureTime > new Date(endDate as string)) return false;\n          return true;\n        });\n      }\n\n      // Sort by capture time (newest first)\n      filteredSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\n\n      // Apply pagination\n      const total = filteredSnapshots.length;\n      const paginatedSnapshots = filteredSnapshots.slice(skip, skip + limitNum);\n\n      const response = {\n        snapshots: paginatedSnapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${paginatedSnapshots.length} route snapshots from memory (${total} total)`);\n      res.json(response);\n    }\n  } catch (error) {\n    console.error(\"Error fetching route snapshots:\", error);\n    res.status(500).json({ error: \"Failed to fetch route snapshots\" });\n  }\n};\n\n// Get a specific route snapshot by ID\nexport const getRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    try {\n      // Try MongoDB first\n      const snapshot = await RouteSnapshot.findOne({ id });\n\n      if (snapshot) {\n        console.log(\"Route snapshot found in MongoDB:\", snapshot.id);\n        return res.json(snapshot);\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memorySnapshot = inMemorySnapshots.find(s => s.id === id);\n\n    if (memorySnapshot) {\n      console.log(\"Route snapshot found in memory:\", memorySnapshot.id);\n      return res.json(memorySnapshot);\n    }\n\n    return res.status(404).json({ error: \"Route snapshot not found\" });\n  } catch (error) {\n    console.error(\"Error fetching route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to fetch route snapshot\" });\n  }\n};\n\n// Create a new route snapshot\nexport const createRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      employeeName,\n      trackingSessionId,\n      title,\n      description,\n      startLocation,\n      endLocation,\n      route,\n      meetings,\n      totalDistance,\n      duration,\n      status,\n      mapBounds\n    } = req.body;\n\n    if (!employeeId || !employeeName || !title || !startLocation || !route || !mapBounds) {\n      return res.status(400).json({\n        error: \"Employee ID, name, title, start location, route, and map bounds are required\",\n      });\n    }\n\n    // Generate unique snapshot ID\n    const snapshotId = `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Calculate snapshot metadata\n    const snapshotMetadata = {\n      routeColor: '#3b82f6',\n      mapZoom: 12,\n      routePointsCount: route.length,\n      meetingsCount: meetings ? meetings.length : 0\n    };\n\n    const snapshotData = {\n      id: snapshotId,\n      employeeId,\n      employeeName,\n      trackingSessionId,\n      captureTime: new Date().toISOString(),\n      title,\n      description,\n      startLocation: {\n        ...startLocation,\n        timestamp: startLocation.timestamp || new Date().toISOString(),\n      },\n      endLocation: endLocation ? {\n        ...endLocation,\n        timestamp: endLocation.timestamp || new Date().toISOString(),\n      } : undefined,\n      route: route.map((point: any) => ({\n        ...point,\n        timestamp: point.timestamp || new Date().toISOString(),\n      })),\n      meetings: meetings || [],\n      totalDistance: totalDistance || 0,\n      duration,\n      status: status || 'active',\n      mapBounds,\n      snapshotMetadata\n    };\n\n    try {\n      // Try to save to MongoDB first\n      const newSnapshot = new RouteSnapshot(snapshotData);\n      const savedSnapshot = await newSnapshot.save();\n\n      console.log(\"Route snapshot created in MongoDB:\", savedSnapshot.id);\n      res.status(201).json(savedSnapshot);\n    } catch (mongoError) {\n      console.error(\"MongoDB save failed, saving to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      inMemorySnapshots.push(snapshotData);\n\n      console.log(\"Route snapshot created in memory:\", snapshotData.id);\n      res.status(201).json(snapshotData);\n    }\n  } catch (error) {\n    console.error(\"Error creating route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to create route snapshot\" });\n  }\n};\n\n// Update a route snapshot\nexport const updateRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n    let updated = false;\n\n    try {\n      // Try MongoDB first\n      const updatedSnapshot = await RouteSnapshot.findOneAndUpdate(\n        { id },\n        { $set: updates },\n        { new: true, runValidators: true }\n      );\n\n      if (updatedSnapshot) {\n        console.log(\"Route snapshot updated in MongoDB:\", updatedSnapshot.id);\n        return res.json(updatedSnapshot);\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB update failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\n    if (memoryIndex !== -1) {\n      inMemorySnapshots[memoryIndex] = { ...inMemorySnapshots[memoryIndex], ...updates };\n      console.log(\"Route snapshot updated in memory:\", inMemorySnapshots[memoryIndex].id);\n      return res.json(inMemorySnapshots[memoryIndex]);\n    }\n\n    return res.status(404).json({ error: \"Route snapshot not found\" });\n  } catch (error) {\n    console.error(\"Error updating route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to update route snapshot\" });\n  }\n};\n\n// Delete a route snapshot\nexport const deleteRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    let deleted = false;\n\n    try {\n      // Try MongoDB first\n      const deletedSnapshot = await RouteSnapshot.findOneAndDelete({ id });\n      if (deletedSnapshot) {\n        console.log(\"Route snapshot deleted from MongoDB:\", deletedSnapshot.id);\n        deleted = true;\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB delete failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\n    if (memoryIndex !== -1) {\n      const deletedSnapshot = inMemorySnapshots.splice(memoryIndex, 1)[0];\n      console.log(\"Route snapshot deleted from memory:\", deletedSnapshot.id);\n      deleted = true;\n    }\n\n    if (!deleted) {\n      return res.status(404).json({ error: \"Route snapshot not found\" });\n    }\n\n    res.status(204).send();\n  } catch (error) {\n    console.error(\"Error deleting route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to delete route snapshot\" });\n  }\n};\n\n// Get snapshots by employee\nexport const getEmployeeSnapshots: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.params;\n    const { page = 1, limit = 10 } = req.query;\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const skip = (pageNum - 1) * limitNum;\n\n    try {\n      // Try MongoDB first\n      const snapshots = await RouteSnapshot.find({ employeeId })\n        .sort({ captureTime: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await RouteSnapshot.countDocuments({ employeeId });\n\n      const response = {\n        snapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${snapshots.length} snapshots for employee ${employeeId} from MongoDB`);\n      res.json(response);\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      const employeeSnapshots = inMemorySnapshots.filter(s => s.employeeId === employeeId);\n\n      // Sort by capture time (newest first)\n      employeeSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\n\n      // Apply pagination\n      const total = employeeSnapshots.length;\n      const paginatedSnapshots = employeeSnapshots.slice(skip, skip + limitNum);\n\n      const response = {\n        snapshots: paginatedSnapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${paginatedSnapshots.length} snapshots for employee ${employeeId} from memory (${total} total)`);\n      res.json(response);\n    }\n  } catch (error) {\n    console.error(\"Error fetching employee snapshots:\", error);\n    res.status(500).json({ error: \"Failed to fetch employee snapshots\" });\n  }\n};\n","import { RequestHandler } from \"express\";\r\nimport axios from 'axios';\r\n\r\n// Update follow-up meeting status\r\nexport const updateFollowUpStatus: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { status, meetingDetails } = req.body;\r\n    // Allow followUpId to be passed either as URL param or in the body\r\n    const followUpId = (req.params && (req.params as any).id) || (req.body && req.body.followUpId);\r\n\r\n    if (!followUpId || !status) {\r\n      return res.status(400).json({\r\n        error: \"Missing required fields: followUpId and status are required\",\r\n      });\r\n    }\r\n\r\n    console.log(\"Updating follow-up status:\", {\r\n      followUpId,\r\n      status,\r\n      meetingDetails,\r\n    });\r\n\r\n    // Construct the external API URL for updating follow-up status\r\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\r\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\r\n    \r\n    // Prefer external endpoint updateFollowUp/:id if available\r\n    const updateUrl = `${baseUrl}/updateFollowUp/${followUpId}`;\r\n\r\n    const updatePayload = {\r\n      meetingStatus: status,\r\n      meetingDetails: meetingDetails,\r\n      updatedAt: new Date().toISOString(),\r\n    };\r\n\r\n    console.log(\"Sending update to external API (updateFollowUp/:id):\", {\r\n      url: updateUrl,\r\n      payload: updatePayload,\r\n    });\r\n\r\n    // Try calling the updateFollowUp/:id endpoint first\r\n    let response;\r\n    try {\r\n      response = await axios.put(updateUrl, updatePayload, {\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        timeout: 10000,\r\n      });\r\n    } catch (err) {\r\n      console.warn(\"updateFollowUp/:id failed, falling back to updateFollowUpHistory\", err?.message || err);\r\n      // Fallback to older endpoint if available\r\n      const fallbackUrl = `${baseUrl}/updateFollowUpHistory`;\r\n      const fallbackPayload = {\r\n        id: followUpId,\r\n        status: status,\r\n        meetingDetails: meetingDetails,\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n      console.log(\"Sending update to external API (fallback):\", { url: fallbackUrl, payload: fallbackPayload });\r\n      response = await axios.put(fallbackUrl, fallbackPayload, {\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        timeout: 10000,\r\n      });\r\n    }\r\n\r\n    if (response.status === 200 || response.data.success) {\r\n      console.log(\"Follow-up status updated successfully:\", response.data);\r\n      return res.json({\r\n        message: \"Follow-up status updated successfully\",\r\n        data: response.data,\r\n      });\r\n    } else {\r\n      console.error(\"Failed to update follow-up status:\", response.data);\r\n      return res.status(400).json({\r\n        error: \"Failed to update follow-up status\",\r\n        details: response.data,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating follow-up status:\", error);\r\n\r\n    if (axios.isAxiosError(error)) {\r\n      const errorMessage = error.response?.data?.message || error.message;\r\n      return res.status(error.response?.status || 500).json({\r\n        error: \"Failed to update follow-up status\",\r\n        details: errorMessage,\r\n      });\r\n    }\r\n\r\n    return res.status(500).json({\r\n      error: \"Internal server error\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\",\r\n    });\r\n  }\r\n};\r\n\r\n// Get follow-up history for a user\r\nexport const getFollowUpHistory: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { userId } = req.query;\r\n\r\n    if (!userId) {\r\n      return res.status(400).json({\r\n        error: \"Missing required parameter: userId\",\r\n      });\r\n    }\r\n\r\n    console.log(\"Fetching follow-up history for user:\", userId);\r\n\r\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\r\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\r\n    const url = `${baseUrl}/getFollowUpHistory?userId=${userId}`;\r\n\r\n    console.log(\"Fetching from external API:\", url);\r\n\r\n    const response = await axios.get(url, {\r\n      timeout: 10000,\r\n    });\r\n\r\n    if (response.status === 200 && response.data) {\r\n      console.log(`Fetched ${response.data.length || 0} follow-up records`);\r\n      return res.json(response.data);\r\n    } else {\r\n      console.error(\"Failed to fetch follow-up history:\", response.data);\r\n      return res.status(400).json({\r\n        error: \"Failed to fetch follow-up history\",\r\n        details: response.data,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching follow-up history:\", error);\r\n\r\n    if (axios.isAxiosError(error)) {\r\n      const errorMessage = error.response?.data?.message || error.message;\r\n      return res.status(error.response?.status || 500).json({\r\n        error: \"Failed to fetch follow-up history\",\r\n        details: errorMessage,\r\n      });\r\n    }\r\n\r\n    return res.status(500).json({\r\n      error: \"Internal server error\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\",\r\n    });\r\n  }\r\n};\r\n","import express from \"express\";\r\nimport cors from \"cors\";\r\nimport path from \"path\";\r\nimport Database from \"./config/database\";\r\nimport { handleDemo } from \"./routes/demo\";\r\nimport {\r\n  getEmployees,\r\n  getEmployee,\r\n  updateEmployeeLocation,\r\n  updateEmployeeStatus,\r\n  createEmployee,\r\n  updateEmployee,\r\n  deleteEmployee,\r\n  refreshEmployeeLocations,\r\n  clearLocationCache,\r\n} from \"./routes/employees\";\r\nimport {\r\n  getMeetings,\r\n  createMeeting,\r\n  updateMeeting,\r\n  getMeeting,\r\n  deleteMeeting,\r\n  getActiveMeeting,\r\n  updateMeetingApproval,\r\n  updateMeetingApprovalByDetails,\r\n} from \"./routes/meetings\";\r\nimport {\r\n  getTrackingSessions,\r\n  createTrackingSession,\r\n  updateTrackingSession,\r\n  addLocationToRoute,\r\n  getTrackingSession,\r\n  deleteTrackingSession,\r\n  getMeetingHistory,\r\n  addMeetingToHistory,\r\n  saveIncompleteMeetingRemark,\r\n  getIncompleteMeetingRemark,\r\n} from \"./routes/tracking\";\r\nimport {\r\n  getEmployeeAnalytics,\r\n  getEmployeeDetails,\r\n  getLeadHistory,\r\n  saveAttendance,\r\n  getAttendance,\r\n  getMeetingTrends,\r\n  getAllEmployeesDetails,\r\n} from \"./routes/analytics\";\r\nimport {\r\n  syncAllData,\r\n  getDataStatus,\r\n} from \"./routes/data-sync\";\r\nimport {\r\n  debugEmployeeData,\r\n} from \"./routes/debug\";\r\nimport {\r\n  getRouteSnapshots,\r\n  getRouteSnapshot,\r\n  createRouteSnapshot,\r\n  updateRouteSnapshot,\r\n  deleteRouteSnapshot,\r\n  getEmployeeSnapshots,\r\n} from \"./routes/route-snapshots\";\r\nimport { updateFollowUpStatus, getFollowUpHistory } from \"./routes/follow-ups\";\r\nimport { fileURLToPath } from \"url\";\r\n\r\n// ES module equivalent of __dirname\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nexport function createServer() {\r\n  const app = express();\r\n\r\n  // Initialize database connection\r\n  const initializeDatabase = async () => {\r\n    try {\r\n      const db = Database.getInstance();\r\n      await db.connect();\r\n    } catch (error) {\r\n      console.error('Failed to initialize database:', error);\r\n      // Continue without database for development\r\n    }\r\n  };\r\n\r\n  // Start database connection (non-blocking)\r\n  initializeDatabase();\r\n\r\n  // Middleware\r\n  app.use(cors());\r\n  app.use(express.json());\r\n  app.use(express.urlencoded({ extended: true }));\r\n\r\n  // Request logging\r\n  app.use((req, res, next) => {\r\n    console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);\r\n    next();\r\n  });\r\n\r\n  // Example API routes\r\n  app.get(\"/api/ping\", (_req, res) => {\r\n    console.log(\"Health check ping received\");\r\n    res.json({\r\n      message: \"Hello from Express server v2!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\",\r\n    });\r\n  });\r\n\r\n  app.get(\"/api/demo\", handleDemo);\r\n  \r\n  // Test endpoint for attendance\r\n  app.get(\"/api/test-attendance\", (_req, res) => {\r\n    console.log(\"Test attendance endpoint hit\");\r\n    res.json({\r\n      message: \"Attendance route is working!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\"\r\n    });\r\n  });\r\n\r\n  // Employee routes\r\n  app.get(\"/api/employees\", getEmployees);\r\n  app.post(\"/api/employees\", createEmployee);\r\n  app.get(\"/api/employees/:id\", getEmployee);\r\n  app.put(\"/api/employees/:id\", updateEmployee);\r\n  app.delete(\"/api/employees/:id\", deleteEmployee);\r\n  app.put(\"/api/employees/:id/location\", updateEmployeeLocation);\r\n  app.put(\"/api/employees/:id/status\", updateEmployeeStatus);\r\n  app.post(\"/api/employees/refresh-locations\", refreshEmployeeLocations);\r\n  app.post(\"/api/employees/clear-cache\", clearLocationCache);\r\n\r\n  // Meeting routes\r\n  app.get(\"/api/meetings\", getMeetings);\r\n  app.post(\"/api/meetings\", createMeeting);\r\n  app.get(\"/api/meetings/active\", getActiveMeeting); // üîπ NEW: Get active meeting\r\n  app.get(\"/api/meetings/:id\", getMeeting);\r\n  app.put(\"/api/meetings/:id\", updateMeeting);\r\n  app.put(\"/api/meetings/:id/approval\", updateMeetingApproval); // Meeting approval by ID\r\n  app.put(\"/api/meetings/approval-by-details\", updateMeetingApprovalByDetails); // Meeting approval by composite key\r\n  app.delete(\"/api/meetings/:id\", deleteMeeting);\r\n\r\n  // Tracking session routes\r\n  app.get(\"/api/tracking-sessions\", getTrackingSessions);\r\n  app.post(\"/api/tracking-sessions\", createTrackingSession);\r\n  app.get(\"/api/tracking-sessions/:id\", getTrackingSession);\r\n  app.put(\"/api/tracking-sessions/:id\", updateTrackingSession);\r\n  app.delete(\"/api/tracking-sessions/:id\", deleteTrackingSession);\r\n  app.post(\"/api/tracking-sessions/:id/location\", addLocationToRoute);\r\n\r\n  // Meeting history routes\r\n  app.get(\"/api/meeting-history\", getMeetingHistory);\r\n  app.post(\"/api/meeting-history\", addMeetingToHistory);\r\n  app.post(\"/api/incomplete-meeting-remarks\", saveIncompleteMeetingRemark);\r\n  // Expose both paths for backward compatibility and ease-of-use from the client\r\n  app.get(\"/api/get-incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n  // Preferred/clean path the frontend should call to fetch incomplete meeting remarks by employeeId\r\n  app.get(\"/api/incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n\r\n  // Analytics routes\r\n  app.get(\"/api/analytics/employees\", getEmployeeAnalytics);\r\n  app.get(\"/api/analytics/employee-details/:employeeId\", getEmployeeDetails);\r\n  app.get(\"/api/analytics/all-employees-details\", getAllEmployeesDetails); // New endpoint for all employees\r\n  app.get(\"/api/analytics/lead-history/:leadId\", getLeadHistory);\r\n  app.post(\"/api/analytics/save-attendance\", saveAttendance);\r\n  app.get(\"/api/analytics/attendance\", (req, res, next) => {\r\n    console.log(\"üéØ Attendance route hit!\", {\r\n      query: req.query,\r\n      url: req.url,\r\n      method: req.method\r\n    });\r\n    getAttendance(req, res, next);\r\n  });\r\n  app.get(\"/api/analytics/trends\", getMeetingTrends);\r\n\r\n  // Data synchronization routes\r\n  app.post(\"/api/data-sync\", syncAllData);\r\n  app.get(\"/api/data-status\", getDataStatus);\r\n\r\n  // Debug routes\r\n  app.get(\"/api/debug/employee/:employeeId\", debugEmployeeData);\r\n\r\n  // Route snapshot routes\r\n  app.get(\"/api/route-snapshots\", getRouteSnapshots);\r\n  app.post(\"/api/route-snapshots\", createRouteSnapshot);\r\n  app.get(\"/api/route-snapshots/:id\", getRouteSnapshot);\r\n  app.put(\"/api/route-snapshots/:id\", updateRouteSnapshot);\r\n  app.delete(\"/api/route-snapshots/:id\", deleteRouteSnapshot);\r\n  app.get(\"/api/employees/:employeeId/snapshots\", getEmployeeSnapshots);\r\n\r\n  // Follow-up meeting routes\r\n  app.get(\"/api/follow-ups\", getFollowUpHistory);\r\n  app.put(\"/api/follow-ups/:id\", updateFollowUpStatus);\r\n\r\n  // Serve static files in production\r\n  if (process.env.NODE_ENV === 'production') {\r\n    const distPath = path.join(__dirname, '../spa');\r\n    \r\n    console.log('üì¶ Serving static files from:', distPath);\r\n    \r\n    // Serve static files\r\n    app.use(express.static(distPath));\r\n    \r\n    // Handle React Router - serve index.html for all non-API routes\r\n    app.get('*', (req, res) => {\r\n      // Don't serve index.html for API routes\r\n      if (req.path.startsWith('/api/')) {\r\n        return res.status(404).json({ error: 'API endpoint not found' });\r\n      }\r\n      \r\n      const indexPath = path.join(distPath, 'index.html');\r\n      console.log('üìÑ Serving index.html for:', req.path);\r\n      res.sendFile(indexPath);\r\n    });\r\n  }\r\n\r\n  return app;\r\n}\r\n","import path from \"path\";\nimport { createServer } from \"./index\";\nimport * as express from \"express\";\n\nconst app = createServer();\nconst port = process.env.PORT || 3000;\n\n// In production, serve the built SPA files\nconst __dirname = import.meta.dirname;\nconst distPath = path.join(__dirname, \"../spa\");\n\n// Serve static files\napp.use(express.static(distPath));\n\n// Handle React Router - serve index.html for all non-API routes\napp.get(\"*\", (req, res) => {\n  // Don't serve index.html for API routes\n  if (req.path.startsWith(\"/api/\") || req.path.startsWith(\"/health\")) {\n    return res.status(404).json({ error: \"API endpoint not found\" });\n  }\n\n  res.sendFile(path.join(distPath, \"index.html\"));\n});\n\napp.listen(port, () => {\n  console.log(`üöÄ Fusion Starter server running on port ${port}`);\n  console.log(`üì± Frontend: http://localhost:${port}`);\n  console.log(`üîß API: http://localhost:${port}/api`);\n});\n\n// Graceful shutdown\nprocess.on(\"SIGTERM\", () => {\n  console.log(\"üõë Received SIGTERM, shutting down gracefully\");\n  process.exit(0);\n});\n\nprocess.on(\"SIGINT\", () => {\n  console.log(\"üõë Received SIGINT, shutting down gracefully\");\n  process.exit(0);\n});\n"],"names":["CustomerContactSchema","MeetingDetailsSchema","LocationSchema","LeadInfoSchema","LocationDataSchema","EXTERNAL_API_URL","GEOCACHE_TTL","employeeStatuses","geocodeCache","EmployeeModel","fetchExternalUsers","mapExternalUserToEmployee","employee","lastGeocodingTime","GEOCODING_DELAY","reverseGeocode","response","allMeetings","meeting","meetingLog","TrackingSessionModel","newSession","session","startOfWeek","pageNum","limitNum","newHistoryEntry","incompleteMeetings","inMemoryMeetings","trackingSessions","TrackingSession","meetings","__dirname","app","express","distPath"],"mappings":";;;;;;;;;;AAIA,OAAO,OAAO;AAQP,MAAM,WAA2B;AAAA,EACtC,aAAa,QAAQ,IAAI,eAAe;AAAA,EACxC,SAAS,QAAQ,IAAI,WAAW;AAClC;AAEA,MAAM,SAAS;AAAA,EACb,OAAe;AAAA,EACP,cAAc;AAAA,EAEd,cAAc;AAAA,EAAA;AAAA,EAEtB,OAAc,cAAwB;AAChC,QAAA,CAAC,SAAS,UAAU;AACb,eAAA,WAAW,IAAI,SAAS;AAAA,IAAA;AAEnC,WAAO,SAAS;AAAA,EAAA;AAAA,EAGlB,MAAa,UAAyB;AACpC,QAAI,KAAK,aAAa;AACpB,cAAQ,IAAI,2CAA2C;AACvD;AAAA,IAAA;AAGE,QAAA;AACF,cAAQ,IAAI,yCAAyC;AAC7C,cAAA,IAAI,qBAAqB,SAAS,WAAW;AAE/C,YAAA,SAAS,QAAQ,SAAS,aAAa;AAAA,QAC3C,QAAQ,SAAS;AAAA,MAAA,CAClB;AAED,WAAK,cAAc;AACnB,cAAQ,IAAI,+CAA+C;AAG3D,eAAS,WAAW,GAAG,SAAS,CAAC,UAAU;AACjC,gBAAA,MAAM,yCAAyC,KAAK;AAC5D,aAAK,cAAc;AAAA,MAAA,CACpB;AAEQ,eAAA,WAAW,GAAG,gBAAgB,MAAM;AAC3C,gBAAQ,IAAI,mCAAmC;AAC/C,aAAK,cAAc;AAAA,MAAA,CACpB;AAEQ,eAAA,WAAW,GAAG,eAAe,MAAM;AAC1C,gBAAQ,IAAI,kCAAkC;AAC9C,aAAK,cAAc;AAAA,MAAA,CACpB;AAAA,aAEM,OAAO;AACN,cAAA,MAAM,6CAA6C,KAAK;AAChE,WAAK,cAAc;AACb,YAAA;AAAA,IAAA;AAAA,EACR;AAAA,EAGF,MAAa,aAA4B;AACnC,QAAA,CAAC,KAAK,aAAa;AACrB;AAAA,IAAA;AAGE,QAAA;AACF,YAAM,SAAS,WAAW;AAC1B,WAAK,cAAc;AACnB,cAAQ,IAAI,wCAAwC;AAAA,aAC7C,OAAO;AACN,cAAA,MAAM,iDAAiD,KAAK;AAAA,IAAA;AAAA,EACtE;AAAA,EAGK,qBAA8B;AACnC,WAAO,KAAK,eAAe,SAAS,WAAW,eAAe;AAAA,EAAA;AAAA,EAGzD,gBAAgB;AACrB,WAAO,SAAS;AAAA,EAAA;AAEpB;ACxFa,MAAA,aAA6B,CAAC,KAAK,QAAQ;AACtD,QAAM,WAAyB;AAAA,IAC7B,SAAS;AAAA,EACX;AACA,MAAI,OAAO,GAAG,EAAE,KAAK,QAAQ;AAC/B;ACwDA,MAAMA,0BAAwB,IAAI,OAAO;AAAA,EACxC,cAAc,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EAC7C,sBAAsB,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACrD,eAAe,EAAE,MAAM,OAAO;AAAA,EAC9B,gBAAgB,EAAE,MAAM,OAAO;AAAA,EAC/B,qBAAqB,EAAE,MAAM,OAAO;AAAA,EACpC,oBAAoB,EAAE,MAAM,OAAO;AACpC,CAAC;AAID,MAAMC,yBAAuB,IAAI,OAAO;AAAA,EACvC,WAAW,CAACD,uBAAqB;AAAA,EACjC,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA;AAAA,EAE3C,cAAc,EAAE,MAAM,OAAO;AAAA,EAC7B,sBAAsB,EAAE,MAAM,OAAO;AAAA,EACrC,eAAe,EAAE,MAAM,OAAO;AAAA,EAC9B,gBAAgB,EAAE,MAAM,OAAO;AAAA,EAC/B,qBAAqB,EAAE,MAAM,OAAO;AAAA,EACpC,oBAAoB,EAAE,MAAM,OAAO;AACpC,CAAC;AAID,MAAM,mBAAmB,IAAI,OAAO;AAAA,EACnC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,SAAS,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxC,WAAW,EAAE,MAAM,OAAO;AAC3B,GAAG,EAAE,KAAK,OAAO;AAGjB,MAAME,mBAAiB,IAAI,OAAO;AAAA,EACjC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,SAAS,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxC,aAAa,EAAE,MAAM,iBAAiB;AAAA,EACtC,WAAW,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC3C,CAAC;AAMD,MAAMC,mBAAiB,IAAI,OAAO;AAAA,EACjC,IAAI,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACnC,aAAa,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EAC5C,aAAa,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC7C,CAAC;AAID,MAAM,gBAAgB,IAAI,OAAO;AAAA,EAChC,YAAY;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,UAAU;AAAA,IACR,MAAMD;AAAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,WAAW;AAAA,IACT,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,YAAY;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,OAAO;AAAA,IACL,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,MAAM,CAAC,WAAW,eAAe,WAAW;AAAA,IAC5C,SAAS;AAAA,IACT,OAAO;AAAA,EACT;AAAA,EACA,mBAAmB;AAAA,IACjB,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,UAAUC;AAAAA,EACV,YAAY;AAAA,IACV,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,gBAAgBF;AAAAA,EAChB,uBAAuB;AAAA,IACrB,MAAM;AAAA,EACR;AAAA,EACA,gBAAgB;AAAA,IACd,MAAM;AAAA,IACN,MAAM,CAAC,MAAM,QAAQ;AAAA,IACrB,OAAO;AAAA,EACT;AAAA,EACA,gBAAgB;AAAA,IACd,MAAM;AAAA,EAAA;AAET,GAAG;AAAA,EACF,YAAY;AAAA,EACZ,YAAY;AACb,CAAC;AAID,cAAc,MAAM,EAAE,YAAY,GAAG,WAAW,IAAI;AACpD,cAAc,MAAM,EAAE,QAAQ,GAAG,WAAW,IAAI;AAChD,cAAc,MAAM,EAAE,QAAQ,GAAG,WAAW,IAAI;AAGzC,MAAM,UAAU,SAAS,MAAgB,WAAW,aAAa;AC7IxE,MAAM,wBAAwB,IAAI,OAAO;AAAA,EACvC,cAAc,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EAC7C,sBAAsB,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACrD,eAAe,EAAE,MAAM,OAAO;AAAA,EAC9B,gBAAgB,EAAE,MAAM,OAAO;AAAA,EAC/B,qBAAqB,EAAE,MAAM,OAAO;AAAA,EACpC,oBAAoB,EAAE,MAAM,OAAO;AACrC,CAAC;AAGD,MAAM,uBAAuB,IAAI,OAAO;AAAA,EACtC,WAAW,CAAC,qBAAqB;AAAA,EACjC,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA;AAAA,EAE3C,YAAY,EAAE,MAAM,SAAS,SAAS,OAAO,OAAO,KAAK;AAAA,EACzD,kBAAkB,EAAE,MAAM,OAAO;AAAA;AAAA,EAEjC,cAAc,EAAE,MAAM,OAAO;AAAA,EAC7B,sBAAsB,EAAE,MAAM,OAAO;AAAA,EACrC,eAAe,EAAE,MAAM,OAAO;AAAA,EAC9B,gBAAgB,EAAE,MAAM,OAAO;AAAA,EAC/B,qBAAqB,EAAE,MAAM,OAAO;AAAA,EACpC,oBAAoB,EAAE,MAAM,OAAO;AACrC,CAAC;AAGD,MAAM,iBAAiB,IAAI,OAAO;AAAA,EAChC,IAAI,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACnC,aAAa,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EAC5C,aAAa,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC9C,CAAC;AAGD,MAAM,uBAAuB,IAAI,OAAO;AAAA,EACtC,WAAW;AAAA,IACT,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,YAAY;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,gBAAgB;AAAA,IACd,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,WAAW;AAAA,IACT,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,UAAU;AACZ,GAAG;AAAA,EACD,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AAGD,qBAAqB,MAAM,EAAE,YAAY,GAAG,WAAW,IAAI;AAC3D,qBAAqB,MAAM,EAAE,QAAQ,GAAG,WAAW,IAAI;AACvD,qBAAqB,MAAM,EAAE,WAAW,GAAG,WAAW,IAAI;AAEnD,MAAM,iBAAiB,SAAS,MAAuB,kBAAkB,oBAAoB;AChGpG,MAAM,mBAAmB,IAAI,OAAO;AAAA,EAClC,YAAY;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA;AAAA,EACT;AAAA,EACA,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,MAAM,CAAC,YAAY,YAAY,OAAO,eAAe,IAAI;AAAA,IACzD,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,mBAAmB;AAAA,IACjB,MAAM;AAAA,IACN,SAAS;AAAA;AAAA,EAAA;AAEb,GAAG;AAAA,EACD,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AAGD,iBAAiB,MAAM,EAAE,YAAY,GAAG,MAAM,KAAK,EAAE,QAAQ,MAAM;AAGnE,iBAAiB,MAAM,EAAE,YAAY,GAAG,MAAM,IAAI;AAClD,iBAAiB,MAAM,EAAE,MAAM,IAAI,kBAAkB,GAAG;AAEjD,MAAM,aAAa,SAAS,MAAmB,cAAc,gBAAgB;ACzBpF,MAAMG,uBAAqB,IAAI,OAAO;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,SAAS,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxC,WAAW,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC5C,CAAC;AAGD,MAAM,wBAAwB,IAAI,OAAO;AAAA,EACvC,IAAI;AAAA,IACF,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,YAAY;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,WAAW;AAAA,IACT,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,eAAe;AAAA,IACb,MAAMA;AAAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,aAAa;AAAA,IACX,MAAMA;AAAAA,EACR;AAAA,EACA,OAAO,CAACA,oBAAkB;AAAA,EAC1B,eAAe;AAAA,IACb,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,UAAU;AAAA,IACR,MAAM;AAAA;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,MAAM,CAAC,UAAU,aAAa,QAAQ;AAAA,IACtC,SAAS;AAAA,IACT,OAAO;AAAA,EAAA;AAEX,GAAG;AAAA,EACD,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AAGD,sBAAsB,MAAM,EAAE,YAAY,GAAG,WAAW,IAAI;AAC5D,sBAAsB,MAAM,EAAE,QAAQ,GAAG,WAAW,IAAI;AACxD,sBAAsB,MAAM,EAAE,YAAY,GAAG,QAAQ,GAAG,WAAW,IAAI;AAEhE,MAAM,kBAAkB,SAAS,MAAwB,mBAAmB,qBAAqB;ACxDxG,MAAM,iBAAiB,IAAI,OAAO;AAAA,EAChC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,SAAS,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxC,WAAW,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC5C,CAAC;AAGD,MAAM,iBAAiB,IAAI,OAAO;AAAA,EAChC,IAAI;AAAA,IACF,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,OAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,OAAO;AAAA,IACL,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,MAAM,CAAC,UAAU,YAAY,SAAS;AAAA,IACtC,SAAS;AAAA,IACT,OAAO;AAAA,EACT;AAAA,EACA,UAAU;AAAA,EACV,YAAY;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,EACR;AAAA,EACA,UAAU;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,EACR;AAAA,EACA,YAAY;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,EACR;AAAA,EACA,UAAU;AAAA,IACR,MAAM;AAAA,EAAA;AAEV,GAAG;AAAA,EACD,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AAGD,eAAe,MAAM,EAAE,QAAQ,GAAG,MAAM,GAAG;AAC3C,eAAe,MAAM,EAAE,aAAa,GAAG,YAAY,GAAG;AACtD,eAAe,MAAM,EAAE,MAAM,QAAQ,OAAO,QAAQ;AAE7C,MAAM,WAAW,SAAS,MAAiB,YAAY,cAAc;AC7C5E,MAAM,qBAAqB,IAAI,OAAO;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,KAAK,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACpC,SAAS,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxC,WAAW,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC5C,CAAC;AAGD,MAAM,wBAAwB,IAAI,OAAO;AAAA,EACvC,IAAI,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACnC,UAAU,EAAE,MAAM,oBAAoB,UAAU,KAAK;AAAA,EACrD,YAAY,EAAE,MAAM,OAAO;AAAA,EAC3B,WAAW,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EAC1C,SAAS,EAAE,MAAM,OAAO;AAAA,EACxB,QAAQ,EAAE,MAAM,QAAQ,UAAU,KAAK;AACzC,CAAC;AAGD,MAAM,kBAAkB,IAAI,OAAO;AAAA,EACjC,OAAO,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACtC,OAAO,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACtC,MAAM,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACrC,MAAM,EAAE,MAAM,QAAQ,UAAU,KAAK;AACvC,CAAC;AAGD,MAAM,yBAAyB,IAAI,OAAO;AAAA,EACxC,YAAY,EAAE,MAAM,QAAQ,SAAS,UAAU;AAAA,EAC/C,SAAS,EAAE,MAAM,QAAQ,SAAS,GAAG;AAAA,EACrC,kBAAkB,EAAE,MAAM,QAAQ,SAAS,EAAE;AAAA,EAC7C,eAAe,EAAE,MAAM,QAAQ,SAAS,EAAE;AAC5C,CAAC;AAGD,MAAM,sBAAsB,IAAI,OAAO;AAAA,EACrC,IAAI;AAAA,IACF,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,YAAY;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,cAAc;AAAA,IACZ,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,mBAAmB;AAAA,IACjB,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AAAA,EACA,eAAe;AAAA,IACb,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,EACR;AAAA,EACA,OAAO,CAAC,kBAAkB;AAAA,EAC1B,UAAU,CAAC,qBAAqB;AAAA,EAChC,eAAe;AAAA,IACb,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,UAAU;AAAA,IACR,MAAM;AAAA;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,MAAM,CAAC,UAAU,WAAW;AAAA,IAC5B,SAAS;AAAA,IACT,OAAO;AAAA,EACT;AAAA,EACA,OAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,aAAa;AAAA,IACX,MAAM;AAAA,EACR;AAAA,EACA,WAAW;AAAA,IACT,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,UAAU;AAAA,EAAA;AAEd,GAAG;AAAA,EACD,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AAGD,oBAAoB,MAAM,EAAE,YAAY,GAAG,aAAa,IAAI;AAC5D,oBAAoB,MAAM,EAAE,mBAAmB,GAAG,aAAa,IAAI;AACnE,oBAAoB,MAAM,EAAE,QAAQ,GAAG,aAAa,IAAI;AACxD,oBAAoB,MAAM,EAAE,YAAY,GAAG,QAAQ,GAAG,aAAa,IAAI;AAEhE,MAAM,gBAAgB,SAAS,MAAsB,iBAAiB,mBAAmB;AChJhG,MAAMC,qBAAmB;AACzB,MAAM,gBAAgB;AACtB,MAAMC,iBAAe,KAAK,KAAK;AAqB/B,IAAIC,qBAAmD,CAAC;AACxD,MAAMC,qCAAmB,IAAkD;AA4C3E,eAAe,0BACb,KACA,KACiB;AACjB,MAAI,QAAQ,KAAK,QAAQ,EAAU,QAAA;AAE7B,QAAA,kBAAkB,GAAG,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC;AACtD,QAAA,WAAW,GAAG,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC;AAC9C,QAAA,SAASA,eAAa,IAAI,QAAQ;AAGxC,MAAI,UAAU,OAAO,UAAU,KAAK,OAAO;AACjC,YAAA,IAAI,8BAA8B,GAAG,KAAK,GAAG,KAAK,OAAO,OAAO,EAAE;AAC1E,WAAO,OAAO;AAAA,EAAA;AAIZ,MAAA;AACF,YAAQ,IAAI,yCAAyC,GAAG,KAAK,GAAG,EAAE;AAClE,UAAM,WAAW,MAAM,MAAM,IAAI,eAAe;AAAA,MAC9C,QAAQ;AAAA,QACN,QAAQ;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL,MAAM;AAAA,QACN,gBAAgB;AAAA,MAClB;AAAA,MACA,SAAS;AAAA,QACP,cAAc;AAAA,MAChB;AAAA,MACA,SAAS;AAAA;AAAA,IAAA,CACV;AAEK,UAAA,UAAU,SAAS,MAAM,gBAAgB;AACvC,YAAA,IAAI,uBAAuB,OAAO,EAAE;AAG5CA,mBAAa,IAAI,UAAU;AAAA,MACzB;AAAA,MACA,SAAS,KAAK,QAAQF;AAAAA,IAAA,CACvB;AAEM,WAAA;AAAA,WACA,OAAO;AACd,YAAQ,KAAK,2BAA2B,GAAG,KAAK,GAAG,wBAAwB,MAAM,OAAO;AAEjF,WAAA;AAAA,EAAA;AAEX;AAEA,eAAe,0BAA0B,YAAoB;AACvD,MAAA;AAEI,UAAA,WAAY,MAAM,QAAQ,KAAK;AAAA,MACnCG,SAAc,QAAQ,EAAE,IAAI,WAAY,CAAA,EAAE,KAAK;AAAA,MAC/C,IAAI;AAAA,QAAQ,CAAC,GAAG,WACd,WAAW,MAAM,OAAO,IAAI,MAAM,YAAY,CAAC,GAAG,GAAG;AAAA,MAAA;AAAA,IACvD,CACD;AAED,QAAI,UAAU,UAAU,OAAO,SAAS,SAAS,QAAQ,GAAG;AAC1D,YAAM,UACJ,SAAS,SAAS,WAClB,GAAG,SAAS,SAAS,IAAI,QAAQ,CAAC,CAAC,KAAK,SAAS,SAAS,IAAI,QAAQ,CAAC,CAAC;AAEnE,aAAA;AAAA,QACL,KAAK,SAAS,SAAS;AAAA,QACvB,KAAK,SAAS,SAAS;AAAA,QACvB;AAAA,QACA,WAAW,SAAS,SAAS;AAAA,QAC7B,YAAY,SAAS,cAAc;AAAA,MACrC;AAAA,IAAA;AAII,UAAA,gBAAiB,MAAM,QAAQ,KAAK;AAAA,MACxC,gBAAgB,QAAQ;AAAA,QACtB;AAAA,QACA,KAAK,CAAC,EAAE,QAAQ,YAAY,EAAE,QAAQ,YAAa,CAAA;AAAA,MAAA,CACpD,EACE,KAAK,EAAE,WAAW,GAAG,CAAC,EACtB,KAAK;AAAA,MACR,IAAI;AAAA,QAAQ,CAAC,GAAG,WACd,WAAW,MAAM,OAAO,IAAI,MAAM,YAAY,CAAC,GAAG,GAAG;AAAA,MAAA;AAAA,IACvD,CACD;AAED,QAAI,eAAe;AACX,YAAA,iBAAiB,cAAc,OAAO,SACxC,cAAc,MAAM,cAAc,MAAM,SAAS,CAAC,IAClD,cAAc;AAElB,UAAI,gBAAgB,QAAQ,KAAK,gBAAgB,QAAQ,GAAG;AAC1D,cAAM,UACJ,eAAe,WACf,GAAG,eAAe,IAAI,QAAQ,CAAC,CAAC,KAAK,eAAe,IAAI,QAAQ,CAAC,CAAC;AAE7D,eAAA;AAAA,UACL,KAAK,eAAe;AAAA,UACpB,KAAK,eAAe;AAAA,UACpB;AAAA,UACA,WAAW,eAAe;AAAA,UAC1B,YACE,cAAc,WAAW,WACrB,uBACA;AAAA,QACR;AAAA,MAAA;AAAA,IACF;AAGK,WAAA;AAAA,WACA,OAAO;AACd,YAAQ,KAAK,8BAA8B,UAAU,KAAK,MAAM,OAAO;AAChE,WAAA;AAAA,EAAA;AAEX;AAYA,eAAeC,uBAA8C;AACvD,MAAA;AACI,UAAA,aAAa,IAAI,gBAAgB;AACvC,UAAM,UAAU,WAAW,MAAM,WAAW,MAAA,GAAS,IAAK;AAEpD,UAAA,WAAW,MAAM,MAAML,oBAAkB;AAAA,MAC7C,QAAQ,WAAW;AAAA,MACnB,SAAS,EAAE,QAAQ,mBAAmB;AAAA,IAAA,CACvC;AAED,iBAAa,OAAO;AAEhB,QAAA,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,QAAQ,SAAS,MAAM,EAAE;AAAA,IAAA;AAGrC,UAAA,OAAO,MAAM,SAAS,KAAK;AACjC,WAAO,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC;AAAA,WAC9B,OAAO;AACN,YAAA,MAAM,8BAA8B,KAAK;AACjD,WAAO,CAAC;AAAA,EAAA;AAEZ;AAEA,eAAeM,4BACb,MACA,OACmB;AACnB,QAAM,SAAS,KAAK;AAGpB,MAAI,eAAe;AACf,MAAA;AACc,mBAAA,MAAM,QAAQ,KAAK;AAAA,MACjC,0BAA0B,MAAM;AAAA,MAChC,IAAI;AAAA,QAAQ,CAAC,GAAG,WACd,WAAW,MAAM,OAAO,IAAI,MAAM,SAAS,CAAC,GAAG,GAAI;AAAA,MAAA;AAAA,IACrD,CACD;AAAA,WACM,OAAO;AAEC,mBAAA;AAAA,EAAA;AAIb,MAAA,CAACJ,mBAAiB,MAAM,GAAG;AAC7BA,uBAAiB,MAAM,IAAI;AAAA,MACzB,QAAQ,UAAU,IAAI,YAAY,UAAU,IAAI,aAAa;AAAA,MAC7D,UAAU,gBAAgB;AAAA,QACxB,KAAK,WAAW,KAAK,WAAW,OAAO;AAAA;AAAA,QACvC,KAAK,UAAU,KAAK,WAAW,OAAO;AAAA,QACtC,SAAS,YAAY,QAAQ,CAAC;AAAA,QAC9B,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAAA,MACA,YAAY,cAAc,cAAc;AAAA,MACxC,aACE,UAAU,IACN,mBACA,UAAU,IACR,2BACA;AAAA,IACV;AAAA,aACS,cAAc;AACNA,uBAAA,MAAM,EAAE,WAAW;AAAA,MAClC,KAAK,aAAa;AAAA,MAClB,KAAK,aAAa;AAAA,MAClB,SAAS,aAAa;AAAA,MACtB,WAAW,aAAa;AAAA,IAC1B;AACiBA,uBAAA,MAAM,EAAE,aAAa,aAAa;AAAA,EAAA;AAG/C,QAAA,SAASA,mBAAiB,MAAM;AAE/B,SAAA;AAAA,IACL,IAAI;AAAA,IACJ,MAAM,KAAK;AAAA,IACX,OAAO,KAAK;AAAA,IACZ,OAAO,KAAK;AAAA,IACZ,QAAQ,OAAO;AAAA,IACf,UAAU,OAAO;AAAA,IACjB,YAAY,OAAO;AAAA,IACnB,aAAa,OAAO;AAAA,IACpB,UAAU,UAAU,OAAO,MAAM,EAAE,CAAC;AAAA,IACpC,aAAa,KAAK;AAAA,IAClB,YAAY,KAAK;AAAA,IACjB,aAAa,KAAK,YAAY,CAAC,GAAG;AAAA,IAClC,UAAU,KAAK,QAAQ;AAAA,EACzB;AACF;AAGa,MAAA,eAA+B,OAAO,KAAK,QAAQ;AAC1D,MAAA;AACE,QAAA,IAAI,MAAM,eAAe,QAAQ;AACnCA,2BAAmB,CAAC;AACpBC,qBAAa,MAAM;AAAA,IAAA;AAGf,UAAA,gBAAgB,MAAME,qBAAmB;AAC3C,QAAA,cAAc,SAAS,GAAG;AACtB,YAAA,YAAY,MAAM,QAAQ;AAAA,QAC9B,cAAc;AAAA,UAAI,CAAC,MAAM,UACvBC,4BAA0B,MAAM,KAAK;AAAA,QAAA;AAAA,MAEzC;AAGI,UAAA;AACF,cAAM,QAAQ;AAAA,UACZ,UAAU;AAAA,YAAI,CAAC,aACbF,SAAc,iBAAiB,EAAE,IAAI,SAAS,GAAG,GAAG,UAAU;AAAA,cAC5D,QAAQ;AAAA,cACR,KAAK;AAAA,YACN,CAAA;AAAA,UAAA;AAAA,QAEL;AAAA,eACO,SAAS;AACR,gBAAA,KAAK,wBAAwB,OAAO;AAAA,MAAA;AAG9C,aAAO,IAAI,KAAK,EAAE,WAAW,OAAO,UAAU,QAAQ;AAAA,IAAA;AAIpD,QAAA;AACF,YAAM,iBAAiB,MAAMA,SAAc,KAAK,CAAE,CAAA,EAAE,KAAK;AACzD,aAAO,IAAI,KAAK;AAAA,QACd,WAAW;AAAA,QACX,OAAO,eAAe;AAAA,MAAA,CACvB;AAAA,aACM,SAAS;AACR,cAAA,KAAK,4BAA4B,OAAO;AACzC,aAAA,IAAI,KAAK,EAAE,WAAW,CAAA,GAAI,OAAO,GAAG;AAAA,IAAA;AAAA,WAEtC,OAAO;AACN,YAAA,MAAM,0BAA0B,KAAK;AAC7C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,6BAA6B;AAAA,EAAA;AAE/D;AAEa,MAAA,cAA8B,OAAO,KAAK,QAAQ;AACzD,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACb,UAAA,gBAAgB,MAAMC,qBAAmB;AAE3C,QAAA,cAAc,SAAS,GAAG;AAC5B,YAAM,OAAO,cAAc,KAAK,CAAC,MAAM,EAAE,QAAQ,EAAE;AACnD,UAAI,MAAM;AACR,cAAM,WAAW,MAAMC;AAAAA,UACrB;AAAA,UACA,cAAc,QAAQ,IAAI;AAAA,QAC5B;AAEI,YAAA;AACF,gBAAMF,SAAc,iBAAiB,EAAE,GAAA,GAAM,UAAU;AAAA,YACrD,QAAQ;AAAA,YACR,KAAK;AAAA,UAAA,CACN;AAAA,iBACM,SAAS;AACR,kBAAA,KAAK,0BAA0B,OAAO;AAAA,QAAA;AAGzC,eAAA,IAAI,KAAK,QAAQ;AAAA,MAAA;AAAA,IAC1B;AAIE,QAAA;AACI,YAAA,WAAW,MAAMA,SAAc,QAAQ,EAAE,GAAG,CAAC,EAAE,KAAK;AAC1D,UAAI,SAAU,QAAO,IAAI,KAAK,QAAQ;AAAA,aAC/B,SAAS;AACR,cAAA,KAAK,yBAAyB,OAAO;AAAA,IAAA;AAGxC,WAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,sBAAsB;AAAA,WACpD,OAAO;AACN,YAAA,MAAM,0BAA0B,KAAK;AAC7C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,EAAA;AAE9D;AAEa,MAAA,yBAAyC,OAAO,KAAK,QAAQ;AACpE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,EAAE,KAAK,IAAI,IAAI,IAAI;AAGzB,UAAM,UAAU,MAAM,0BAA0B,KAAK,GAAG;AAExD,UAAM,iBAAiB;AAAA,MACrB,UAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAAA,MACA,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV;AAGI,QAAA;AACI,YAAA,kBAAkB,MAAMA,SAAc;AAAA,QAC1C,EAAE,GAAG;AAAA,QACL,EAAE,MAAM,eAAe;AAAA,QACvB,EAAE,KAAK,KAAK;AAAA,MACd;AAEA,UAAI,iBAAiB;AACnB,eAAO,IAAI,KAAK,EAAE,SAAS,MAAM,UAAU,iBAAiB;AAAA,MAAA;AAAA,aAEvD,SAAS;AACR,cAAA,KAAK,0BAA0B,OAAO;AAAA,IAAA;AAI1C,UAAA,gBAAgB,MAAMC,qBAAmB;AAC/C,UAAM,YAAY,cAAc,UAAU,CAAC,SAAS,KAAK,QAAQ,EAAE;AAEnE,QAAI,cAAc,IAAI;AACb,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,sBAAsB;AAAA,IAAA;AAG7DH,uBAAiB,EAAE,IAAIA,mBAAiB,EAAE,IACtC,EAAE,GAAGA,mBAAiB,EAAE,GAAG,GAAG,eAAA,IAC9B,EAAE,GAAG,gBAAgB,QAAQ,UAAU,aAAa,OAAU;AAElE,UAAM,WAAW,MAAMI;AAAAA,MACrB,cAAc,SAAS;AAAA,MACvB;AAAA,IACF;AACA,QAAI,KAAK,EAAE,SAAS,MAAM,UAAU;AAAA,WAC7B,OAAO;AACN,YAAA,MAAM,4BAA4B,KAAK;AAC/C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,6BAA6B;AAAA,EAAA;AAE/D;AAEa,MAAA,uBAAuC,OAAO,KAAK,QAAQ;AAClE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,EAAE,QAAQ,YAAY,IAAI,IAAI;AACpC,UAAM,SAAS,EAAE,QAAQ,aAAa,YAAY,WAAW;AAEzD,QAAA;AACIC,YAAAA,YAAW,MAAMH,SAAc;AAAA,QACnC,EAAE,GAAG;AAAA,QACL,EAAE,MAAM,OAAO;AAAA,QACf,EAAE,KAAK,KAAK;AAAA,MACd;AAEA,UAAIG,UAAU,QAAO,IAAI,KAAKA,SAAQ;AAAA,aAC/B,SAAS;AACR,cAAA,KAAK,0BAA0B,OAAO;AAAA,IAAA;AAI1C,UAAA,gBAAgB,MAAMF,qBAAmB;AAC/C,UAAM,OAAO,cAAc,KAAK,CAAC,MAAM,EAAE,QAAQ,EAAE;AAE/C,QAAA,CAAC,KAAM,QAAO,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,sBAAsB;AAElE,QAAA,CAACH,mBAAiB,EAAE,GAAG;AACnB,YAAA,WAAW,MAAM,0BAA0B,EAAE;AACnDA,yBAAiB,EAAE,IAAI;AAAA,QACrB,QAAQ;AAAA,QACR,UAAU,YAAY;AAAA,UACpB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,SAAS;AAAA,UACT,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QACpC;AAAA,QACA,YAAY,UAAU,cAAc;AAAA,MACtC;AAAA,IAAA;AAGeA,uBAAA,EAAE,IAAI,EAAE,GAAGA,mBAAiB,EAAE,GAAG,GAAG,OAAO;AAC5D,UAAM,WAAW,MAAMI;AAAAA,MACrB;AAAA,MACA,cAAc,QAAQ,IAAI;AAAA,IAC5B;AACA,QAAI,KAAK,QAAQ;AAAA,WACV,OAAO;AACN,YAAA,MAAM,yBAAyB,KAAK;AAC5C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,2BAA2B;AAAA,EAAA;AAE7D;AAEa,MAAA,qBAAqC,OAAO,KAAK,QAAQ;AAChE,MAAA;AACFJ,yBAAmB,CAAC;AACpBC,mBAAa,MAAM;AACnB,QAAI,KAAK,EAAE,SAAS,MAAM,SAAS,8BAA8B;AAAA,WAC1D,OAAO;AACN,YAAA,MAAM,uBAAuB,KAAK;AAC1C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,yBAAyB;AAAA,EAAA;AAE3D;AAEa,MAAA,2BAA2C,OAAO,KAAK,QAAQ;AACtE,MAAA;AACFD,yBAAmB,CAAC;AACd,UAAA,gBAAgB,MAAMG,qBAAmB;AACzC,UAAA,YAAY,MAAM,QAAQ;AAAA,MAC9B,cAAc;AAAA,QAAI,CAAC,MAAM,UACvBC,4BAA0B,MAAM,KAAK;AAAA,MAAA;AAAA,IAEzC;AAEI,QAAA;AACF,YAAM,QAAQ;AAAA,QACZ,UAAU;AAAA,UAAI,CAAC,aACbF,SAAc,iBAAiB,EAAE,IAAI,SAAS,GAAG,GAAG,UAAU;AAAA,YAC5D,QAAQ;AAAA,YACR,KAAK;AAAA,UACN,CAAA;AAAA,QAAA;AAAA,MAEL;AAAA,aACO,SAAS;AACR,cAAA,KAAK,wBAAwB,OAAO;AAAA,IAAA;AAG9C,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,SAAS,aAAa,UAAU,MAAM;AAAA,MACtC;AAAA,IAAA,CACD;AAAA,WACM,OAAO;AACN,YAAA,MAAM,mBAAmB,KAAK;AACtC,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,+BAA+B;AAAA,EAAA;AAEjE;AAGO,MAAM,iBAAiC,CAAC,KAAK,QAClD,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gCAAA,CAAiC;AAE1D,MAAM,iBAAiC,CAAC,KAAK,QAClD,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,+BAAA,CAAgC;AAEzD,MAAM,iBAAiC,CAAC,KAAK,QAClD,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gCAAA,CAAiC;AC9hBjE,MAAMD,iBAAe,IAAI,UAAU,EAAE,QAAQ,MAAM,aAAa,KAAK;AAIrE,IAAIK,sBAAoB;AACxB,MAAMC,oBAAkB;AAExB,eAAeC,iBAAe,KAAa,KAA8B;AACvE,MAAI,QAAQ,KAAK,QAAQ,EAAU,QAAA;AAE7B,QAAA,WAAW,GAAG,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC;AAC9C,QAAA,gBAAgBP,eAAa,IAAY,QAAQ;AACvD,MAAI,eAAe;AACjB,YAAQ,IAAI,8BAA8B,GAAG,KAAK,GAAG,KAAK,aAAa,EAAE;AAClE,WAAA;AAAA,EAAA;AAGL,MAAA;AAEI,UAAA,MAAM,KAAK,IAAI;AACrB,UAAM,uBAAuB,MAAMK;AACnC,QAAI,uBAAuBC,mBAAiB;AAC1C,YAAM,WAAWA,oBAAkB;AAC3B,cAAA,IAAI,4BAA4B,QAAQ,qBAAqB;AACrE,YAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,QAAQ,CAAC;AAAA,IAAA;AAE5DD,0BAAoB,KAAK,IAAI;AAE7B,YAAQ,IAAI,yCAAyC,GAAG,KAAK,GAAG,EAAE;AAClE,UAAM,WAAW,MAAM,MAAM,IAAI,+CAA+C;AAAA,MAC9E,QAAQ;AAAA,QACN,QAAQ;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL,MAAM;AAAA,QACN,gBAAgB;AAAA,MAClB;AAAA,MACA,SAAS;AAAA,QACP,cAAc;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,IAAA,CACV;AAED,UAAM,UAAU,SAAS,MAAM,gBAAgB,GAAG,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC;AAC3E,YAAA,IAAI,uBAAuB,OAAO,EAAE;AAC/BL,mBAAA,IAAI,UAAU,OAAO;AAC3B,WAAA;AAAA,WACA,OAAO;AACd,YAAQ,MAAM,mCAAmC,GAAG,KAAK,GAAG,KAAK,MAAM,OAAO;AACvE,WAAA,GAAG,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC;AAAA,EAAA;AAE/C;AAGA,eAAe,2BAA2B,SAAwC;AAChF,QAAM,WAAW,QAAQ;AACzB,QAAM,UAAU,MAAMO,iBAAe,SAAS,KAAK,SAAS,GAAG;AAExD,SAAA;AAAA,IACL,IAAI,QAAQ,IAAI,SAAS;AAAA,IACzB,YAAY,QAAQ;AAAA,IACpB,UAAU;AAAA,MACR,GAAG;AAAA,MACH;AAAA;AAAA,IACF;AAAA,IACA,WAAW,QAAQ;AAAA,IACnB,SAAS,QAAQ;AAAA,IACjB,YAAY,QAAQ;AAAA,IACpB,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,IAChB,mBAAmB,QAAQ;AAAA,IAC3B,QAAQ,QAAQ;AAAA,IAChB,UAAU,QAAQ;AAAA,IAClB,YAAY,QAAQ;AAAA;AAAA,IACpB,gBAAgB,QAAQ;AAAA,IACxB,gBAAgB,QAAQ;AAAA;AAAA,IACxB,gBAAgB,QAAQ;AAAA;AAAA,EAC1B;AACF;AAGA,IAAI,mBAAiC,CAAC;AAKzB,MAAA,cAA8B,OAAO,KAAK,QAAQ;AACzD,MAAA;AACI,UAAA,EAAE,YAAY,QAAQ,WAAW,SAAS,QAAQ,OAAO,IAAI;AAGnE,UAAM,QAAa,CAAC;AAChB,QAAA,kBAAkB,aAAa;AAC/B,QAAA,cAAc,SAAS;AAE3B,QAAI,aAAa,SAAS;AACxB,YAAM,YAAY,CAAC;AACnB,UAAI,UAAiB,OAAA,UAAU,OAAO,IAAI,KAAK,SAAmB;AAClE,UAAI,QAAe,OAAA,UAAU,OAAO,IAAI,KAAK,OAAiB;AAAA,IAAA;AAGhE,YAAQ,IAAI,oCAAoC,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAG1E,QAAA;AAEF,UAAI,YAAY;AACd,cAAM,aAAa,MAAM,QAAQ,eAAe,EAAE,YAAY;AAC9D,gBAAQ,IAAI,wCAAwC,UAAU,KAAK,UAAU;AAAA,MAAA;AAG/E,YAAM,gBAAgB,MAAM,QAAQ,KAAK,KAAK,EAC3C,KAAK,EAAE,WAAW,GAAA,CAAI,EACtB,MAAM,SAAS,KAAe,CAAC,EAC/B,KAAK;AAGF,YAAA,cAAc,MAAM,QAAQ;AAAA,QAChC,cAAc,IAAI,CAAW,YAAA,2BAA2B,OAAO,CAAC;AAAA,MAClE;AAEA,YAAMC,YAAgC;AAAA,QACpC,UAAU;AAAA,QACV,OAAO,YAAY;AAAA,MACrB;AAEQ,cAAA;AAAA,QAAI,WAAW,YAAY,MAAM;AAAA,QACvC,YAAY,IAAI,CAAA,OAAM,EAAE,IAAI,EAAE,IAAI,QAAQ,EAAE,QAAQ,YAAY,EAAE,YAAY,QAAQ,EAAE,aAAa;AAAA,MACvG;AAGI,UAAA,YAAY,WAAW,KAAK,YAAY;AAC1C,gBAAQ,KAAK,0DAA0D;AACjEC,cAAAA,eAAc,MAAM,QAAQ,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK;AACpD,gBAAA;AAAA,UAAI;AAAA,UACVA,aAAY,IAAI,CAAM,OAAA,EAAE,IAAI,EAAE,KAAK,QAAQ,EAAE,QAAQ,YAAY,EAAE,aAAa;AAAA,QAClF;AAAA,MAAA;AAGF,UAAI,KAAKD,SAAQ;AACjB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,QAAI,mBAAmB;AAEvB,QAAI,YAAY;AACd,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,QAAQ,eAAe;AAAA,MACtC;AAAA,IAAA;AAGF,QAAI,QAAQ;AACV,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,QAAQ,WAAW;AAAA,MAClC;AAAA,IAAA;AAGF,QAAI,WAAW;AACb,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,IAAI,KAAK,QAAQ,SAAS,KAAK,IAAI,KAAK,SAAmB;AAAA,MAC1E;AAAA,IAAA;AAGF,QAAI,SAAS;AACX,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,IAAI,KAAK,QAAQ,SAAS,KAAK,IAAI,KAAK,OAAiB;AAAA,MACxE;AAAA,IAAA;AAGe,qBAAA;AAAA,MACf,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,SAAS,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,IAC5E;AAEA,QAAI,OAAO;AACT,yBAAmB,iBAAiB,MAAM,GAAG,SAAS,KAAe,CAAC;AAAA,IAAA;AAGxE,UAAM,WAAgC;AAAA,MACpC,UAAU;AAAA,MACV,OAAO,iBAAiB;AAAA,IAC1B;AAEA,YAAQ,IAAI,SAAS,iBAAiB,MAAM,qBAAqB;AACjE,QAAI,KAAK,QAAQ;AAAA,WACV,OAAO;AACN,YAAA,MAAM,4BAA4B,KAAK;AAC/C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,EAAA;AAE9D;AAEa,MAAA,aAA6B,OAAO,KAAK,QAAQ;AACxD,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AAGf,QAAA;AACF,YAAME,WAAU,MAAM,QAAQ,SAAS,EAAE,EAAE,KAAK;AAChD,UAAI,CAACA,UAAS;AACL,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,iCAAiC;AAAA,MAAA;AAGlE,YAAA,aAAa,MAAM,2BAA2BA,QAAO;AACnD,cAAA,IAAI,6BAA6BA,SAAQ,GAAG;AACpD,UAAI,KAAK,UAAU;AACnB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,UAAM,UAAU,iBAAiB,KAAK,CAACA,aAAYA,SAAQ,OAAO,EAAE;AAEpE,QAAI,CAAC,SAAS;AACL,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qBAAqB;AAAA,IAAA;AAGpD,YAAA,IAAI,4BAA4B,QAAQ,EAAE;AAClD,QAAI,KAAK,OAAO;AAAA,WACT,OAAO;AACN,YAAA,MAAM,2BAA2B,KAAK;AAC9C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,2BAA2B;AAAA,EAAA;AAE7D;AAEa,MAAA,gBAAgC,OAAO,KAAK,QAAQ;AAC3D,MAAA;AACI,UAAA,EAAE,YAAY,UAAU,YAAY,OAAO,QAAQ,UAAU,YAAY,sBAAsB,IAAI,IAAI;AAEzG,QAAA,CAAC,cAAc,CAAC,UAAU;AACrB,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,yCAAyC;AAAA,IAAA;AAIhF,UAAM,UAAU,MAAMH,iBAAe,SAAS,KAAK,SAAS,GAAG;AAE/D,UAAM,cAAc;AAAA,MAClB;AAAA,MACA,UAAU;AAAA,QACR,GAAG;AAAA,QACH;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR,QAAQ,UAAU;AAAA,MAClB,UAAU,YAAY;AAAA,MACtB,YAAY,cAAc;AAAA;AAAA,MAC1B,uBAAuB,yBAAyB;AAAA;AAAA,IAClD;AAGI,QAAA;AACI,YAAA,aAAa,IAAI,QAAQ,WAAW;AACpC,YAAA,eAAe,MAAM,WAAW,KAAK;AACrCI,YAAAA,cAAa,MAAM,2BAA2B,YAAY;AAEhE,cAAQ,IAAI,+BAA+B;AAAA,QACzC,IAAI,aAAa;AAAA,QACjB,YAAY,aAAa;AAAA,QACzB,YAAY,aAAa;AAAA,QACzB,QAAQ,aAAa;AAAA,QACrB,YAAY,aAAa;AAAA,MAAA,CAC1B;AAGG,UAAA;AACF,cAAM,eAAe,MAAM,QAAQ,SAAS,aAAa,GAAG;AAC5D,YAAI,cAAc;AAChB,kBAAQ,IAAI,wCAAwC;AAC5C,kBAAA,IAAI,0BAA0B,aAAa,UAAU;AACrD,kBAAA,IAAI,sBAAsB,aAAa,MAAM;AAGrD,cAAI,aAAa,YAAY;AACrB,kBAAA,eAAe,MAAM,QAAQ,QAAQ;AAAA,cACzC,YAAY,aAAa;AAAA,cACzB,QAAQ,EAAE,KAAK,CAAC,eAAe,SAAS,EAAE;AAAA,YAAA,CAC3C;AACD,gBAAI,cAAc;AAChB,sBAAQ,IAAI,4CAA4C;AAAA,YAAA,OACnD;AACL,sBAAQ,MAAM,2DAA2D;AAAA,YAAA;AAAA,UAC3E;AAAA,QACF,OACK;AACL,kBAAQ,MAAM,sDAAsD;AAAA,QAAA;AAAA,eAE/D,aAAa;AACZ,gBAAA,MAAM,yBAAyB,WAAW;AAAA,MAAA;AAGpD,UAAI,OAAO,GAAG,EAAE,KAAKA,WAAU;AAC/B;AAAA,aACO,SAAS;AACR,cAAA,KAAK,2DAA2D,OAAO;AAAA,IAAA;AAIjF,UAAM,YAAY,WAAW,KAAK,IAAA,CAAK,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAClF,UAAM,aAAyB;AAAA,MAC7B,IAAI;AAAA,MACJ,YAAY,YAAY;AAAA,MACxB,UAAU,YAAY;AAAA,MACtB,WAAW,YAAY;AAAA,MACvB,YAAY,YAAY;AAAA,MACxB,OAAO,YAAY;AAAA,MACnB,QAAQ,YAAY;AAAA,MACpB,QAAQ,YAAY;AAAA,MACpB,UAAU,YAAY;AAAA,IACxB;AAEA,qBAAiB,KAAK,UAAU;AAExB,YAAA,IAAI,4BAA4B,SAAS;AACjD,QAAI,OAAO,GAAG,EAAE,KAAK,UAAU;AAAA,WACxB,OAAO;AACN,YAAA,MAAM,2BAA2B,KAAK;AAC9C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,EAAA;AAE9D;AAEa,MAAA,gBAAgC,OAAO,KAAK,QAAQ;AAC3D,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,UAAU,IAAI;AAEpB,YAAQ,IAAI,uBAAuB,EAAE,iBAAiB,QAAQ,MAAM,EAAE;AAC9D,YAAA,IAAI,+BAA+B,QAAQ,WAAW;AAG9D,QAAI,QAAQ,WAAW,eAAe,CAAC,QAAQ,SAAS;AACtD,cAAQ,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,IAAA;AAI3C,QAAI,QAAQ,kBAAkB,CAAC,QAAQ,eAAe,YAAY,QAAQ;AACjE,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,IAAA;AAI1E,QAAI,QAAQ,WAAW,eAAe,QAAQ,aAAa;AACjD,cAAA,IAAI,0CAA0C,KAAK,UAAU,QAAQ,aAAa,MAAM,CAAC,CAAC;AAElG,cAAQ,sBAAsB,IAAI;AAAA,QAChC,KAAK,QAAQ,YAAY;AAAA,QACzB,KAAK,QAAQ,YAAY;AAAA,QACzB,SAAS,QAAQ,YAAY,WAAW,GAAG,QAAQ,YAAY,IAAI,QAAQ,CAAC,CAAC,KAAK,QAAQ,YAAY,IAAI,QAAQ,CAAC,CAAC;AAAA,QACpH,WAAW,QAAQ,YAAY,cAAiB,oBAAA,KAAA,GAAO,YAAY;AAAA,MACrE;AACQ,cAAA,IAAI,6BAA6B,KAAK,UAAU,QAAQ,sBAAsB,GAAG,MAAM,CAAC,CAAC;AAEjG,aAAO,QAAQ;AAAA,IAAA,WACN,QAAQ,WAAW,aAAa;AACzC,cAAQ,KAAK,8DAA8D;AAAA,IAAA;AAIzE,QAAA;AACI,YAAA,iBAAiB,MAAM,QAAQ;AAAA,QACnC;AAAA,QACA,EAAE,MAAM,QAAQ;AAAA,QAChB,EAAE,KAAK,MAAM,eAAe,KAAK;AAAA,MACnC;AAEA,UAAI,CAAC,gBAAgB;AACZ,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,iCAAiC;AAAA,MAAA;AAGhE,cAAA,IAAI,+BAA+B,eAAe,GAAG;AACzD,UAAA,eAAe,UAAU,aAAa;AACxC,gBAAQ,IAAI,yBAAyB,eAAe,SAAS,WAAW;AAAA,MAAA;AAGpE,YAAA,aAAa,MAAM,2BAA2B,cAAc;AAClE,UAAI,KAAK,UAAU;AACnB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AAAA,IAAA;AAInF,UAAM,eAAe,iBAAiB,UAAU,CAAC,YAAY,QAAQ,OAAO,EAAE;AAC9E,QAAI,iBAAiB,IAAI;AAChB,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qBAAqB;AAAA,IAAA;AAG5D,qBAAiB,YAAY,IAAI;AAAA,MAC/B,GAAG,iBAAiB,YAAY;AAAA,MAChC,GAAG;AAAA,IACL;AAEQ,YAAA,IAAI,8BAA8B,EAAE;AACxC,QAAA,KAAK,iBAAiB,YAAY,CAAC;AAAA,WAChC,OAAO;AACN,YAAA,MAAM,2BAA2B,KAAK;AAC9C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,EAAA;AAE9D;AAEa,MAAA,gBAAgC,OAAO,KAAK,QAAQ;AAC3D,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AAGf,QAAA;AACF,YAAM,iBAAiB,MAAM,QAAQ,kBAAkB,EAAE;AACzD,UAAI,CAAC,gBAAgB;AACZ,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qBAAqB;AAAA,MAAA;AAGxD,UAAA,OAAO,GAAG,EAAE,KAAK;AACrB;AAAA,aACO,SAAS;AACR,cAAA,MAAM,0BAA0B,OAAO;AACzC,YAAA;AAAA,IAAA;AAAA,WAED,OAAO;AACN,YAAA,MAAM,2BAA2B,KAAK;AAC9C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,EAAA;AAE9D;AAGa,MAAA,mBAAmC,OAAO,KAAK,QAAQ;AAC9D,MAAA;AACF,UAAM,EAAE,YAAY,WAAW,IAAI,IAAI;AAEnC,QAAA,CAAC,cAAc,CAAC,YAAY;AAC9B,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGH,YAAQ,IAAI,oCAAoC,EAAE,YAAY,YAAY;AAGtE,QAAA;AAEF,YAAM,QAAa;AAAA,QACjB,QAAQ,EAAE,KAAK,CAAC,eAAe,SAAS,EAAE;AAAA,MAC5C;AAEA,UAAI,YAAY;AAEd,cAAM,aAAa;AAAA,iBACV,YAAY;AAErB,cAAM,aAAa;AAAA,MAAA;AAGrB,cAAQ,IAAI,aAAa,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAEvD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,KAAK,EAC9C,KAAK,EAAE,WAAW,GAAI,CAAA,EACtB,KAAK;AAER,UAAI,CAAC,eAAe;AAClB,gBAAQ,IAAI,0CAA0C,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAGpF,YAAI,YAAY;AACRF,gBAAAA,eAAc,MAAM,QAAQ,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK;AAC5D,kBAAQ,IAAI,iCAAiCA,aAAY,IAAI,CAAM,OAAA;AAAA,YACjE,IAAI,EAAE;AAAA,YACN,QAAQ,EAAE;AAAA,YACV,YAAY,EAAE;AAAA,YACd,WAAW,EAAE;AAAA,YACb,CAAC;AAAA,QAAA;AAIC,cAAA,oBAAoB,MAAM,QAAQ,KAAK;AAAA,UAC3C,QAAQ,EAAE,KAAK,CAAC,eAAe,SAAS,EAAE;AAAA,QAC3C,CAAA,EAAE,KAAK;AACR,gBAAQ,IAAI,uCAAuC,kBAAkB,IAAI,CAAM,OAAA;AAAA,UAC7E,IAAI,EAAE;AAAA,UACN,YAAY,EAAE;AAAA,UACd,YAAY,EAAE;AAAA,UACd,QAAQ,EAAE;AAAA,UACV,CAAC;AAEH,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,UACP;AAAA,UACA;AAAA,UACA,OAAO;AAAA,YACL,0BAA0B,aAAa,UAAU;AAAA,YACjD,qBAAqB,mBAAmB,UAAU;AAAA,UAAA;AAAA,QACpD,CACD;AAAA,MAAA;AAGG,YAAA,aAAa,MAAM,2BAA2B,aAAa;AACjE,cAAQ,IAAI,2BAA2B;AAAA,QACrC,IAAI,WAAW;AAAA,QACf,YAAY,WAAW;AAAA,QACvB,QAAQ,WAAW;AAAA,QACnB,QAAQ,WAAW;AAAA,MAAA,CACpB;AAED,UAAI,KAAK,UAAU;AACnB;AAAA,aACO,SAAS;AACR,cAAA,MAAM,yBAAyB,OAAO;AACvC,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,yBAAyB;AAAA,IAAA;AAAA,WAEzD,OAAO;AACN,YAAA,MAAM,iCAAiC,KAAK;AACpD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gCAAgC;AAAA,EAAA;AAElE;AAca,MAAA,wBAAwC,OAAO,KAAK,QAAQ;AACnE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,EAAE,gBAAgB,eAAe,IAAI,IAAI;AAG3C,QAAA,CAAC,kBAAkB,CAAC,CAAC,MAAM,QAAQ,EAAE,SAAS,cAAc,GAAG;AAC1D,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,iDAAiD;AAAA,IAAA;AAGxF,QAAI,CAAC,kBAAkB,CAAC,eAAe,QAAQ;AACtC,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,+BAA+B;AAAA,IAAA;AAGtE,YAAQ,IAAI,gCAAgC,EAAE,KAAK,EAAE,gBAAgB,gBAAgB;AAEjF,QAAA;AACI,YAAA,iBAAiB,MAAM,QAAQ;AAAA,QACnC;AAAA,QACA;AAAA,UACE,MAAM;AAAA,YACJ;AAAA,YACA,gBAAgB,eAAe,KAAK;AAAA,UAAA;AAAA,QAExC;AAAA,QACA,EAAE,KAAK,MAAM,eAAe,KAAK;AAAA,MACnC;AAEA,UAAI,CAAC,gBAAgB;AACZ,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qBAAqB;AAAA,MAAA;AAGpD,cAAA,IAAI,+BAA+B,eAAe,GAAG;AAEvD,YAAA,aAAa,MAAM,2BAA2B,cAAc;AAClE,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,SAAS;AAAA,QACT,gBAAgB,eAAe;AAAA,QAC/B,gBAAgB,eAAe;AAAA,MAAA,CAChC;AAAA,aACM,SAAS;AACR,cAAA,MAAM,0BAA0B,OAAO;AAC/C,UAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,IAAA;AAAA,WAE9D,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;AAGa,MAAA,iCAAiD,OAAO,KAAK,QAAQ;AAC5E,MAAA;AACI,UAAA,EAAE,YAAY,MAAM,aAAa,eAAe,gBAAgB,mBAAmB,IAAI;AAG7F,QAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,eAAe,CAAC,eAAe;AACnD,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,kEAAkE;AAAA,IAAA;AAGrG,QAAA,CAAC,kBAAkB,CAAC,CAAC,MAAM,QAAQ,EAAE,SAAS,cAAc,GAAG;AAC1D,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,iDAAiD;AAAA,IAAA;AAGxF,QAAI,CAAC,kBAAkB,CAAC,eAAe,QAAQ;AACtC,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,+BAA+B;AAAA,IAAA;AAGtE,YAAQ,IAAI,4CAA4C;AAAA,MACtD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAEG,QAAA;AAEI,YAAA,iBAAiB,IAAI,KAAK,IAAI;AACpC,qBAAe,SAAS,GAAG,GAAG,GAAG,CAAC;AAE5B,YAAA,eAAe,IAAI,KAAK,IAAI;AAClC,mBAAa,SAAS,IAAI,IAAI,IAAI,GAAG;AAG/B,YAAA,UAAU,MAAM,QAAQ,QAAQ;AAAA,QACpC;AAAA,QACA,YAAY;AAAA,QACZ,WAAW;AAAA,UACT,MAAM,eAAe,YAAY;AAAA,UACjC,MAAM,aAAa,YAAY;AAAA,QAAA;AAAA,MAElC,CAAA,EAAE,KAAK;AAER,UAAI,CAAC,SAAS;AACZ,gBAAQ,MAAM,qCAAqC,EAAE,YAAY,MAAM,aAAa;AACpF,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,UACP,SAAS,EAAE,YAAY,MAAM,aAAa,cAAc;AAAA,QAAA,CACzD;AAAA,MAAA;AAGH,cAAQ,IAAI,+BAA+B,QAAQ,GAAG,EAAE;AAGlD,YAAA,iBAAiB,MAAM,QAAQ;AAAA,QACnC,QAAQ;AAAA,QACR;AAAA,UACE,MAAM;AAAA,YACJ;AAAA,YACA,gBAAgB,eAAe,KAAK;AAAA,UAAA;AAAA,QAExC;AAAA,QACA,EAAE,KAAK,MAAM,eAAe,KAAK;AAAA,MACnC;AAEA,UAAI,CAAC,gBAAgB;AACZ,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,MAAA;AAG3D,cAAA,IAAI,0CAA0C,eAAe,GAAG;AAElE,YAAA,aAAa,MAAM,2BAA2B,cAAc;AAClE,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,SAAS;AAAA,QACT,gBAAgB,eAAe;AAAA,QAC/B,gBAAgB,eAAe;AAAA,MAAA,CAChC;AAAA,aACM,SAAS;AACR,cAAA,MAAM,0BAA0B,OAAO;AAC/C,UAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,IAAA;AAAA,WAE9D,OAAO;AACN,YAAA,MAAM,+CAA+C,KAAK;AAClE,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;;;;;;;;;;;;;AC1pBA,IAAI,oBAAoB;AACxB,MAAM,kBAAkB;AACxB,MAAM,mCAAmB,IAAkD;AAC3E,MAAM,eAAe;AAErB,eAAe,eAAe,KAAa,KAA8B;AACvE,MAAI,QAAQ,KAAK,QAAQ,EAAU,QAAA;AAE7B,QAAA,WAAW,GAAG,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC;AAC9C,QAAA,SAAS,aAAa,IAAI,QAAQ;AACxC,MAAI,UAAU,OAAO,UAAU,KAAK,OAAO;AACjC,YAAA,IAAI,8BAA8B,GAAG,KAAK,GAAG,KAAK,OAAO,OAAO,EAAE;AAC1E,WAAO,OAAO;AAAA,EAAA;AAGZ,MAAA;AAEI,UAAA,MAAM,KAAK,IAAI;AACrB,UAAM,uBAAuB,MAAM;AACnC,QAAI,uBAAuB,iBAAiB;AAC1C,YAAM,WAAW,kBAAkB;AAC3B,cAAA,IAAI,4BAA4B,QAAQ,qBAAqB;AACrE,YAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,QAAQ,CAAC;AAAA,IAAA;AAE5D,wBAAoB,KAAK,IAAI;AAE7B,YAAQ,IAAI,yCAAyC,GAAG,KAAK,GAAG,EAAE;AAClE,UAAM,WAAW,MAAM,MAAM,IAAI,+CAA+C;AAAA,MAC9E,QAAQ;AAAA,QACN,QAAQ;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL,MAAM;AAAA,QACN,gBAAgB;AAAA,MAClB;AAAA,MACA,SAAS;AAAA,QACP,cAAc;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,IAAA,CACV;AAED,UAAM,UAAU,SAAS,MAAM,gBAAgB,GAAG,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC;AAC3E,YAAA,IAAI,uBAAuB,OAAO,EAAE;AAE5C,iBAAa,IAAI,UAAU;AAAA,MACzB;AAAA,MACA,SAAS,KAAK,QAAQ;AAAA,IAAA,CACvB;AAEM,WAAA;AAAA,WACA,OAAO;AACd,YAAQ,MAAM,mCAAmC,GAAG,KAAK,GAAG,KAAK,MAAM,OAAO;AACvE,WAAA,GAAG,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC;AAAA,EAAA;AAE/C;AAGA,IAAI,mBAA0C,CAAC;AAC/C,IAAI,mBAAmB;AAGvB,IAAI,iBAQC,CAAC;AACN,IAAI,mBAAmB;AAEV,MAAA,sBAAsC,OAAO,KAAK,QAAQ;AACjE,MAAA;AACI,UAAA,EAAE,YAAY,QAAQ,WAAW,SAAS,QAAQ,OAAO,IAAI;AAGnE,UAAM,QAAa,CAAC;AAEpB,QAAI,YAAY;AACd,YAAM,aAAa;AAAA,IAAA;AAGrB,QAAI,QAAQ;AACV,YAAM,SAAS;AAAA,IAAA;AAGjB,QAAI,aAAa,SAAS;AACxB,YAAM,YAAY,CAAC;AACnB,UAAI,WAAW;AACb,cAAM,UAAU,OAAO,IAAI,KAAK,SAAmB,EAAE,YAAY;AAAA,MAAA;AAEnE,UAAI,SAAS;AACX,cAAM,UAAU,OAAO,IAAI,KAAK,OAAiB,EAAE,YAAY;AAAA,MAAA;AAAA,IACjE;AAGM,YAAA,IAAI,0CAA0C,KAAK;AAGvD,QAAA;AACF,YAAM,gBAAgB,MAAMG,gBAAqB,KAAK,KAAK,EACxD,KAAK,EAAE,WAAW,GAAA,CAAI,EACtB,MAAM,SAAS,KAAe,CAAC,EAC/B,KAAK;AAER,YAAMJ,YAAoC;AAAA,QACxC,UAAU;AAAA,QACV,OAAO,cAAc;AAAA,MACvB;AAEA,cAAQ,IAAI,SAAS,cAAc,MAAM,+BAA+B;AACxE,UAAI,KAAKA,SAAQ;AACjB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,QAAI,mBAAmB;AAEvB,QAAI,YAAY;AACd,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,QAAQ,eAAe;AAAA,MACtC;AAAA,IAAA;AAGF,QAAI,QAAQ;AACV,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,QAAQ,WAAW;AAAA,MAClC;AAAA,IAAA;AAGF,QAAI,WAAW;AACb,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YACC,IAAI,KAAK,QAAQ,SAAS,KAAK,IAAI,KAAK,SAAmB;AAAA,MAC/D;AAAA,IAAA;AAGF,QAAI,SAAS;AACX,yBAAmB,iBAAiB;AAAA,QAClC,CAAC,YAAY,IAAI,KAAK,QAAQ,SAAS,KAAK,IAAI,KAAK,OAAiB;AAAA,MACxE;AAAA,IAAA;AAGe,qBAAA;AAAA,MACf,CAAC,GAAG,MACF,IAAI,KAAK,EAAE,SAAS,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,IACpE;AAEA,QAAI,OAAO;AACT,yBAAmB,iBAAiB,MAAM,GAAG,SAAS,KAAe,CAAC;AAAA,IAAA;AAGxE,UAAM,WAAoC;AAAA,MACxC,UAAU;AAAA,MACV,OAAO,iBAAiB;AAAA,IAC1B;AAEA,YAAQ,IAAI,SAAS,iBAAiB,MAAM,8BAA8B;AAC1E,QAAI,KAAK,QAAQ;AAAA,WACV,OAAO;AACN,YAAA,MAAM,qCAAqC,KAAK;AACxD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;AAEa,MAAA,wBAAwC,OAAO,KAAK,QAAQ;AACnE,MAAA;AACI,UAAA,EAAE,IAAI,YAAY,WAAW,eAAe,OAAO,eAAe,WAAW,IAAI;AAEnF,QAAA,CAAC,cAAc,CAAC,eAAe;AACjC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGH,YAAQ,IAAI,iCAAiC,EAAE,IAAI,YAAY,WAAW;AAGtE,QAAA,wBAAwB,EAAE,GAAG,cAAc;AAC3C,QAAA,cAAc,OAAO,cAAc,KAAK;AACtC,UAAA;AACF,gBAAQ,IAAI,yCAAyC;AACrD,cAAM,UAAU,MAAM,eAAe,cAAc,KAAK,cAAc,GAAG;AACzE,8BAAsB,UAAU;AACxB,gBAAA,IAAI,sCAAsC,OAAO;AAAA,eAClD,OAAO;AACN,gBAAA,KAAK,gDAAgD,KAAK;AAAA,MAAA;AAAA,IAEpE;AAGF,UAAM,cAAc;AAAA,MAClB,IAAI,MAAM,WAAW,OAAO,kBAAkB,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,MAChE;AAAA,MACA,WAAW,cAAiB,oBAAA,KAAA,GAAO,YAAY;AAAA,MAC/C,eAAe;AAAA,QACb,GAAG;AAAA,QACH,WAAW,sBAAsB,cAAiB,oBAAA,QAAO,YAAY;AAAA,MACvE;AAAA,MACA,OAAO,SAAS,CAAC,qBAAqB;AAAA,MACtC,eAAe,iBAAiB;AAAA,MAChC,QAAQ,UAAU;AAAA,IACpB;AAGI,QAAA;AACIK,YAAAA,cAAa,IAAID,gBAAqB,WAAW;AACjD,YAAA,eAAe,MAAMC,YAAW,KAAK;AAEnC,cAAA,IAAI,sCAAsC,aAAa,EAAE;AACjE,UAAI,OAAO,GAAG,EAAE,KAAK,YAAY;AACjC;AAAA,aACO,SAAS;AACR,cAAA,KAAK,2DAA2D,OAAO;AAAA,IAAA;AAIjF,UAAM,aAAa;AACnB,qBAAiB,KAAK,UAAU;AAExB,YAAA,IAAI,qCAAqC,WAAW,EAAE;AAC9D,QAAI,OAAO,GAAG,EAAE,KAAK,UAAU;AAAA,WACxB,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;AAEa,MAAA,wBAAwC,OAAO,KAAK,QAAQ;AACnE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,UAAU,IAAI;AAEZ,YAAA,IAAI,iCAAiC,EAAE;AAC/C,YAAQ,IAAI,eAAe,KAAK,UAAU,SAAS,MAAM,CAAC,CAAC;AAG3D,QAAI,QAAQ,WAAW,eAAe,CAAC,QAAQ,SAAS;AACtD,cAAQ,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,IAAA;AAK3C,QAAI,QAAQ,eAAe,QAAQ,YAAY,OAAO,QAAQ,YAAY,KAAK;AACzE,UAAA;AACF,gBAAQ,IAAI,uCAAuC;AAC7C,cAAA,UAAU,MAAM,eAAe,QAAQ,YAAY,KAAK,QAAQ,YAAY,GAAG;AACrF,gBAAQ,YAAY,UAAU;AACtB,gBAAA,IAAI,oCAAoC,OAAO;AAAA,eAChD,OAAO;AACN,gBAAA,KAAK,8CAA8C,KAAK;AAAA,MAAA;AAAA,IAElE;AAIE,QAAA;AACI,YAAA,iBAAiB,MAAMD,gBAAqB;AAAA,QAChD,EAAE,GAAG;AAAA,QACL,EAAE,MAAM,QAAQ;AAAA,QAChB,EAAE,KAAK,MAAM,eAAe,KAAK;AAAA,MACnC;AAEA,UAAI,CAAC,gBAAgB;AACX,gBAAA,KAAK,8CAA8C,EAAE;AACtD,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,0CAA0C;AAAA,MAAA;AAIjF,UAAI,QAAQ,WAAW,eAAe,eAAe,aAAa,eAAe,SAAS;AACxF,cAAM,YAAY,IAAI,KAAK,eAAe,SAAS,EAAE,QAAQ;AAC7D,cAAM,UAAU,IAAI,KAAK,eAAe,OAAO,EAAE,QAAQ;AACzD,cAAM,WAAW,KAAK,OAAO,UAAU,aAAa,GAAI;AAExD,cAAMA,gBAAqB;AAAA,UACzB,EAAE,GAAG;AAAA,UACL,EAAE,MAAM,EAAE,WAAW;AAAA,UACrB,EAAE,KAAK,KAAK;AAAA,QACd;AACA,uBAAe,WAAW;AAClB,gBAAA,IAAI,0BAA0B,UAAU,SAAS;AAAA,MAAA;AAGnD,cAAA,IAAI,0CAA0C,eAAe,EAAE;AACvE,UAAI,eAAe,aAAa;AACtB,gBAAA,IAAI,yBAAyB,eAAe,WAAW;AAAA,MAAA;AAEjE,UAAI,KAAK,cAAc;AACvB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AAAA,IAAA;AAInF,UAAM,eAAe,iBAAiB;AAAA,MACpC,CAAC,YAAY,QAAQ,OAAO;AAAA,IAC9B;AACA,QAAI,iBAAiB,IAAI;AAChB,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,8BAA8B;AAAA,IAAA;AAIrE,QAAI,QAAQ,WAAW,eAAe,CAAC,iBAAiB,YAAY,EAAE,SAAS;AACvE,YAAA,YAAY,IAAI,KAAK,iBAAiB,YAAY,EAAE,SAAS,EAAE,QAAQ;AAC7E,YAAM,UAAU,IAAI,KAAK,QAAQ,OAAO,EAAE,QAAQ;AAClD,cAAQ,WAAW,KAAK,OAAO,UAAU,aAAa,GAAI;AAAA,IAAA;AAG5D,qBAAiB,YAAY,IAAI;AAAA,MAC/B,GAAG,iBAAiB,YAAY;AAAA,MAChC,GAAG;AAAA,IACL;AAEA,YAAQ,IAAI,uCAAuC,iBAAiB,YAAY,EAAE,EAAE;AAChF,QAAA,KAAK,iBAAiB,YAAY,CAAC;AAAA,WAChC,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;AAEa,MAAA,qBAAqC,OAAO,KAAK,QAAQ;AAChE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACb,UAAA,EAAE,aAAa,IAAI;AAEzB,QAAI,CAAC,UAAU;AACN,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,wBAAwB;AAAA,IAAA;AAI/D,UAAM,wBAAsC;AAAA,MAC1C,GAAG;AAAA,MACH,WAAW,SAAS,cAAiB,oBAAA,QAAO,YAAY;AAAA,IAC1D;AAGI,QAAA;AACF,YAAME,WAAU,MAAMF,gBAAqB,QAAQ,EAAE,IAAI;AACzD,UAAI,CAACE,UAAS;AACL,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,0CAA0C;AAAA,MAAA;AAIjFA,eAAQ,MAAM,KAAK,qBAAqB;AAGpCA,UAAAA,SAAQ,MAAM,SAAS,GAAG;AAC5B,cAAM,eAAeA,SAAQ,MAAMA,SAAQ,MAAM,SAAS,CAAC;AAC3D,cAAM,WAAW;AAAA,UACf,aAAa;AAAA,UACb,aAAa;AAAA,UACb,SAAS;AAAA,UACT,SAAS;AAAA,QACX;AACAA,iBAAQ,iBAAiB;AAAA,MAAA;AAG3B,YAAMA,SAAQ,KAAK;AAEX,cAAA,IAAI,uCAAuCA,SAAQ,EAAE;AAC7D,UAAI,KAAKA,QAAO;AAChB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AAAA,IAAA;AAInF,UAAM,eAAe,iBAAiB;AAAA,MACpC,CAACA,aAAYA,SAAQ,OAAO;AAAA,IAC9B;AACA,QAAI,iBAAiB,IAAI;AAChB,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,8BAA8B;AAAA,IAAA;AAG/D,UAAA,UAAU,iBAAiB,YAAY;AAGrC,YAAA,MAAM,KAAK,qBAAqB;AAGpC,QAAA,QAAQ,MAAM,SAAS,GAAG;AAC5B,YAAM,eAAe,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC;AAC3D,YAAM,WAAW;AAAA,QACf,aAAa;AAAA,QACb,aAAa;AAAA,QACb,SAAS;AAAA,QACT,SAAS;AAAA,MACX;AACA,cAAQ,iBAAiB;AAAA,IAAA;AAGnB,YAAA,IAAI,sCAAsC,QAAQ,EAAE;AAC5D,QAAI,KAAK,OAAO;AAAA,WACT,OAAO;AACN,YAAA,MAAM,mCAAmC,KAAK;AACtD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAEa,MAAA,qBAAqC,OAAO,KAAK,QAAQ;AAChE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AAGf,QAAA;AACF,YAAMA,WAAU,MAAMF,gBAAqB,QAAQ,EAAE,IAAI;AACzD,UAAIE,UAAS;AACH,gBAAA,IAAI,sCAAsCA,SAAQ,EAAE;AAC5D,YAAI,KAAKA,QAAO;AAChB;AAAA,MAAA;AAAA,aAEK,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,UAAM,UAAU,iBAAiB,KAAK,CAACA,aAAYA,SAAQ,OAAO,EAAE;AAEpE,QAAI,CAAC,SAAS;AACL,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,8BAA8B;AAAA,IAAA;AAG7D,YAAA,IAAI,qCAAqC,QAAQ,EAAE;AAC3D,QAAI,KAAK,OAAO;AAAA,WACT,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,oCAAoC;AAAA,EAAA;AAEtE;AAEa,MAAA,wBAAwC,CAAC,KAAK,QAAQ;AAC7D,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,eAAe,iBAAiB;AAAA,MACpC,CAAC,YAAY,QAAQ,OAAO;AAAA,IAC9B;AAEA,QAAI,iBAAiB,IAAI;AAChB,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,8BAA8B;AAAA,IAAA;AAGpD,qBAAA,OAAO,cAAc,CAAC;AACnC,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,WACd,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qCAAqC;AAAA,EAAA;AAEvE;AAGa,MAAA,oBAAoC,OAAO,KAAK,QAAQ;AAC/D,MAAA;AACI,UAAA,EAAE,YAAY,OAAO,GAAG,QAAQ,IAAI,WAAW,WAAW,SAAS,OAAO,IAAI,IAAI;AAGxF,UAAM,QAAa,CAAC;AACpB,QAAI,YAAY;AACd,YAAM,aAAa;AAAA,IAAA;AAErB,QAAI,QAAQ;AACV,YAAM,SAAS;AAAA,IAAA;AAIb,QAAA,aAAa,aAAa,SAAS;AAC/B,YAAA,0BAAU,KAAK;AACrB,UAAI,OAAa;AAEb,UAAA,aAAa,cAAc,UAAU;AACvC,gBAAQ,WAAW;AAAA,UACjB,KAAK;AAEH;AAAA,UACF,KAAK;AACK,oBAAA,IAAI,KAAK,IAAI,YAAY,GAAG,IAAI,SAAS,GAAG,IAAI,SAAS;AACjE,kBAAM,IAAI,KAAK,IAAI,YAAe,GAAA,IAAI,SAAS,GAAG,IAAI,QAAA,GAAW,IAAI,IAAI,EAAE;AAC3E;AAAA,UACF,KAAK;AACG,kBAAA,YAAY,IAAI,KAAK,IAAI,QAAY,IAAA,KAAK,KAAK,KAAK,GAAI;AACtD,oBAAA,IAAI,KAAK,UAAU,YAAY,GAAG,UAAU,SAAS,GAAG,UAAU,SAAS;AACnF,kBAAM,IAAI,KAAK,UAAU,YAAe,GAAA,UAAU,SAAS,GAAG,UAAU,QAAA,GAAW,IAAI,IAAI,EAAE;AAC7F;AAAA,UACF,KAAK;AACH,kBAAMC,eAAc,IAAI,KAAK,IAAI,QAAQ,KAAK,IAAI,OAAA,KAAY,KAAK,KAAK,KAAK,KAAK,GAAI;AAC9E,oBAAA,IAAI,KAAKA,aAAY,YAAY,GAAGA,aAAY,SAAS,GAAGA,aAAY,SAAS;AACzF,kBAAM,IAAI,KAAK,IAAI,YAAe,GAAA,IAAI,SAAS,GAAG,IAAI,QAAA,GAAW,IAAI,IAAI,EAAE;AAC3E;AAAA,UACF,KAAK;AACK,oBAAA,IAAI,KAAK,IAAI,eAAe,IAAI,YAAY,CAAC;AACrD,kBAAM,IAAI,KAAK,IAAI,YAAe,GAAA,IAAI,SAAS,IAAI,GAAG,GAAG,IAAI,IAAI,EAAE;AACnE;AAAA,QAAA;AAAA,MACJ,WACS,aAAa,SAAS;AACvB,gBAAA,IAAI,KAAK,SAAmB;AAC9B,cAAA,IAAI,KAAK,OAAiB;AAChC,YAAI,SAAS,IAAI,IAAI,IAAI,GAAG;AAAA,MAAA;AAG9B,UAAI,SAAS,KAAK;AAChB,cAAM,YAAY;AAAA,UAChB,MAAM,MAAM,YAAY;AAAA,UACxB,MAAM,IAAI,YAAY;AAAA,QACxB;AACQ,gBAAA,IAAI,gCAAgC,MAAM,aAAa,OAAO,IAAI,YAAa,CAAA,EAAE;AAAA,MAAA;AAAA,IAC3F;AAGF,YAAQ,IAAI,iCAAiC;AACrC,YAAA,IAAI,2BAA2B,EAAE,YAAY,QAAQ,WAAW,WAAW,SAAS;AAC5F,YAAQ,IAAI,wBAAwB,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAG9D,QAAA,CAAC,cAAc,cAAc,OAAO;AAClC,UAAA;AACI,cAAA,gBAAgB,MAAM,eAAe,eAAe;AAC1D,cAAM,oBAAoB,MAAM,eAAe,SAAS,YAAY;AACpE,cAAM,gBAAgB,MAAM,eAAe,SAAS,QAAQ;AAC5D,gBAAQ,IAAI,6BAA6B;AACjC,gBAAA,IAAI,+BAA+B,aAAa,EAAE;AAC1D,gBAAQ,IAAI,wBAAwB,kBAAkB,MAAM,MAAM,iBAAiB;AACnF,gBAAQ,IAAI,oBAAoB,cAAc,OAAO,CAAM,OAAA,EAAE,EAAE,MAAM,MAAM,cAAc,OAAO,CAAA,OAAM,EAAE,CAAC;AAGnG,cAAA,gBAAgB,MAAM,eAAe,KAAK;AAAA,UAC9C,QAAQ,EAAE,KAAK,CAAC,cAAc,YAAY,EAAE;AAAA,QAC7C,CAAA,EAAE,KAAK;AACR,gBAAQ,IAAI,2CAA2C,cAAc,MAAM,EAAE;AAC/D,sBAAA,QAAQ,CAAC,YAAY;AACjC,kBAAQ,IAAI,aAAa,QAAQ,MAAM,eAAe,QAAQ,UAAU,eAAe,QAAQ,gBAAgB,gBAAgB,QAAQ,gBAAgB,YAAY,CAAC,GAAG,YAAY,EAAE;AAAA,QAAA,CACtL;AAAA,eACM,YAAY;AACX,gBAAA,IAAI,sBAAsB,WAAW,OAAO;AAAA,MAAA;AAAA,IACtD;AAIE,QAAA;AACIC,YAAAA,WAAU,SAAS,IAAc;AACjCC,YAAAA,YAAW,SAAS,KAAe;AACnC,YAAA,QAAQD,WAAU,KAAKC;AAE7B,YAAM,eAAe,MAAM,eAAe,KAAK,KAAK,EACjD,KAAK,EAAE,WAAW,GAAI,CAAA,EACtB,KAAK,IAAI,EACT,MAAMA,SAAQ,EACd,KAAK;AAER,YAAM,QAAQ,MAAM,eAAe,eAAe,KAAK;AAEvD,YAAMT,YAAW;AAAA,QACf,UAAU;AAAA,QACV;AAAA,QACA,MAAMQ;AAAAA,QACN,YAAY,KAAK,KAAK,QAAQC,SAAQ;AAAA,MACxC;AAEA,cAAQ,IAAI,SAAS,aAAa,MAAM,uDAAuD,UAAU,EAAE;AACvG,UAAA,aAAa,SAAS,GAAG;AAC3B,gBAAQ,IAAI,wBAAwB;AAAA,UAClC,cAAc;AAAA,YACZ,YAAY,aAAa,CAAC,EAAE;AAAA,YAC5B,QAAQ,aAAa,CAAC,EAAE;AAAA,YACxB,cAAc,aAAa,CAAC,EAAE,gBAAgB;AAAA,YAC9C,WAAW,aAAa,CAAC,EAAE;AAAA,UAAA;AAAA,QAC7B,CACD;AAEK,cAAA,oBAAoB,CAAC,GAAG,IAAI,IAAI,aAAa,IAAI,CAAK,MAAA,EAAE,UAAU,CAAC,CAAC;AAClE,gBAAA,IAAI,gCAAgC,iBAAiB;AAAA,MAAA;AAE/D,UAAI,KAAKT,SAAQ;AACjB;AAAA,aACO,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,QAAI,kBAAkB;AAEtB,QAAI,YAAY;AACd,wBAAkB,gBAAgB;AAAA,QAChC,CAAC,YAAY,QAAQ,eAAe;AAAA,MACtC;AAAA,IAAA;AAGF,QAAI,QAAQ;AACV,wBAAkB,gBAAgB;AAAA,QAChC,CAAC,YAAY,QAAQ,WAAW;AAAA,MAClC;AAAA,IAAA;AAGc,oBAAA;AAAA,MACd,CAAC,GAAG,MACF,IAAI,KAAK,EAAE,SAAS,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,IACpE;AAEM,UAAA,UAAU,SAAS,IAAc;AACjC,UAAA,WAAW,SAAS,KAAe;AACnC,UAAA,cAAc,UAAU,KAAK;AACnC,UAAM,WAAW,aAAa;AAC9B,UAAM,mBAAmB,gBAAgB,MAAM,YAAY,QAAQ;AAEnE,UAAM,WAAW;AAAA,MACf,UAAU;AAAA,MACV,OAAO,gBAAgB;AAAA,MACvB,MAAM;AAAA,MACN,YAAY,KAAK,KAAK,gBAAgB,SAAS,QAAQ;AAAA,IACzD;AAEA,YAAQ,IAAI,SAAS,iBAAiB,MAAM,oCAAoC;AAChF,QAAI,KAAK,QAAQ;AAAA,WACV,OAAO;AACN,YAAA,MAAM,mCAAmC,KAAK;AACtD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAEa,MAAA,sBAAsC,OAAO,KAAK,QAAQ;AACjE,MAAA;AACF,UAAM,EAAE,WAAW,YAAY,gBAAgB,QAAQ,SAAA,IAAa,IAAI;AAExE,YAAQ,IAAI,8BAA8B;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,CAAC,aAAa,CAAC,cAAc,CAAC,gBAAgB;AAChD,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAIH,QAAI,CAAC,eAAe,cAAc,CAAC,eAAe,WAAW,QAAQ;AACnE,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAIH,QAAI,CAAC,eAAe,aAAa,eAAe,UAAU,WAAW,GAAG;AAEtE,UAAI,CAAC,eAAe,gBAAgB,CAAC,eAAe,sBAAsB;AACxE,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,QAAA,CACR;AAAA,MAAA;AAIH,qBAAe,YAAY,CAAC;AAAA,QAC1B,cAAc,eAAe;AAAA,QAC7B,sBAAsB,eAAe;AAAA,QACrC,eAAe,eAAe,iBAAiB;AAAA,QAC/C,gBAAgB,eAAe,kBAAkB;AAAA,QACjD,qBAAqB,eAAe,uBAAuB;AAAA,QAC3D,oBAAoB,eAAe,sBAAsB;AAAA,MAAA,CAC1D;AAAA,IAAA;AAGH,UAAM,cAAc;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,QAAQ,UAAU;AAAA,MAClB,UAAU,YAAY;AAAA,IACxB;AAGI,QAAA;AACIU,YAAAA,mBAAkB,IAAI,eAAe,WAAW;AAChD,YAAA,eAAe,MAAMA,iBAAgB,KAAK;AAExC,cAAA,IAAI,qCAAqC,aAAa,GAAG;AAGjE,YAAM,oBAAoB;AAAA,QACxB,IAAI,aAAa,IAAI,SAAS;AAAA,QAC9B,WAAW,aAAa;AAAA,QACxB,YAAY,aAAa;AAAA,QACzB,gBAAgB,aAAa;AAAA,QAC7B,WAAW,aAAa;AAAA,QACxB,QAAQ,aAAa;AAAA,QACrB,UAAU,aAAa;AAAA,QACvB,KAAK,aAAa;AAAA,QAClB,WAAW,aAAa;AAAA,QACxB,WAAW,aAAa;AAAA,MAC1B;AAEA,UAAI,OAAO,GAAG,EAAE,KAAK,iBAAiB;AACtC;AAAA,aACO,SAAS;AACR,cAAA,KAAK,2DAA2D,OAAO;AAE/E,cAAQ,MAAM,0BAA0B;AAAA,QACtC,SAAS,QAAQ;AAAA,QACjB,OAAO,QAAQ;AAAA,QACf,MAAM;AAAA,MAAA,CACP;AAAA,IAAA;AAIH,UAAM,kBAAkB;AAAA,MACtB,IAAI,WAAW,OAAO,kBAAkB,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,MAC1D,GAAG;AAAA,IACL;AAEA,mBAAe,KAAK,eAAe;AAE3B,YAAA,IAAI,0CAA0C,eAAe;AAC7D,YAAA,IAAI,kCAAkC,eAAe,MAAM;AAEnE,QAAI,OAAO,GAAG,EAAE,KAAK,eAAe;AAAA,WAC7B,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,oCAAoC;AAAA,EAAA;AAEtE;AAGa,MAAA,8BAA8C,OAAO,KAAK,QAAQ;AACzE,MAAA;AACF,UAAM,EAAE,YAAY,QAAQ,oBAAoB,IAAI;AAEpD,QAAI,CAAC,cAAc,CAAC,mBAAmB,gBAAgB,WAAW,GAAG;AACnE,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGH,YAAQ,IAAI,2CAA2C;AACvD,YAAQ,IAAI,gBAAgB,YAAY,SAAS,OAAO,UAAU;AAC1D,YAAA,IAAI,mBAAmB,MAAM;AAC7B,YAAA,IAAI,2BAA2B,gBAAgB,MAAM;AAGvD,UAAA,eAAe,MAAM,QAAQ;AAAA,MACjC,gBAAgB,IAAI,OAAO,SAAc,QAAgB;AAEjD,cAAA,gBAAgB,QAAQ,oBAAoB,UAAU;AAE5D,cAAM,iBAAiB;AAAA,UACrB,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,kBAAkB;AAAA,UAClB,WAAW;AAAA,YACT;AAAA,cACE,cAAc,QAAQ,gBAAgB;AAAA,cACtC,sBAAsB,QAAQ,gBAAgB;AAAA,cAC9C,eAAe,QAAQ,iBAAiB;AAAA,cACxC,gBAAgB,QAAQ,kBAAkB;AAAA,cAC1C,qBAAqB,QAAQ,uBAAuB;AAAA,cACpD,oBAAoB;AAAA,YAAA;AAAA,UACtB;AAAA,QAEJ;AAEA,cAAM,cAAc;AAAA,UAClB,WAAW,qBAAqB,KAAK,IAAI,CAAC,IAAI,GAAG;AAAA,UACjD,YAAY,OAAO,UAAU;AAAA;AAAA,UAC7B;AAAA,UACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UAClC,QAAQ,QAAQ;AAAA,UAChB,UAAU;AAAA,YACR,IAAI,QAAQ;AAAA,YACZ,aAAa,QAAQ;AAAA,UAAA;AAAA,QAEzB;AAEA,gBAAQ,IAAI,sBAAsB,MAAM,CAAC,KAAK;AAAA,UAC5C,YAAY,YAAY;AAAA,UACxB,aAAa,QAAQ;AAAA,UACrB,cAAc,QAAQ;AAAA,UACtB,QAAQ,QAAQ;AAAA,UAChB,QAAQ;AAAA,QAAA,CACT;AAGG,YAAA;AACI,gBAAA,WAAW,IAAI,eAAe,WAAW;AACzC,gBAAA,QAAQ,MAAM,SAAS,KAAK;AAC1B,kBAAA,IAAI,iDAAiD,MAAM,GAAG;AAC9D,kBAAA,IAAI,gBAAgB,QAAQ,WAAW;AACvC,kBAAA,IAAI,yBAAyB,MAAM,UAAU;AACrD,kBAAQ,IAAI,8BAA8B,MAAM,gBAAgB,UAAU;AAClE,kBAAA,IAAI,eAAe,aAAa;AACjC,iBAAA;AAAA,YACL,SAAS;AAAA,YACT,WAAW,QAAQ;AAAA,YACnB,WAAW,MAAM;AAAA,YACjB,aAAa,QAAQ;AAAA,YACrB,QAAQ;AAAA,UACV;AAAA,iBACO,SAAS;AACR,kBAAA,KAAK,sDAAsD,OAAO;AAE1E,yBAAe,KAAK;AAAA,YAClB,IAAI,WAAW,OAAO,kBAAkB,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,YAC1D,GAAG;AAAA,UAAA,CACJ;AACD,kBAAQ,IAAI,wDAAwD;AAC7D,iBAAA;AAAA,YACL,SAAS;AAAA,YACT,WAAW,QAAQ;AAAA,YACnB,aAAa,QAAQ;AAAA,YACrB,QAAQ;AAAA,UACV;AAAA,QAAA;AAAA,MAEH,CAAA;AAAA,IACH;AAEA,YAAQ,IAAI,0CAA0C;AAC9C,YAAA,IAAI,wBAAwB,aAAa,MAAM;AAC1C,iBAAA,QAAQ,CAAC,OAAO,QAAQ;AAC3B,cAAA,IAAI,KAAK,MAAM,CAAC,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,EAAE;AAAA,IAAA,CAClE;AAEG,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,SAAS;AAAA,MACT;AAAA,MACA,mBAAmB,aAAa;AAAA,MAChC,SAAS;AAAA,IAAA,CACV;AAAA,WACM,OAAO;AACN,YAAA,MAAM,4CAA4C,KAAK;AAC/D,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,6CAA6C;AAAA,EAAA;AAE/E;AAGa,MAAA,6BAA6C,OAAO,KAAK,QAAQ;AACxE,MAAA;AACI,UAAA,EAAE,eAAe,IAAI;AAE3B,QAAI,CAAC,YAAY;AACf,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGK,YAAA,IAAI,qDAAqD,UAAU;AAC3E,YAAQ,IAAI,mCAAmC,OAAO,YAAY,UAAU,UAAU;AAGlF,QAAA;AAEF,YAAM,QAAQ;AAAA,QACZ,YAAY,OAAO,UAAU;AAAA,QAC7B,6BAA6B;AAAA,MAC/B;AAEA,cAAQ,IAAI,kBAAkB,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAE5D,YAAMC,sBAAqB,MAAM,eAAe,KAAK,KAAK,EAAE,KAAK;AAEjE,cAAQ,IAAI,SAASA,oBAAmB,MAAM,wCAAwC;AAGhF,YAAA,gBAAgB,MAAM,eAAe,KAAK;AAAA,QAC9C,6BAA6B;AAAA,MAC9B,CAAA,EAAE,KAAK;AACR,cAAQ,IAAI,oDAAoD,cAAc,MAAM,EAAE;AAEtF,UAAI,KAAK,EAAE,UAAUA,oBAAAA,CAAoB;AACzC;AAAA,aACO,SAAS;AACR,cAAA,KAAK,4DAA4D,OAAO;AAAA,IAAA;AAIlF,UAAM,qBAAqB,eAAe;AAAA,MACxC,CAAC,YACC,OAAO,QAAQ,UAAU,MAAM,OAAO,UAAU,KAChD,QAAQ,eAAe;AAAA,IAC3B;AAEA,YAAQ,IAAI,SAAS,mBAAmB,MAAM,uCAAuC;AACrF,QAAI,KAAK,EAAE,UAAU,mBAAA,CAAoB;AAAA,WAClC,OAAO;AACN,YAAA,MAAM,8CAA8C,KAAK;AACjE,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,8CAA8C;AAAA,EAAA;AAEhF;AAGA,SAAS,kBACP,MACA,MACA,MACA,MACQ;AACR,QAAM,IAAI;AACJ,QAAA,KAAM,OAAO,KAAK,KAAM;AACxB,QAAA,KAAM,OAAO,KAAK,KAAM;AAC9B,QAAM,MAAO,OAAO,QAAQ,KAAK,KAAM;AACvC,QAAM,MAAO,OAAO,QAAQ,KAAK,KAAM;AAEjC,QAAA,IACJ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,KAAK,CAAC,IAClC,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,KAAK,CAAC;AAClE,QAAM,IAAI,IAAI,KAAK,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC,CAAC;AAEvD,SAAO,IAAI;AACb;ACz4BA,MAAM,mBAAmB;AAEzB,eAAe,qBAA8C;AACvD,MAAA;AAEI,UAAA,aAAa,IAAI,gBAAgB;AACvC,UAAM,YAAY,WAAW,MAAM,WAAW,MAAA,GAAS,GAAK;AAEtD,UAAA,WAAW,MAAM,MAAM,kBAAkB;AAAA,MAC7C,QAAQ,WAAW;AAAA,MACnB,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,gBAAgB;AAAA,MAAA;AAAA,IAClB,CACD;AAED,iBAAa,SAAS;AAElB,QAAA,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,IAAA;AAGpD,UAAA,QAAwB,MAAM,SAAS,KAAK;AAC1C,YAAA;AAAA,MACN,mCAAmC,MAAM,MAAM,aAAa,KAAK,UAAU,MAAM,CAAC,KAAK,CAAA,GAAI,MAAM,CAAC,CAAC;AAAA,IACrG;AAEO,WAAA;AAAA,WACA,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACjD,QAAA,MAAM,SAAS,cAAc;AAC/B,cAAQ,MAAM,iDAAiD;AAAA,IACtD,WAAA,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC1C,cAAQ,MAAM,0CAA0C;AAAA,IAAA;AAE1D,WAAO,CAAC;AAAA,EAAA;AAEZ;AAeA,IAAI,mBAAmD,CAAC;AAExD,SAAS,2BAA2B,OAAe;AACjD,QAAM,YAAY;AAAA,IAChB,EAAE,KAAK,SAAS,KAAK,QAAQ,SAAS,mBAAmB;AAAA,IACzD,EAAE,KAAK,QAAQ,KAAK,SAAS,SAAS,sBAAsB;AAAA,IAC5D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,uBAAuB;AAAA,IAC9D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,sBAAsB;AAAA,IAC7D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,uBAAuB;AAAA,IAC9D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,oBAAoB;AAAA,IAC3D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,sBAAsB;AAAA,IAC7D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,qBAAqB;AAAA,IAC5D,EAAE,KAAK,QAAQ,KAAK,SAAS,SAAS,uBAAuB;AAAA,IAC7D,EAAE,KAAK,SAAS,KAAK,SAAS,SAAS,oBAAoB;AAAA,EAC7D;AACO,SAAA,UAAU,QAAQ,UAAU,MAAM;AAC3C;AAEA,SAAS,0BACP,MACA,OACU;AACV,QAAM,SAAS,KAAK;AAEhB,MAAA,CAAC,iBAAiB,MAAM,GAAG;AACvB,UAAA,oBAAoB,2BAA2B,KAAK;AAC1D,qBAAiB,MAAM,IAAI;AAAA,MACzB,QAAQ,UAAU,IAAI,YAAY,UAAU,IAAI,aAAa;AAAA,MAC7D,UAAU;AAAA,QACR,GAAG;AAAA,QACH,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAAA,MACA,YAAY,GAAG,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI,CAAC;AAAA,MACjD,aACE,UAAU,IACN,mBACA,UAAU,IACR,2BACA;AAAA,IACV;AAAA,EAAA;AAGI,QAAA,SAAS,iBAAiB,MAAM;AAE/B,SAAA;AAAA,IACL,IAAI;AAAA,IACJ,MAAM,KAAK;AAAA,IACX,OAAO,KAAK;AAAA,IACZ,OAAO,KAAK;AAAA,IACZ,QAAQ,OAAO;AAAA,IACf,UAAU,OAAO;AAAA,IACjB,YAAY,OAAO;AAAA,IACnB,aAAa,OAAO;AAAA,IACpB,UAAU,UAAU,OAAO,MAAM,EAAE,CAAC;AAAA,IACpC,aAAa,KAAK;AAAA,IAClB,YAAY,KAAK;AAAA,IACjB,aAAa,KAAK,YAAY,CAAC,GAAG;AAAA,IAClC,UAAU,KAAK,QAAQ;AAAA,EACzB;AACF;AAGA,SAAS,aAAa,WAAmB,WAAoB,SAAkB;AACvE,QAAA,0BAAU,KAAK;AAErB,UAAQ,WAAW;AAAA,IACjB,KAAK;AAEI,aAAA;AAAA,QACL,OAAW,oBAAA,KAAK,YAAY;AAAA;AAAA,QAC5B,KAAS,oBAAA,KAAK,YAAY;AAAA;AAAA,MAC5B;AAAA,IACF,KAAK;AACI,aAAA;AAAA,QACL,OAAO,WAAW,GAAG;AAAA,QACrB,KAAK,SAAS,GAAG;AAAA,MACnB;AAAA,IACF,KAAK;AACG,YAAA,YAAY,QAAQ,KAAK,CAAC;AACzB,aAAA;AAAA,QACL,OAAO,WAAW,SAAS;AAAA,QAC3B,KAAK,SAAS,SAAS;AAAA,MACzB;AAAA,IACF,KAAK;AACI,aAAA;AAAA,QACL,OAAO,YAAY,KAAK,EAAE,cAAc,GAAG;AAAA;AAAA,QAC3C,KAAK,UAAU,KAAK,EAAE,cAAc,EAAG,CAAA;AAAA,MACzC;AAAA,IACF,KAAK;AACI,aAAA;AAAA,QACL,OAAO,aAAa,GAAG;AAAA,QACvB,KAAK,WAAW,GAAG;AAAA,MACrB;AAAA,IACF,KAAK;AACH,UAAI,aAAa,SAAS;AACjB,eAAA;AAAA,UACL,OAAO,WAAW,SAAS,SAAS,CAAC;AAAA,UACrC,KAAK,SAAS,SAAS,OAAO,CAAC;AAAA,QACjC;AAAA,MAAA;AAGK,aAAA;AAAA,QACL,OAAO,WAAW,GAAG;AAAA,QACrB,KAAK,SAAS,GAAG;AAAA,MACnB;AAAA,IACF;AACS,aAAA;AAAA,QACL,OAAO,WAAW,GAAG;AAAA,QACrB,KAAK,SAAS,GAAG;AAAA,MACnB;AAAA,EAAA;AAEN;AAGA,SAAS,yBAAyB,WAAmB,SAA0B;AACvE,QAAA,QAAQ,IAAI,KAAK,SAAS;AAChC,QAAM,MAAM,UAAU,IAAI,KAAK,OAAO,wBAAQ,KAAK;AACnD,QAAM,aAAa,IAAI,QAAQ,IAAI,MAAM,QAAQ;AAC1C,SAAA,cAAc,MAAO,KAAK;AACnC;AAGA,SAAS,mBACP,YACA,WACQ;AAIR,QAAM,cAAc,KAAK;AAAA,KACtB,UAAU,IAAI,QAAA,IAAY,UAAU,MAAM,cACxC,MAAO,KAAK,KAAK;AAAA,EACtB;AACA,SAAO,KAAK,IAAI,cAAc,GAAG,EAAE;AACrC;AAEa,MAAA,uBAAuC,OAAO,KAAK,QAAQ;AAClE,MAAA;AACI,UAAA;AAAA,MACJ;AAAA,MACA,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,QACE,IAAI;AAGF,UAAA,EAAE,OAAO,IAAA,IAAQ;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,YAAQ,IAAI,kCAAkC,SAAS,YAAY,SAAS,UAAU,OAAO,EAAE;AACvF,YAAA,IAAI,0BAA0B,MAAM,aAAa,OAAO,IAAI,YAAa,CAAA,EAAE;AAG3E,UAAA,gBAAgB,MAAM,mBAAmB;AAC/C,QAAI,YAAY,cAAc;AAAA,MAAI,CAAC,MAAM,UACvC,0BAA0B,MAAM,KAAK;AAAA,IACvC;AAGI,QAAA,cAAc,eAAe,OAAO;AACtC,kBAAY,UAAU,OAAO,CAAC,QAAQ,IAAI,OAAO,UAAU;AAAA,IAAA;AAI7D,QAAI,QAAQ;AACJ,YAAA,aAAc,OAAkB,YAAY;AAClD,kBAAY,UAAU;AAAA,QACpB,CAAC,QACC,IAAI,KAAK,YAAc,EAAA,SAAS,UAAU,KAC1C,IAAI,MAAM,YAAY,EAAE,SAAS,UAAU;AAAA,MAC/C;AAAA,IAAA;AAIF,QAAI,iBAAwB,CAAC;AAEzB,QAAA;AAGF,YAAM,gBAAgB,MAAM,QAAQ,KAAK,CAAE,CAAA,EAAE,KAAK;AAEjC,uBAAA,cAAc,IAAI,CAAY,aAAA;AAAA,QAC7C,IAAI,QAAQ,IAAI,SAAS;AAAA,QACzB,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,QACjB,YAAY,QAAQ;AAAA,QACpB,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,gBAAgB,QAAQ;AAAA,QACxB,UAAU,QAAQ;AAAA,MAAA,EAClB;AAEF,cAAQ,IAAI,SAAS,eAAe,MAAM,4BAA4B;AAC9D,cAAA,IAAI,sBAAsB,MAAM,aAAa,OAAO,IAAI,YAAa,CAAA,EAAE;AAG3E,UAAA,eAAe,WAAW,GAAG;AAC/B,cAAM,EAAE,kBAAAC,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,yBAAiBA,qBAAoB,CAAC;AACtC,gBAAQ,IAAI,mBAAmB,eAAe,MAAM,uBAAuB;AAAA,MAAA;AAAA,aAEtE,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AACjF,YAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,uBAAiBA,qBAAoB,CAAC;AAAA,IAAA;AAGxC,YAAQ,IAAI,wBAAwB,eAAe,QAAQ,UAAU;AACrE,YAAQ,IAAI,wBAAwB,UAAU,IAAI,CAAM,OAAA,EAAE,IAAI,EAAE,IAAI,MAAM,EAAE,KAAA,EAAO,CAAC;AACpF,YAAQ,IAAI,yBAAyB,eAAe,IAAI,CAAK,MAAA,EAAE,UAAU,CAAC;AAG1E,UAAM,YAAY,UAAU,IAAI,CAAC,aAAa;AAE5C,YAAM,mBAAmB,eAAe;AAAA,QACtC,CAAC,YAAY,QAAQ,eAAe,SAAS;AAAA,MAC/C;AAEQ,cAAA,IAAI,YAAY,SAAS,IAAI,KAAK,SAAS,EAAE,YAAY,iBAAiB,MAAM,WAAW;AAGnG,YAAM,kBAAkB,iBAAiB,OAAO,CAAC,YAAY;AAC3D,cAAM,cAAc,IAAI,KAAK,QAAQ,SAAS;AACxC,cAAA,cAAc,YAAY,QAAQ;AAClC,cAAA,YAAY,MAAM,QAAQ;AAC1B,cAAA,UAAU,IAAI,QAAQ;AACtB,cAAA,UAAU,eAAe,aAAa,eAAe;AAE3D,YAAI,SAAS;AACH,kBAAA,IAAI,aAAa,QAAQ,EAAE,cAAc,QAAQ,SAAS,KAAK,QAAQ,cAAc,WAAW,GAAG;AAAA,QAAA,OACtG;AACL,kBAAQ,IAAI,aAAa,QAAQ,EAAE,kBAAkB,QAAQ,SAAS,iBAAiB,MAAM,aAAa,QAAQ,IAAI,YAAA,CAAa,GAAG;AAAA,QAAA;AAEjI,eAAA;AAAA,MAAA,CACR;AAGD,YAAM,gBAAgB,iBAAiB;AAAA,QAAO,CAAC,YAC7C,QAAQ,IAAI,KAAK,QAAQ,SAAS,CAAC;AAAA,MAAA,EACnC;AAIF,YAAM,oBAAoB,gBAAgB,OAAO,CAAC,OAAO,YAAY;AACnE,eACE,QAAQ,yBAAyB,QAAQ,WAAW,QAAQ,OAAO;AAAA,SAEpE,CAAC;AAEI,cAAA,IAAI,YAAY,SAAS,IAAI,KAAK,SAAS,EAAE,MAAM,iBAAiB,MAAM,oBAAoB,gBAAgB,MAAM,mBAAmB,SAAS,MAAM,kBAAkB,QAAQ,CAAC,CAAC,gBAAgB;AAG1M,YAAM,iBAAiB,mBAAmB,SAAS,IAAI,EAAE,OAAO,KAAK;AAE9D,aAAA;AAAA,QACL,YAAY,SAAS;AAAA,QACrB,cAAc,SAAS;AAAA,QACvB,eAAe,iBAAiB;AAAA;AAAA,QAChC;AAAA,QACA;AAAA;AAAA,QACA;AAAA,QACA,QAAQ,SAAS;AAAA,MACnB;AAAA,IAAA,CACD;AAGD,UAAM,UAAU;AAAA,MACd,gBAAgB,UAAU;AAAA,MAC1B,gBAAgB,UAAU,OAAO,CAAC,QAAQ,IAAI,WAAW,SAAS,EAC/D;AAAA,MACH,oBAAoB,UAAU;AAAA,QAC5B,CAAC,KAAK,QAAQ,MAAM,IAAI;AAAA,QACxB;AAAA,MACF;AAAA,MACA,oBACE,UAAU,SAAS,IACf,UAAU,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,mBAAmB,CAAC,IAC7D,KAAK;AAAA,QACH,UAAU,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,eAAe,CAAC;AAAA,QACzD;AAAA,MAAA,IAEF;AAAA,IACR;AAEA,QAAI,KAAK;AAAA,MACP;AAAA,MACA;AAAA,MACA,WAAW;AAAA,QACT,OAAO,MAAM,YAAY;AAAA,QACzB,KAAK,IAAI,YAAY;AAAA,QACrB,OAAO;AAAA,MAAA;AAAA,IACT,CACD;AAAA,WACM,OAAO;AACN,YAAA,MAAM,sCAAsC,KAAK;AACzD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,6BAA6B;AAAA,EAAA;AAE/D;AAmDa,MAAA,qBAAqC,OAAO,KAAK,QAAQ;AAChE,MAAA;AACI,UAAA,EAAE,eAAe,IAAI;AAC3B,UAAM,EAAE,YAAY,SAAS,WAAW,QAAA,IAAY,IAAI;AAGlD,UAAA,EAAE,OAAO,IAAA,IAAQ;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,YAAQ,IAAI,yCAAyC,SAAS,YAAY,SAAS,UAAU,OAAO,EAAE;AAC9F,YAAA,IAAI,YAAY,UAAU,2BAA2B,MAAM,YAAY,CAAC,OAAO,IAAI,YAAY,CAAC,EAAE;AAGxG,QAAI,iBAAwB,CAAC;AAEzB,QAAA;AAGI,YAAA,gBAAgB,MAAM,QAAQ,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK;AAE7C,uBAAA,cAAc,IAAI,CAAW,YAAA;AACxC,YAAA,CAAC,QAAQ,KAAK;AACR,kBAAA,MAAM,sCAAsC,OAAO;AAAA,QAAA;AAEtD,eAAA;AAAA,UACL,IAAI,QAAQ,MAAM,QAAQ,IAAI,SAAa,IAAA;AAAA,UAC3C,YAAY,QAAQ;AAAA,UACpB,WAAW,QAAQ;AAAA,UACnB,SAAS,QAAQ;AAAA,UACjB,YAAY,QAAQ;AAAA,UACpB,QAAQ,QAAQ;AAAA,UAChB,QAAQ,QAAQ;AAAA,UAChB,gBAAgB,QAAQ;AAAA,UACxB,UAAU,QAAQ;AAAA,UAClB,gBAAgB,QAAQ;AAAA,UACxB,gBAAgB,QAAQ;AAAA,QAC1B;AAAA,MAAA,CACD;AAED,cAAQ,IAAI,SAAS,eAAe,MAAM,2CAA2C,UAAU,EAAE;AAG7F,UAAA,eAAe,SAAS,GAAG;AAC7B,gBAAQ,IAAI,gCAAgC,eAAe,IAAI,QAAM,EAAE,IAAI,EAAE,IAAI,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC;AAAA,MAAA;AAE5F,cAAA,IAAI,gCAAgC,MAAM,aAAa,OAAO,IAAI,YAAa,CAAA,EAAE;AAGrF,UAAA,eAAe,WAAW,GAAG;AAC/B,cAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,0BAAkBA,qBAAoB,IAAI,OAAO,CAAW,YAAA,QAAQ,eAAe,UAAU;AAC7F,gBAAQ,IAAI,mBAAmB,eAAe,MAAM,sCAAsC,UAAU,EAAE;AAAA,MAAA;AAAA,aAEjG,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AACjF,YAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,wBAAkBA,qBAAoB,IAAI,OAAO,CAAW,YAAA,QAAQ,eAAe,UAAU;AAAA,IAAA;AAK/F,UAAM,mBAAmB,eAAe,OAAO,CAAC,YAAY;AAC1D,YAAM,cAAc,IAAI,KAAK,QAAQ,SAAS;AACxC,YAAA,cAAc,YAAY,QAAQ;AAClC,YAAA,YAAY,MAAM,QAAQ;AAC1B,YAAA,UAAU,IAAI,QAAQ;AACtB,YAAA,cAAc,eAAe,aAAa,eAAe;AAE/D,UAAI,aAAa;AACf,gBAAQ,IAAI,sBAAsB,QAAQ,EAAE,cAAc,QAAQ,SAAS,KAAK,QAAQ,cAAc,WAAW,cAAc,QAAQ,MAAM,GAAG;AAAA,MAAA,OAC3I;AACL,gBAAQ,IAAI,sBAAsB,QAAQ,EAAE,cAAc,QAAQ,SAAS,aAAa,MAAM,YAAa,CAAA,OAAO,IAAI,YAAA,CAAa,cAAc,QAAQ,MAAM,GAAG;AAAA,MAAA;AAG7J,aAAA;AAAA,IAAA,CACR;AAED,YAAQ,IAAI,eAAe,iBAAiB,MAAM,wCAAwC,UAAU,EAAE;AAGlG,QAAA,iBAAiB,SAAS,GAAG;AAC/B,cAAQ,IAAI,4BAA4B,iBAAiB,IAAI,CAAM,OAAA;AAAA,QACjE,IAAI,EAAE;AAAA,QACN,OAAO,CAAC,CAAC,EAAE;AAAA,QACX,QAAQ,EAAE;AAAA,QACV,CAAC;AAAA,IAAA;AAIL,QAAIC,oBAA0B,CAAC;AAC3B,QAAA;AACF,YAAM,EAAE,iBAAAC,iBAAA,IAAoB,MAAM,OAAO,qBAAW;AAC9C,YAAA,gBAAgB,MAAMA,iBAAgB,KAAK;AAAA,QAC/C;AAAA,QACA,WAAW,EAAE,MAAM,MAAM,eAAe,MAAM,IAAI,YAAc,EAAA;AAAA,MACjE,CAAA,EAAE,KAAK;AAEW,MAAAD,oBAAA,cAAc,IAAI,CAAY,aAAA;AAAA,QAC/C,IAAI,QAAQ;AAAA,QACZ,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,QACjB,eAAe,QAAQ;AAAA,QACvB,aAAa,QAAQ;AAAA,QACrB,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA,MAAA,EAClB;AAEF,cAAQ,IAAI,SAASA,kBAAiB,MAAM,mCAAmC,UAAU,EAAE;AAAA,aACpF,SAAS;AACR,cAAA,KAAK,sCAAsC,OAAO;AAAA,IAAA;AAI5D,UAAM,aAAa,iBAAiB;AAAA,MAClC,CAAC,QAAQ,YAAY;AACnB,cAAM,OAAO,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAC7D,YAAI,CAAC,OAAO,IAAI,EAAU,QAAA,IAAI,IAAI,CAAC;AAC5B,eAAA,IAAI,EAAE,KAAK,OAAO;AAClB,eAAA;AAAA,MACT;AAAA,MACA,CAAA;AAAA,IACF;AAGA,UAAM,oBAAoBA,kBAAiB;AAAA,MACzC,CAAC,QAAQ,YAAY;AACnB,cAAM,OAAO,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAC7D,YAAI,CAAC,OAAO,IAAI,EAAU,QAAA,IAAI,IAAI,CAAC;AAC5B,eAAA,IAAI,EAAE,KAAK,OAAO;AAClB,eAAA;AAAA,MACT;AAAA,MACA,CAAA;AAAA,IACF;AAGM,UAAA,+BAAe,IAAI;AAAA,MACvB,GAAG,OAAO,KAAK,UAAU;AAAA,MACzB,GAAG,OAAO,KAAK,iBAAiB;AAAA,IAAA,CACjC;AAGD,QAAI,oBAA2B,CAAC;AAC5B,QAAA;AACI,YAAA,kBAAkB,MAAM,WAAW,KAAK;AAAA,QAC5C;AAAA,QACA,MAAM;AAAA,UACJ,MAAM,OAAO,OAAO,YAAY;AAAA,UAChC,MAAM,OAAO,KAAK,YAAY;AAAA,QAAA;AAAA,MAEjC,CAAA,EAAE,KAAK;AAEY,0BAAA,gBAAgB,IAAI,CAAQ,SAAA;AAAA,QAC9C,MAAM,IAAI;AAAA,QACV,mBAAmB,IAAI;AAAA,QACvB,kBAAkB,IAAI;AAAA,QACtB,kBAAkB,IAAI;AAAA,MAAA,EACtB;AAEF,cAAQ,IAAI,SAAS,kBAAkB,MAAM,oCAAoC,UAAU,EAAE;AAAA,aACtF,SAAS;AACR,cAAA,KAAK,uCAAuC,OAAO;AAAA,IAAA;AAIvD,UAAA,gBAAgB,MAAM,mBAAmB;AAC/C,UAAM,UAAU,IAAI,IAAI,cAAc,IAAI,CAAA,SAAQ,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,CAAC;AAGxE,UAAM,aAAa,MAAM,KAAK,QAAQ,EAAE,IAAI,CAAC,SAAS;AACpD,YAAME,YAAW,WAAW,IAAI,KAAK,CAAC;AACtC,YAAM,WAAW,kBAAkB,IAAI,KAAK,CAAC;AAE7C,YAAM,gBAAgBA,UAAS;AAC/B,YAAM,oBAAoBA,UAAS,OAAO,CAAC,OAAO,YAAY;AAC5D,eACE,QAAQ,yBAAyB,QAAQ,WAAW,QAAQ,OAAO;AAAA,SAEpE,CAAC;AAGJ,YAAM,iBAAiB,CAAC,GAAGA,SAAQ,EAAE;AAAA,QAAK,CAAC,GAAG,MAC5C,IAAI,KAAK,EAAE,SAAS,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,MAClE;AACM,YAAA,eAAe,eAAe,CAAC;AACrC,YAAM,cAAc,eAAe,eAAe,SAAS,CAAC;AAGtD,YAAA,eAAe,SAAS,CAAC;AAC/B,YAAM,cAAc,SAAS,SAAS,SAAS,CAAC;AAG1C,YAAA,oBAAoB,cAAc,aAAa;AAC/C,YAAA,uBAAuB,cAAc,UAAU,WAAW;AAG1D,YAAA,kBAAkB,aAAa,WAAW;AAChD,YAAM,qBAAqB,aAAa,WAAW,aAAa,UAAU,aAAa,UACnF,YAAY,SAAS,YAAY,UAChC,aAAa,UAAU,WAAW;AAGvC,UAAI,iBAAiB;AACjB,UAAA,gBAAgB,aAAa,SAAS;AACxC,cAAM,gBAAgB,IAAI,KAAK,YAAY,OAAO,EAAE,QAAQ,IAAI,IAAI,KAAK,aAAa,SAAS,EAAE,QAAQ,MAAM,MAAO,KAAK;AAC1G,yBAAA,KAAK,IAAI,GAAG,YAAY;AAAA,MAAA;AAI3C,YAAM,aAAa,kBAAkB,KAAK,CAAO,QAAA,IAAI,SAAS,IAAI;AAC5D,YAAA,oBAAoB,YAAY,oBAClC,QAAQ,IAAI,WAAW,iBAAiB,KAAK,WAAW,oBACxD;AAEI,cAAA,IAAI,kBAAkB,IAAI,GAAG;AAC7B,cAAA,IAAI,iBAAiB,aAAa,oBAAoB,kBAAkB,QAAQ,CAAC,CAAC,GAAG;AAC7F,cAAQ,IAAI,8BAA8B,qBAAqB,KAAK,6BAA6B;AACjG,cAAQ,IAAI,4BAA4B,mBAAmB,KAAK,0BAA0B;AAC1F,cAAQ,IAAI,0BAA0B,SAAS,MAAM,0BAA0B,qBAAqB,KAAK,EAAE;AAEpG,aAAA;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,WAAW,eAAe,QAAQ,CAAC,CAAC;AAAA,QACpD,aAAa;AAAA,QACb,oBAAoB,KAAK,IAAI,GAAG,iBAAiB,iBAAiB;AAAA,QAClE;AAAA;AAAA,MACF;AAAA,IAAA,CACD;AAGD,UAAM,iBAAiB,iBAAiB,IAAI,CAAC,YAAY;AACvD,cAAQ,IAAI,4CAA4C,QAAQ,EAAE,KAAK;AAAA,QACrE,IAAI,QAAQ;AAAA,QACZ,OAAO,CAAC,CAAC,QAAQ;AAAA,QACjB,QAAQ,QAAQ;AAAA,QAChB,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ,WAAW;AAAA,QAC5B,YAAY,CAAC,CAAC,QAAQ;AAAA,QACtB,gBAAgB,QAAQ,kBAAkB;AAAA,MAAA,CAC3C;AAEG,UAAA,CAAC,QAAQ,IAAI;AACP,gBAAA,MAAM,iCAAiC,OAAO;AAAA,MAAA;AAGjD,aAAA;AAAA,QACL,WAAW,QAAQ;AAAA;AAAA,QACnB,cAAc;AAAA;AAAA,QACd,aAAa,QAAQ,cAAc;AAAA,QACnC,MAAM,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAAA,QACtD,QAAQ,QAAQ,UAAU;AAAA,QAC1B,eAAe,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,OAAO;AAAA,QAC1D,mBAAmB,QAAQ,UAAU,WAAW;AAAA,QAChD,gBAAgB,QAAQ,UACpB,OAAO,IAAI,KAAK,QAAQ,OAAO,GAAG,OAAO,IACzC;AAAA;AAAA;AAAA,QAEJ,oBAAoB,QAAQ,WAAW,QAAQ,UAAU,aAAa,UAClE,QAAQ,SAAS,YAAY,UAC5B,QAAQ,WAAW,cAAc,KAAK;AAAA,QAC3C,eAAe;AAAA,UACb,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV;AAAA,QACA,YAAY,QAAQ,gBAAgB,cAAc,QAAQ,UAAU,QAAQ,WAAW,cAAc,wBAAwB;AAAA,QAC7H,eACE,QAAQ,gBAAgB,WAAW,SAAS,IACxC,QAAQ,eAAe,UACpB,IAAI,CAAC,aAAa,SAAS,oBAAoB,EAC/C,KAAK,IAAI,IACZ,QAAQ,gBAAgB,yBAAyB,QAAQ,WAAW,cAAc,QAAQ;AAAA,QAChG,eAAe,QAAQ,UAAU;AAAA;AAAA,QACjC,uBAAuB,QAAQ,yBAAyB;AAAA;AAAA,QACxD,YAAY,QAAQ,gBAAgB,cAAc;AAAA;AAAA,QAClD,kBAAkB,QAAQ,gBAAgB,oBAAoB;AAAA;AAAA,QAC9D,gBAAgB,QAAQ,kBAAkB;AAAA;AAAA,QAC1C,gBAAgB,QAAQ,kBAAkB;AAAA;AAAA,MAC5C;AAAA,IAAA,CACD;AAED,UAAM,cAAc;AAAA,MAClB,YAAY,WAAW;AAAA,QACrB,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,IAAI,EAAE,QAAQ;AAAA,MAClE;AAAA,MACA,gBAAgB,eAAe;AAAA,QAC7B,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,IAAI,EAAE,QAAQ;AAAA,MAAA;AAAA,IAEpE;AAEQ,YAAA,IAAI,4BAA4B,YAAY,WAAW,MAAM,iBAAiB,YAAY,eAAe,MAAM,kBAAkB;AAEzI,QAAI,KAAK,WAAW;AAAA,WACb,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AACvD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,oCAAoC;AAAA,EAAA;AAEtE;AAEa,MAAA,iBAAiC,OAAO,KAAK,QAAQ;AAC5D,MAAA;AACI,UAAA,EAAE,WAAW,IAAI;AAEf,YAAA,IAAI,8BAA8B,MAAM,EAAE;AAGlD,QAAI,iBAAwB,CAAC;AAEzB,QAAA;AAEI,YAAA,gBAAgB,MAAM,QAAQ,KAAK,EAAE,OAAO,CAAC,EAAE,KAAK;AAEzC,uBAAA,cAAc,IAAI,CAAY,aAAA;AAAA,QAC7C,IAAI,QAAQ,IAAI,SAAS;AAAA,QACzB,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,QACjB,YAAY,QAAQ;AAAA,QACpB,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,gBAAgB,QAAQ;AAAA,QACxB,UAAU,QAAQ;AAAA,QAClB,UAAU,QAAQ;AAAA,MAAA,EAClB;AAEF,cAAQ,IAAI,SAAS,eAAe,MAAM,iCAAiC,MAAM,EAAE;AAG/E,UAAA,eAAe,WAAW,GAAG;AAC/B,cAAM,EAAE,kBAAAH,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,0BAAkBA,qBAAoB,IAAI,OAAO,CAAW,YAAA,QAAQ,WAAW,MAAM;AACrF,gBAAQ,IAAI,mBAAmB,eAAe,MAAM,kCAAkC,MAAM,EAAE;AAAA,MAAA;AAAA,aAEzF,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AACjF,YAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,wBAAkBA,qBAAoB,IAAI,OAAO,CAAW,YAAA,QAAQ,WAAW,MAAM;AAAA,IAAA;AAIvF,UAAM,eAAe,eAAe,OAAO,CAAW,YAAA,QAAQ,WAAW,MAAM;AAE/E,YAAQ,IAAI,SAAS,aAAa,MAAM,sBAAsB,MAAM,EAAE;AAGhE,UAAA,gBAAgB,MAAM,mBAAmB;AACzC,UAAA,YAAY,cAAc,IAAI,CAAC,MAAM,UAAU,0BAA0B,MAAM,KAAK,CAAC;AAGrF,UAAA,UAAU,aAAa,IAAI,CAAW,YAAA;AAC1C,YAAM,WAAW,UAAU,KAAK,SAAO,IAAI,OAAO,QAAQ,UAAU;AACpE,YAAM,WAAW,yBAAyB,QAAQ,WAAW,QAAQ,OAAO;AAErE,aAAA;AAAA,QACL,MAAM,QAAQ;AAAA,QACd,cAAc,UAAU,QAAQ;AAAA,QAChC,aAAa,QAAQ,cAAc;AAAA,QACnC;AAAA,QACA,eAAe,QAAQ,gBAAgB,WAAW,SAAS,IACvD,QAAQ,eAAe,UAAU,IAAI,CAAY,aAAA,SAAS,oBAAoB,EAAE,KAAK,IAAI,IACzF,QAAQ,gBAAgB,wBAAwB;AAAA,QACpD,YAAY,QAAQ,gBAAgB,cAAc,QAAQ,SAAS;AAAA,QACnE,QAAQ,QAAQ,UAAU;AAAA,QAC1B,UAAU,QAAQ,UAAU,WAAW;AAAA,QACvC,UAAU,QAAQ;AAAA,MACpB;AAAA,IAAA,CACD,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,IAAI,EAAE,SAAS;AAEzE,QAAI,KAAK;AAAA,MACP;AAAA,MACA;AAAA,MACA,eAAe,QAAQ;AAAA,MACvB,eAAe,QAAQ,OAAO,CAAC,KAAK,WAAW,MAAM,OAAO,UAAU,CAAC;AAAA,IAAA,CACxE;AAAA,WAEM,OAAO;AACN,YAAA,MAAM,gCAAgC,KAAK;AACnD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gCAAgC;AAAA,EAAA;AAElE;AAEa,MAAA,iBAAiC,OAAO,KAAK,QAAQ;AAC5D,MAAA;AACF,UAAM,EAAE,YAAY,MAAM,kBAAkB,kBAAkB,kBAAA,IAAsB,IAAI;AAExF,YAAQ,IAAI,kCAAkC,UAAU,OAAO,IAAI,KAAK;AAAA,MACtE;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAGD,QAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,kBAAkB;AAC7C,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAIH,UAAM,gBAAgB,CAAC,YAAY,YAAY,OAAO,eAAe,IAAI;AACzE,QAAI,CAAC,cAAc,SAAS,gBAAgB,GAAG;AAC7C,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAIH,QAAI,CAAC,sBAAsB,KAAK,IAAI,GAAG;AACrC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGC,QAAA;AAEI,YAAA,kBAAkB,MAAM,WAAW;AAAA,QACvC,EAAE,YAAY,KAAK;AAAA,QACnB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA,kBAAkB,oBAAoB;AAAA,UACtC,mBAAmB,sBAAsB,SAAY,oBAAoB;AAAA;AAAA,QAC3E;AAAA,QACA;AAAA,UACE,KAAK;AAAA,UACL,QAAQ;AAAA,UACR,eAAe;AAAA,QAAA;AAAA,MAEnB;AAEQ,cAAA,IAAI,gCAAgC,gBAAgB,GAAG;AACvD,cAAA,IAAI,uCAAuC,gBAAgB,iBAAiB;AAEpF,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,SAAS;AAAA,QACT,MAAM;AAAA,UACJ,IAAI,gBAAgB;AAAA,UACpB,YAAY,gBAAgB;AAAA,UAC5B,MAAM,gBAAgB;AAAA,UACtB,kBAAkB,gBAAgB;AAAA,UAClC,kBAAkB,gBAAgB;AAAA,UAClC,mBAAmB,gBAAgB;AAAA,UACnC,SAAS,gBAAgB;AAAA,QAAA;AAAA,MAC3B,CACD;AAAA,aAEM,SAAS;AACR,cAAA,KAAK,wCAAwC,OAAO;AAG5D,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,SAAS;AAAA,QACT,MAAM;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,mBAAmB,sBAAsB,SAAY,oBAAoB;AAAA,UACzE,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,QAAA;AAAA,MAClC,CACD;AAAA,IAAA;AAAA,WAGI,OAAO;AACN,YAAA,MAAM,4BAA4B,KAAK;AAC/C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,6BAA6B;AAAA,EAAA;AAE/D;AAEa,MAAA,mBAAmC,OAAO,KAAK,QAAQ;AAC9D,MAAA;AACF,UAAM,EAAE,YAAY,SAAS,WAAW,IAAI;AAI5C,UAAM,SAAS;AAAA,MACb,QAAQ,CAAC,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK;AAAA,MACxD,UAAU;AAAA,QACR;AAAA,UACE,OAAO;AAAA,UACP,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,QAC5B;AAAA,QACA;AAAA,UACE,OAAO;AAAA,UACP,MAAM,CAAC,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,CAAC;AAAA,QAAA;AAAA,MAC7B;AAAA,IAEJ;AAEA,QAAI,KAAK,MAAM;AAAA,WACR,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACrD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,0BAA0B;AAAA,EAAA;AAE5D;AAEa,MAAA,gBAAgC,OAAO,KAAK,QAAQ;AAC3D,MAAA;AACF,UAAM,EAAE,YAAY,WAAW,SAAS,KAAA,IAAS,IAAI;AAErD,YAAQ,IAAI,gCAAgC;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAGD,UAAM,SAAc,CAAC;AAErB,QAAI,YAAY;AACd,aAAO,aAAa;AAAA,IAAA;AAGtB,QAAI,MAAM;AAER,aAAO,OAAO;AAAA,IAAA,WACL,aAAa,SAAS;AAE/B,aAAO,OAAO;AAAA,QACZ,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IAAA;AAGE,QAAA;AAEF,YAAM,oBAAoB,MAAM,WAAW,KAAK,MAAM,EACnD,KAAK,EAAE,MAAM,GAAI,CAAA,EACjB,KAAK;AAER,cAAQ,IAAI,SAAS,kBAAkB,MAAM,qBAAqB;AAG5D,YAAA,gBAAgB,MAAM,mBAAmB;AAC/C,YAAM,UAAU,IAAI,IAAI,cAAc,IAAI,CAAA,SAAQ,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,CAAC;AAGlE,YAAA,mBAAmB,kBAAkB,IAAI,CAAW,YAAA;AAAA,QACxD,IAAI,OAAO,IAAI,SAAS;AAAA,QACxB,YAAY,OAAO;AAAA,QACnB,MAAM,OAAO;AAAA,QACb,kBAAkB,OAAO;AAAA,QACzB,kBAAkB,OAAO,oBAAoB;AAAA,QAC7C,mBAAmB,OAAO;AAAA,QAC1B,uBAAuB,OAAO,oBAC1B,QAAQ,IAAI,OAAO,iBAAiB,KAAK,OAAO,oBAChD;AAAA,QACJ,SAAS,OAAO,aAAa,OAAO;AAAA,MAAA,EACpC;AAEF,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,OAAO,iBAAiB;AAAA,QACxB,MAAM;AAAA,MAAA,CACP;AAAA,aAEM,SAAS;AACR,cAAA,KAAK,yBAAyB,OAAO;AAG7C,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT,OAAO;AAAA,QACP,MAAM,CAAC;AAAA,QACP,SAAS;AAAA,MAAA,CACV;AAAA,IAAA;AAAA,WAGI,OAAO;AACN,YAAA,MAAM,8BAA8B,KAAK;AAC7C,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,SAAS;AAAA,MACT,OAAO;AAAA,IAAA,CACR;AAAA,EAAA;AAEL;AAGa,MAAA,yBAAyC,OAAO,KAAK,QAAQ;AACpE,MAAA;AACF,UAAM,EAAE,YAAY,SAAS,WAAW,QAAA,IAAY,IAAI;AAGlD,UAAA,EAAE,OAAO,IAAA,IAAQ;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,YAAQ,IAAI,8CAA8C,SAAS,YAAY,SAAS,UAAU,OAAO,EAAE;AACnG,YAAA,IAAI,0BAA0B,MAAM,aAAa,OAAO,IAAI,YAAa,CAAA,EAAE;AAG7E,UAAA,gBAAgB,MAAM,mBAAmB;AAC/C,UAAM,YAAY,cAAc;AAAA,MAAI,CAAC,MAAM,UACzC,0BAA0B,MAAM,KAAK;AAAA,IACvC;AAEA,YAAQ,IAAI,cAAc,UAAU,MAAM,YAAY;AAGtD,QAAI,iBAAwB,CAAC;AAEzB,QAAA;AACF,YAAM,gBAAgB,MAAM,QAAQ,KAAK,CAAE,CAAA,EAAE,KAAK;AAEjC,uBAAA,cAAc,IAAI,CAAY,aAAA;AAAA,QAC7C,IAAI,QAAQ,IAAI,SAAS;AAAA,QACzB,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,QACjB,YAAY,QAAQ;AAAA,QACpB,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,gBAAgB,QAAQ;AAAA,QACxB,UAAU,QAAQ;AAAA,MAAA,EAClB;AAEF,cAAQ,IAAI,SAAS,eAAe,MAAM,4BAA4B;AAElE,UAAA,eAAe,WAAW,GAAG;AAC/B,cAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,yBAAiBA,qBAAoB,CAAC;AACtC,gBAAQ,IAAI,mBAAmB,eAAe,MAAM,uBAAuB;AAAA,MAAA;AAAA,aAEtE,SAAS;AACR,cAAA,KAAK,6DAA6D,OAAO;AACjF,YAAM,EAAE,kBAAAA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AACtD,uBAAiBA,qBAAoB,CAAC;AAAA,IAAA;AAIxC,QAAIC,oBAA0B,CAAC;AAC3B,QAAA;AACF,YAAM,EAAE,iBAAAC,iBAAA,IAAoB,MAAM,OAAO,qBAAW;AAC9C,YAAA,gBAAgB,MAAMA,iBAAgB,KAAK;AAAA,QAC/C,WAAW,EAAE,MAAM,MAAM,eAAe,MAAM,IAAI,YAAc,EAAA;AAAA,MACjE,CAAA,EAAE,KAAK;AAEW,MAAAD,oBAAA,cAAc,IAAI,CAAY,aAAA;AAAA,QAC/C,IAAI,QAAQ;AAAA,QACZ,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,QACjB,eAAe,QAAQ;AAAA,QACvB,aAAa,QAAQ;AAAA,QACrB,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA,MAAA,EAClB;AAEF,cAAQ,IAAI,SAASA,kBAAiB,MAAM,oBAAoB;AAAA,aACzD,SAAS;AACR,cAAA,KAAK,sCAAsC,OAAO;AAAA,IAAA;AAI5D,QAAI,oBAA2B,CAAC;AAC5B,QAAA;AACI,YAAA,kBAAkB,MAAM,WAAW,KAAK;AAAA,QAC5C,MAAM;AAAA,UACJ,MAAM,OAAO,OAAO,YAAY;AAAA,UAChC,MAAM,OAAO,KAAK,YAAY;AAAA,QAAA;AAAA,MAEjC,CAAA,EAAE,KAAK;AAEY,0BAAA,gBAAgB,IAAI,CAAQ,SAAA;AAAA,QAC9C,YAAY,IAAI;AAAA,QAChB,MAAM,IAAI;AAAA,QACV,mBAAmB,IAAI;AAAA,QACvB,kBAAkB,IAAI;AAAA,QACtB,kBAAkB,IAAI;AAAA,MAAA,EACtB;AAEF,cAAQ,IAAI,SAAS,kBAAkB,MAAM,qBAAqB;AAAA,aAC3D,SAAS;AACR,cAAA,KAAK,uCAAuC,OAAO;AAAA,IAAA;AAI7D,UAAM,UAAU,IAAI,IAAI,cAAc,IAAI,CAAA,SAAQ,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,CAAC;AAGxE,UAAM,mBAAmB,UAAU,IAAI,CAAC,aAAa;AAEnD,YAAM,mBAAmB,eAAe;AAAA,QACtC,CAAC,YAAY,QAAQ,eAAe,SAAS;AAAA,MAC/C;AAGA,YAAM,kBAAkB,iBAAiB,OAAO,CAAC,YAAY;AAC3D,cAAM,cAAc,IAAI,KAAK,QAAQ,SAAS;AACxC,cAAA,cAAc,YAAY,QAAQ;AAClC,cAAA,YAAY,MAAM,QAAQ;AAC1B,cAAA,UAAU,IAAI,QAAQ;AACrB,eAAA,eAAe,aAAa,eAAe;AAAA,MAAA,CACnD;AAGD,YAAM,mBAAmBA,kBAAiB;AAAA,QACxC,CAAC,YAAY,QAAQ,eAAe,SAAS;AAAA,MAC/C;AAGA,YAAM,aAAa,gBAAgB;AAAA,QACjC,CAAC,QAAQ,YAAY;AACnB,gBAAM,OAAO,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAC7D,cAAI,CAAC,OAAO,IAAI,EAAU,QAAA,IAAI,IAAI,CAAC;AAC5B,iBAAA,IAAI,EAAE,KAAK,OAAO;AAClB,iBAAA;AAAA,QACT;AAAA,QACA,CAAA;AAAA,MACF;AAGA,YAAM,oBAAoB,iBAAiB;AAAA,QACzC,CAAC,QAAQ,YAAY;AACnB,gBAAM,OAAO,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAC7D,cAAI,CAAC,OAAO,IAAI,EAAU,QAAA,IAAI,IAAI,CAAC;AAC5B,iBAAA,IAAI,EAAE,KAAK,OAAO;AAClB,iBAAA;AAAA,QACT;AAAA,QACA,CAAA;AAAA,MACF;AAGM,YAAA,+BAAe,IAAI;AAAA,QACvB,GAAG,OAAO,KAAK,UAAU;AAAA,QACzB,GAAG,OAAO,KAAK,iBAAiB;AAAA,MAAA,CACjC;AAGD,YAAM,aAAa,MAAM,KAAK,QAAQ,EAAE,IAAI,CAAC,SAAS;AACpD,cAAME,YAAW,WAAW,IAAI,KAAK,CAAC;AACtC,cAAM,WAAW,kBAAkB,IAAI,KAAK,CAAC;AAE7C,cAAM,gBAAgBA,UAAS;AAC/B,cAAM,oBAAoBA,UAAS,OAAO,CAAC,OAAO,YAAY;AAC5D,iBACE,QAAQ,yBAAyB,QAAQ,WAAW,QAAQ,OAAO;AAAA,WAEpE,CAAC;AAGJ,cAAM,iBAAiB,CAAC,GAAGA,SAAQ,EAAE;AAAA,UAAK,CAAC,GAAG,MAC5C,IAAI,KAAK,EAAE,SAAS,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,QAClE;AACM,cAAA,eAAe,eAAe,CAAC;AACrC,cAAM,cAAc,eAAe,eAAe,SAAS,CAAC;AAEtD,cAAA,eAAe,SAAS,CAAC;AAC/B,cAAM,cAAc,SAAS,SAAS,SAAS,CAAC;AAG1C,cAAA,oBAAoB,cAAc,aAAa;AAC/C,cAAA,uBAAuB,cAAc,UAAU,WAAW;AAG1D,cAAA,kBAAkB,aAAa,WAAW;AAChD,cAAM,qBAAqB,aAAa,WAAW,aAAa,UAAU,aAAa,UACnF,YAAY,SAAS,YAAY,UAChC,aAAa,UAAU,WAAW;AAGvC,YAAI,iBAAiB;AACjB,YAAA,gBAAgB,aAAa,SAAS;AACxC,gBAAM,gBAAgB,IAAI,KAAK,YAAY,OAAO,EAAE,QAAQ,IAAI,IAAI,KAAK,aAAa,SAAS,EAAE,QAAQ,MAAM,MAAO,KAAK;AAC1G,2BAAA,KAAK,IAAI,GAAG,YAAY;AAAA,QAAA;AAIrC,cAAA,aAAa,kBAAkB,KAAK,CAAO,QAAA,IAAI,SAAS,QAAQ,IAAI,eAAe,SAAS,EAAE;AAC9F,cAAA,oBAAoB,YAAY,oBAClC,QAAQ,IAAI,WAAW,iBAAiB,KAAK,WAAW,oBACxD;AAEG,eAAA;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,gBAAgB,WAAW,eAAe,QAAQ,CAAC,CAAC;AAAA,UACpD,aAAa;AAAA,UACb,oBAAoB,KAAK,IAAI,GAAG,iBAAiB,iBAAiB;AAAA,UAClE;AAAA,QACF;AAAA,MAAA,CACD;AAGD,YAAM,iBAAiB,gBAAgB,IAAI,CAAC,YAAY;AAC/C,eAAA;AAAA,UACL,cAAc,SAAS;AAAA,UACvB,aAAa,QAAQ,cAAc;AAAA,UACnC,MAAM,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,YAAY;AAAA,UACtD,QAAQ,QAAQ,UAAU;AAAA,UAC1B,eAAe,OAAO,IAAI,KAAK,QAAQ,SAAS,GAAG,OAAO;AAAA,UAC1D,mBAAmB,QAAQ,UAAU,WAAW;AAAA,UAChD,gBAAgB,QAAQ,UACpB,OAAO,IAAI,KAAK,QAAQ,OAAO,GAAG,OAAO,IACzC;AAAA,UACJ,oBAAoB,QAAQ,WAAW,QAAQ,UAAU,aAAa,UAClE,QAAQ,SAAS,YAAY,UAC5B,QAAQ,WAAW,cAAc,KAAK;AAAA,UAC3C,eAAe;AAAA,YACb,QAAQ;AAAA,YACR,QAAQ;AAAA,UACV;AAAA,UACA,YAAY,QAAQ,gBAAgB,cAAc,QAAQ,UAAU,QAAQ,WAAW,cAAc,wBAAwB;AAAA,UAC7H,eACE,QAAQ,gBAAgB,WAAW,SAAS,IACxC,QAAQ,eAAe,UACpB,IAAI,CAAC,aAAa,SAAS,oBAAoB,EAC/C,KAAK,IAAI,IACZ,QAAQ,gBAAgB,yBAAyB,QAAQ,WAAW,cAAc,QAAQ;AAAA,UAChG,eAAe,QAAQ,UAAU;AAAA,UACjC,uBAAuB,QAAQ,yBAAyB;AAAA,UACxD,YAAY,QAAQ,gBAAgB,cAAc;AAAA,UAClD,kBAAkB,QAAQ,gBAAgB,oBAAoB;AAAA,QAChE;AAAA,MAAA,CACD;AAEM,aAAA;AAAA,QACL,YAAY,SAAS;AAAA,QACrB,cAAc,SAAS;AAAA,QACvB,OAAO,SAAS;AAAA,QAChB,OAAO,SAAS;AAAA,QAChB,aAAa,SAAS;AAAA,QACtB,YAAY,SAAS;AAAA,QACrB,aAAa,SAAS;AAAA,QACtB,UAAU,SAAS;AAAA,QACnB,YAAY,WAAW;AAAA,UACrB,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,IAAI,EAAE,QAAQ;AAAA,QAClE;AAAA,QACA,gBAAgB,eAAe;AAAA,UAC7B,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,IAAI,EAAE,QAAQ;AAAA,QAAA;AAAA,MAEpE;AAAA,IAAA,CACD;AAED,YAAQ,IAAI,aAAa,iBAAiB,MAAM,+BAA+B;AAE/E,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,WAAW;AAAA,QACT,OAAO,MAAM,YAAY;AAAA,QACzB,KAAK,IAAI,YAAY;AAAA,QACrB,OAAO;AAAA,MACT;AAAA,MACA,gBAAgB,iBAAiB;AAAA,MACjC,WAAW;AAAA,IAAA,CACZ;AAAA,WACM,OAAO;AACN,YAAA,MAAM,yCAAyC,KAAK;AAC5D,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,yCAAyC;AAAA,EAAA;AAE3E;ACvwCa,MAAA,cAA8B,OAAO,KAAK,QAAQ;AACzD,MAAA;AACF,YAAQ,IAAI,kCAAkC;AAExC,UAAA,EAAE,eAAe,IAAI;AAGrB,UAAA,gBAAgB,MAAM,QAAQ,KAAK,aAAa,EAAE,WAAe,IAAA,EAAE,EAAE,KAAK;AAC1E,UAAA,eAAe,MAAM,eAAe,KAAK,aAAa,EAAE,WAAe,IAAA,EAAE,EAAE,KAAK;AAEtF,YAAQ,IAAI,SAAS,cAAc,MAAM,iBAAiB,aAAa,MAAM,6BAA6B;AAG1G,UAAM,EAAE,UAAUH,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AAEhE,YAAQ,IAAI,SAASA,kBAAiB,MAAM,qBAAqB;AAGjE,QAAI,iBAAiB;AACrB,QAAI,gBAAgB;AAGpB,eAAW,WAAWA,mBAAkB;AAClC,UAAA,cAAc,QAAQ,eAAe,WAAY;AAE/C,YAAA,SAAS,MAAM,QAAQ,QAAQ;AAAA,QACnC,YAAY,QAAQ;AAAA,QACpB,WAAW,QAAQ;AAAA,MAAA,CACpB;AAED,UAAI,CAAC,QAAQ;AACP,YAAA;AACI,gBAAA,aAAa,IAAI,QAAQ;AAAA,YAC7B,YAAY,QAAQ;AAAA,YACpB,UAAU,QAAQ;AAAA,YAClB,WAAW,QAAQ;AAAA,YACnB,SAAS,QAAQ;AAAA,YACjB,YAAY,QAAQ;AAAA,YACpB,OAAO,QAAQ;AAAA,YACf,QAAQ,QAAQ;AAAA,YAChB,mBAAmB,QAAQ;AAAA,YAC3B,QAAQ,QAAQ;AAAA,YAChB,UAAU,QAAQ;AAAA,YAClB,gBAAgB,QAAQ;AAAA,UAAA,CACzB;AAED,gBAAM,WAAW,KAAK;AACtB;AAGA,cAAI,QAAQ,WAAW,eAAe,QAAQ,gBAAgB;AACtD,kBAAA,gBAAgB,MAAM,eAAe,QAAQ;AAAA,cACjD,YAAY,QAAQ;AAAA,cACpB,6BAA6B,QAAQ,eAAe;AAAA,YAAA,CACrD;AAED,gBAAI,CAAC,eAAe;AACZ,oBAAA,aAAa,IAAI,eAAe;AAAA,gBACpC,WAAW,QAAQ,qBAAqB,QAAQ,KAAK,KAAK;AAAA,gBAC1D,YAAY,QAAQ;AAAA,gBACpB,gBAAgB,QAAQ;AAAA,gBACxB,WAAW,QAAQ,WAAW,QAAQ;AAAA,gBACtC,QAAQ,QAAQ;AAAA,gBAChB,UAAU,QAAQ;AAAA,cAAA,CACnB;AAED,oBAAM,WAAW,KAAK;AACtB;AAAA,YAAA;AAAA,UACF;AAAA,iBAEK,WAAW;AAClB,kBAAQ,KAAK,0BAA0B,QAAQ,EAAE,KAAK,SAAS;AAAA,QAAA;AAAA,MACjE;AAAA,IACF;AAII,UAAA,gBAAgB,MAAM,QAAQ,eAAe,aAAa,EAAE,WAAe,IAAA,EAAE;AAC7E,UAAA,eAAe,MAAM,eAAe,eAAe,aAAa,EAAE,WAAe,IAAA,EAAE;AAEzF,UAAM,SAAS;AAAA,MACb,SAAS;AAAA,MACT,SAAS;AAAA,MACT,OAAO;AAAA,QACL,wBAAwB;AAAA,QACxB,uBAAuB;AAAA,QACvB,gBAAgB;AAAA,QAChB,eAAe;AAAA,QACf,YAAY,cAAc;AAAA,MAAA;AAAA,IAE9B;AAEQ,YAAA,IAAI,qBAAqB,MAAM;AACvC,QAAI,KAAK,MAAM;AAAA,WAER,OAAO;AACN,YAAA,MAAM,6BAA6B,KAAK;AAC5C,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,MACP,SAAS,MAAM;AAAA,IAAA,CAChB;AAAA,EAAA;AAEL;AAGa,MAAA,gBAAgC,OAAO,KAAK,QAAQ;AAC3D,MAAA;AACI,UAAA,EAAE,eAAe,IAAI;AAGrB,UAAA,qBAAqB,MAAM,QAAQ,eAAe,aAAa,EAAE,WAAe,IAAA,EAAE;AAClF,UAAA,oBAAoB,MAAM,eAAe,eAAe,aAAa,EAAE,WAAe,IAAA,EAAE;AACxF,UAAA,sBAAsB,MAAM,SAAS,eAAe;AACpD,UAAA,qBAAqB,MAAM,gBAAgB,eAAe,aAAa,EAAE,WAAe,IAAA,EAAE;AAGhG,UAAM,EAAE,UAAUA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AAC1D,UAAA,2BAA2B,aAC7BA,kBAAiB,OAAO,OAAK,EAAE,eAAe,UAAU,IACxDA;AAGE,UAAA,qBAAqB,MAAM,QAAQ,QAAQ,aAAa,EAAE,WAAe,IAAA,EAAE,EAAE,KAAK;AAClF,UAAA,qBAAqB,MAAM,eAAe,QAAQ,aAAa,EAAE,WAAe,IAAA,EAAE,EAAE,KAAK;AAE/F,UAAM,SAAS;AAAA,MACb,YAAY,cAAc;AAAA,MAC1B,SAAS;AAAA,QACP,UAAU;AAAA,QACV,SAAS;AAAA,QACT,WAAW;AAAA,QACX,kBAAkB;AAAA,QAClB,eAAe,qBAAqB;AAAA,UAClC,IAAI,mBAAmB;AAAA,UACvB,YAAY,mBAAmB;AAAA,UAC/B,QAAQ,mBAAmB;AAAA,UAC3B,YAAY,CAAC,CAAC,mBAAmB;AAAA,UACjC,QAAQ,mBAAmB;AAAA,QAAA,IACzB;AAAA,QACJ,eAAe,qBAAqB;AAAA,UAClC,IAAI,mBAAmB;AAAA,UACvB,YAAY,mBAAmB;AAAA,UAC/B,cAAc,mBAAmB,gBAAgB,WAAW,SAAS;AAAA,UACrE,YAAY,mBAAmB,gBAAgB,YAAY,UAAU,GAAG,GAAG;AAAA,QAAA,IACzE;AAAA,MACN;AAAA,MACA,UAAU;AAAA,QACR,UAAU,yBAAyB;AAAA,QACnC,eAAe,yBAAyB,CAAC,IAAI;AAAA,UAC3C,IAAI,yBAAyB,CAAC,EAAE;AAAA,UAChC,YAAY,yBAAyB,CAAC,EAAE;AAAA,UACxC,QAAQ,yBAAyB,CAAC,EAAE;AAAA,UACpC,YAAY,CAAC,CAAC,yBAAyB,CAAC,EAAE;AAAA,QAAA,IACxC;AAAA,MAAA;AAAA,IAER;AAEA,QAAI,KAAK,MAAM;AAAA,WAER,OAAO;AACN,YAAA,MAAM,8BAA8B,KAAK;AAC7C,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,MACP,SAAS,MAAM;AAAA,IAAA,CAChB;AAAA,EAAA;AAEL;ACvKa,MAAA,oBAAoC,OAAO,KAAK,QAAQ;AAC/D,MAAA;AACI,UAAA,EAAE,eAAe,IAAI;AAEnB,YAAA,IAAI,gCAAgC,UAAU,EAAE;AAGlD,UAAA,gBAAgB,MAAM,QAAQ,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK;AAC9D,YAAQ,IAAI,SAAS,cAAc,MAAM,qCAAqC,UAAU,EAAE;AAGpF,UAAA,eAAe,MAAM,eAAe,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK;AACpE,YAAQ,IAAI,SAAS,aAAa,MAAM,4CAA4C,UAAU,EAAE;AAGhG,UAAM,EAAE,UAAUA,kBAAqB,IAAA,MAAM,QAAmB,QAAA,EAAA,KAAA,MAAA,QAAA;AAChE,UAAM,mBAAmBA,kBAAiB,OAAO,CAAK,MAAA,EAAE,eAAe,UAAU;AACjF,YAAQ,IAAI,SAAS,iBAAiB,MAAM,oCAAoC,UAAU,EAAE;AAE5F,UAAM,YAAY;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,QACP,UAAU;AAAA,UACR,OAAO,cAAc;AAAA,UACrB,MAAM,cAAc,IAAI,CAAM,OAAA;AAAA,YAC5B,IAAI,EAAE,IAAI,SAAS;AAAA,YACnB,WAAW,EAAE;AAAA,YACb,SAAS,EAAE;AAAA,YACX,QAAQ,EAAE;AAAA,YACV,YAAY,EAAE;AAAA,YACd,QAAQ,EAAE;AAAA,YACV,YAAY,CAAC,CAAC,EAAE;AAAA,YAChB,kBAAkB,EAAE,gBAAgB,WAAW,UAAU;AAAA,UAAA,EACzD;AAAA,QACJ;AAAA,QACA,SAAS;AAAA,UACP,OAAO,aAAa;AAAA,UACpB,MAAM,aAAa,IAAI,CAAM,OAAA;AAAA,YAC3B,IAAI,EAAE,IAAI,SAAS;AAAA,YACnB,WAAW,EAAE;AAAA,YACb,WAAW,EAAE;AAAA,YACb,QAAQ,EAAE;AAAA,YACV,YAAY,CAAC,CAAC,EAAE;AAAA,YAChB,YAAY,EAAE,gBAAgB,YAAY,UAAU,GAAG,GAAG;AAAA,YAC1D,WAAW,EAAE,gBAAgB,WAAW,UAAU;AAAA,YAClD,eAAe,EAAE,gBAAgB,WAAW,IAAI,CAAK,MAAA,EAAE,oBAAoB,KAAK,CAAA;AAAA,UAAC,EACjF;AAAA,QAAA;AAAA,MAEN;AAAA,MACA,UAAU;AAAA,QACR,UAAU;AAAA,UACR,OAAO,iBAAiB;AAAA,UACxB,MAAM,iBAAiB,IAAI,CAAM,OAAA;AAAA,YAC/B,IAAI,EAAE;AAAA,YACN,WAAW,EAAE;AAAA,YACb,SAAS,EAAE;AAAA,YACX,QAAQ,EAAE;AAAA,YACV,YAAY,EAAE;AAAA,YACd,QAAQ,EAAE;AAAA,YACV,YAAY,CAAC,CAAC,EAAE;AAAA,UAAA,EAChB;AAAA,QAAA;AAAA,MAEN;AAAA,MACA,iBAAiB,CAAA;AAAA,IACnB;AAGA,QAAI,cAAc,WAAW,KAAK,iBAAiB,SAAS,GAAG;AACnD,gBAAA,gBAAgB,KAAK,6DAA6D;AAAA,IAAA;AAG1F,QAAA,cAAc,SAAS,aAAa,QAAQ;AACpC,gBAAA,gBAAgB,KAAK,yFAAyF;AAAA,IAAA;AAGtH,QAAA,aAAa,WAAW,GAAG;AACnB,gBAAA,gBAAgB,KAAK,kFAAkF;AAAA,IAAA;AAGnH,YAAQ,IAAI,wBAAwB,KAAK,UAAU,WAAW,MAAM,CAAC,CAAC;AAEtE,QAAI,KAAK,SAAS;AAAA,WAEX,OAAO;AACN,YAAA,MAAM,4BAA4B,KAAK;AAC3C,QAAA,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gBAAgB,SAAS,MAAM,SAAS;AAAA,EAAA;AAE1E;ACtFA,IAAI,oBAA2B,CAAC;AAInB,MAAA,oBAAoC,OAAO,KAAK,QAAQ;AAC/D,MAAA;AACI,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,QACN,IAAI;AAEA,YAAA,IAAI,wCAAwC,EAAE,YAAY,mBAAmB,QAAQ,WAAW,SAAS;AAE3G,UAAA,UAAU,SAAS,IAAc;AACjC,UAAA,WAAW,SAAS,KAAe;AACnC,UAAA,QAAQ,UAAU,KAAK;AAEzB,QAAA;AAEF,YAAM,QAAa,CAAC;AAEpB,UAAI,YAAY;AACd,cAAM,aAAa;AAAA,MAAA;AAGrB,UAAI,mBAAmB;AACrB,cAAM,oBAAoB;AAAA,MAAA;AAG5B,UAAI,QAAQ;AACV,cAAM,SAAS;AAAA,MAAA;AAGjB,UAAI,aAAa,SAAS;AACxB,cAAM,cAAc,CAAC;AACrB,YAAI,WAAW;AACb,gBAAM,YAAY,OAAO,IAAI,KAAK,SAAmB,EAAE,YAAY;AAAA,QAAA;AAErE,YAAI,SAAS;AACX,gBAAM,YAAY,OAAO,IAAI,KAAK,OAAiB,EAAE,YAAY;AAAA,QAAA;AAAA,MACnE;AAGF,YAAM,YAAY,MAAM,cAAc,KAAK,KAAK,EAC7C,KAAK,EAAE,aAAa,GAAI,CAAA,EACxB,KAAK,IAAI,EACT,MAAM,QAAQ,EACd,KAAK;AAER,YAAM,QAAQ,MAAM,cAAc,eAAe,KAAK;AAEtD,YAAM,WAAW;AAAA,QACf;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,YAAY,KAAK,KAAK,QAAQ,QAAQ;AAAA,MACxC;AAEA,cAAQ,IAAI,SAAS,UAAU,MAAM,+BAA+B;AACpE,UAAI,KAAK,QAAQ;AAAA,aACV,YAAY;AACX,cAAA,MAAM,4DAA4D,UAAU;AAGhF,UAAA,oBAAoB,CAAC,GAAG,iBAAiB;AAG7C,UAAI,YAAY;AACd,4BAAoB,kBAAkB,OAAO,CAAK,MAAA,EAAE,eAAe,UAAU;AAAA,MAAA;AAG/E,UAAI,mBAAmB;AACrB,4BAAoB,kBAAkB,OAAO,CAAK,MAAA,EAAE,sBAAsB,iBAAiB;AAAA,MAAA;AAG7F,UAAI,QAAQ;AACV,4BAAoB,kBAAkB,OAAO,CAAK,MAAA,EAAE,WAAW,MAAM;AAAA,MAAA;AAGvE,UAAI,aAAa,SAAS;AACJ,4BAAA,kBAAkB,OAAO,CAAK,MAAA;AAChD,gBAAM,cAAc,IAAI,KAAK,EAAE,WAAW;AAC1C,cAAI,aAAa,cAAc,IAAI,KAAK,SAAmB,EAAU,QAAA;AACrE,cAAI,WAAW,cAAc,IAAI,KAAK,OAAiB,EAAU,QAAA;AAC1D,iBAAA;AAAA,QAAA,CACR;AAAA,MAAA;AAIH,wBAAkB,KAAK,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,WAAW,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,WAAW,EAAE,SAAS;AAGtG,YAAM,QAAQ,kBAAkB;AAChC,YAAM,qBAAqB,kBAAkB,MAAM,MAAM,OAAO,QAAQ;AAExE,YAAM,WAAW;AAAA,QACf,WAAW;AAAA,QACX;AAAA,QACA,MAAM;AAAA,QACN,YAAY,KAAK,KAAK,QAAQ,QAAQ;AAAA,MACxC;AAEA,cAAQ,IAAI,SAAS,mBAAmB,MAAM,iCAAiC,KAAK,SAAS;AAC7F,UAAI,KAAK,QAAQ;AAAA,IAAA;AAAA,WAEZ,OAAO;AACN,YAAA,MAAM,mCAAmC,KAAK;AACtD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAGa,MAAA,mBAAmC,OAAO,KAAK,QAAQ;AAC9D,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AAEf,QAAA;AAEF,YAAM,WAAW,MAAM,cAAc,QAAQ,EAAE,IAAI;AAEnD,UAAI,UAAU;AACJ,gBAAA,IAAI,oCAAoC,SAAS,EAAE;AACpD,eAAA,IAAI,KAAK,QAAQ;AAAA,MAAA;AAAA,aAEnB,YAAY;AACX,cAAA,MAAM,qDAAqD,UAAU;AAAA,IAAA;AAI/E,UAAM,iBAAiB,kBAAkB,KAAK,CAAK,MAAA,EAAE,OAAO,EAAE;AAE9D,QAAI,gBAAgB;AACV,cAAA,IAAI,mCAAmC,eAAe,EAAE;AACzD,aAAA,IAAI,KAAK,cAAc;AAAA,IAAA;AAGzB,WAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,WAC1D,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACrD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,kCAAkC;AAAA,EAAA;AAEpE;AAGa,MAAA,sBAAsC,OAAO,KAAK,QAAQ;AACjE,MAAA;AACI,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAAG;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE,IAAI;AAEJ,QAAA,CAAC,cAAc,CAAC,gBAAgB,CAAC,SAAS,CAAC,iBAAiB,CAAC,SAAS,CAAC,WAAW;AACpF,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAIH,UAAM,aAAa,YAAY,KAAK,IAAA,CAAK,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAGpF,UAAM,mBAAmB;AAAA,MACvB,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,kBAAkB,MAAM;AAAA,MACxB,eAAeA,YAAWA,UAAS,SAAS;AAAA,IAC9C;AAEA,UAAM,eAAe;AAAA,MACnB,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAAA,MACA;AAAA,MACA,eAAe;AAAA,QACb,GAAG;AAAA,QACH,WAAW,cAAc,cAAiB,oBAAA,QAAO,YAAY;AAAA,MAC/D;AAAA,MACA,aAAa,cAAc;AAAA,QACzB,GAAG;AAAA,QACH,WAAW,YAAY,cAAiB,oBAAA,QAAO,YAAY;AAAA,MACzD,IAAA;AAAA,MACJ,OAAO,MAAM,IAAI,CAAC,WAAgB;AAAA,QAChC,GAAG;AAAA,QACH,WAAW,MAAM,cAAiB,oBAAA,QAAO,YAAY;AAAA,MAAA,EACrD;AAAA,MACF,UAAUA,aAAY,CAAC;AAAA,MACvB,eAAe,iBAAiB;AAAA,MAChC;AAAA,MACA,QAAQ,UAAU;AAAA,MAClB;AAAA,MACA;AAAA,IACF;AAEI,QAAA;AAEI,YAAA,cAAc,IAAI,cAAc,YAAY;AAC5C,YAAA,gBAAgB,MAAM,YAAY,KAAK;AAErC,cAAA,IAAI,sCAAsC,cAAc,EAAE;AAClE,UAAI,OAAO,GAAG,EAAE,KAAK,aAAa;AAAA,aAC3B,YAAY;AACX,cAAA,MAAM,qDAAqD,UAAU;AAG7E,wBAAkB,KAAK,YAAY;AAE3B,cAAA,IAAI,qCAAqC,aAAa,EAAE;AAChE,UAAI,OAAO,GAAG,EAAE,KAAK,YAAY;AAAA,IAAA;AAAA,WAE5B,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACrD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAGa,MAAA,sBAAsC,OAAO,KAAK,QAAQ;AACjE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,UAAM,UAAU,IAAI;AACpB,QAAI,UAAU;AAEV,QAAA;AAEI,YAAA,kBAAkB,MAAM,cAAc;AAAA,QAC1C,EAAE,GAAG;AAAA,QACL,EAAE,MAAM,QAAQ;AAAA,QAChB,EAAE,KAAK,MAAM,eAAe,KAAK;AAAA,MACnC;AAEA,UAAI,iBAAiB;AACX,gBAAA,IAAI,sCAAsC,gBAAgB,EAAE;AAC7D,eAAA,IAAI,KAAK,eAAe;AAAA,MAAA;AAAA,aAE1B,YAAY;AACX,cAAA,MAAM,sDAAsD,UAAU;AAAA,IAAA;AAIhF,UAAM,cAAc,kBAAkB,UAAU,CAAK,MAAA,EAAE,OAAO,EAAE;AAChE,QAAI,gBAAgB,IAAI;AACJ,wBAAA,WAAW,IAAI,EAAE,GAAG,kBAAkB,WAAW,GAAG,GAAG,QAAQ;AACjF,cAAQ,IAAI,qCAAqC,kBAAkB,WAAW,EAAE,EAAE;AAClF,aAAO,IAAI,KAAK,kBAAkB,WAAW,CAAC;AAAA,IAAA;AAGzC,WAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,WAC1D,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACrD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAGa,MAAA,sBAAsC,OAAO,KAAK,QAAQ;AACjE,MAAA;AACI,UAAA,EAAE,OAAO,IAAI;AACnB,QAAI,UAAU;AAEV,QAAA;AAEF,YAAM,kBAAkB,MAAM,cAAc,iBAAiB,EAAE,IAAI;AACnE,UAAI,iBAAiB;AACX,gBAAA,IAAI,wCAAwC,gBAAgB,EAAE;AAC5D,kBAAA;AAAA,MAAA;AAAA,aAEL,YAAY;AACX,cAAA,MAAM,sDAAsD,UAAU;AAAA,IAAA;AAIhF,UAAM,cAAc,kBAAkB,UAAU,CAAK,MAAA,EAAE,OAAO,EAAE;AAChE,QAAI,gBAAgB,IAAI;AACtB,YAAM,kBAAkB,kBAAkB,OAAO,aAAa,CAAC,EAAE,CAAC;AAC1D,cAAA,IAAI,uCAAuC,gBAAgB,EAAE;AAC3D,gBAAA;AAAA,IAAA;AAGZ,QAAI,CAAC,SAAS;AACL,aAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,4BAA4B;AAAA,IAAA;AAG/D,QAAA,OAAO,GAAG,EAAE,KAAK;AAAA,WACd,OAAO;AACN,YAAA,MAAM,kCAAkC,KAAK;AACrD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,mCAAmC;AAAA,EAAA;AAErE;AAGa,MAAA,uBAAuC,OAAO,KAAK,QAAQ;AAClE,MAAA;AACI,UAAA,EAAE,eAAe,IAAI;AAC3B,UAAM,EAAE,OAAO,GAAG,QAAQ,GAAA,IAAO,IAAI;AAE/B,UAAA,UAAU,SAAS,IAAc;AACjC,UAAA,WAAW,SAAS,KAAe;AACnC,UAAA,QAAQ,UAAU,KAAK;AAEzB,QAAA;AAEI,YAAA,YAAY,MAAM,cAAc,KAAK,EAAE,WAAY,CAAA,EACtD,KAAK,EAAE,aAAa,GAAG,CAAC,EACxB,KAAK,IAAI,EACT,MAAM,QAAQ,EACd,KAAK;AAER,YAAM,QAAQ,MAAM,cAAc,eAAe,EAAE,YAAY;AAE/D,YAAM,WAAW;AAAA,QACf;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,YAAY,KAAK,KAAK,QAAQ,QAAQ;AAAA,MACxC;AAEA,cAAQ,IAAI,SAAS,UAAU,MAAM,2BAA2B,UAAU,eAAe;AACzF,UAAI,KAAK,QAAQ;AAAA,aACV,YAAY;AACX,cAAA,MAAM,4DAA4D,UAAU;AAGpF,YAAM,oBAAoB,kBAAkB,OAAO,CAAK,MAAA,EAAE,eAAe,UAAU;AAGnF,wBAAkB,KAAK,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,WAAW,EAAE,QAAA,IAAY,IAAI,KAAK,EAAE,WAAW,EAAE,SAAS;AAGtG,YAAM,QAAQ,kBAAkB;AAChC,YAAM,qBAAqB,kBAAkB,MAAM,MAAM,OAAO,QAAQ;AAExE,YAAM,WAAW;AAAA,QACf,WAAW;AAAA,QACX;AAAA,QACA,MAAM;AAAA,QACN,YAAY,KAAK,KAAK,QAAQ,QAAQ;AAAA,MACxC;AAEQ,cAAA,IAAI,SAAS,mBAAmB,MAAM,2BAA2B,UAAU,iBAAiB,KAAK,SAAS;AAClH,UAAI,KAAK,QAAQ;AAAA,IAAA;AAAA,WAEZ,OAAO;AACN,YAAA,MAAM,sCAAsC,KAAK;AACzD,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,sCAAsC;AAAA,EAAA;AAExE;AC5Wa,MAAA,uBAAuC,OAAO,KAAK,QAAQ;AAClE,MAAA;AACF,UAAM,EAAE,QAAQ,eAAe,IAAI,IAAI;AAEjC,UAAA,aAAc,IAAI,UAAW,IAAI,OAAe,MAAQ,IAAI,QAAQ,IAAI,KAAK;AAE/E,QAAA,CAAC,cAAc,CAAC,QAAQ;AAC1B,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGH,YAAQ,IAAI,8BAA8B;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAGK,UAAA,iBAAiB,QAAQ,IAAI,0BAA0B;AAC7D,UAAM,UAAU,eAAe,QAAQ,eAAe,EAAE;AAGxD,UAAM,YAAY,GAAG,OAAO,mBAAmB,UAAU;AAEzD,UAAM,gBAAgB;AAAA,MACpB,eAAe;AAAA,MACf;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,YAAQ,IAAI,wDAAwD;AAAA,MAClE,KAAK;AAAA,MACL,SAAS;AAAA,IAAA,CACV;AAGG,QAAA;AACA,QAAA;AACF,iBAAW,MAAM,MAAM,IAAI,WAAW,eAAe;AAAA,QACnD,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,SAAS;AAAA,MAAA,CACV;AAAA,aACM,KAAK;AACZ,cAAQ,KAAK,oEAAoE,KAAK,WAAW,GAAG;AAE9F,YAAA,cAAc,GAAG,OAAO;AAC9B,YAAM,kBAAkB;AAAA,QACtB,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AACA,cAAQ,IAAI,8CAA8C,EAAE,KAAK,aAAa,SAAS,iBAAiB;AACxG,iBAAW,MAAM,MAAM,IAAI,aAAa,iBAAiB;AAAA,QACvD,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,SAAS;AAAA,MAAA,CACV;AAAA,IAAA;AAGH,QAAI,SAAS,WAAW,OAAO,SAAS,KAAK,SAAS;AAC5C,cAAA,IAAI,0CAA0C,SAAS,IAAI;AACnE,aAAO,IAAI,KAAK;AAAA,QACd,SAAS;AAAA,QACT,MAAM,SAAS;AAAA,MAAA,CAChB;AAAA,IAAA,OACI;AACG,cAAA,MAAM,sCAAsC,SAAS,IAAI;AACjE,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,QACP,SAAS,SAAS;AAAA,MAAA,CACnB;AAAA,IAAA;AAAA,WAEI,OAAO;AACN,YAAA,MAAM,oCAAoC,KAAK;AAEnD,QAAA,MAAM,aAAa,KAAK,GAAG;AAC7B,YAAM,eAAe,MAAM,UAAU,MAAM,WAAW,MAAM;AAC5D,aAAO,IAAI,OAAO,MAAM,UAAU,UAAU,GAAG,EAAE,KAAK;AAAA,QACpD,OAAO;AAAA,QACP,SAAS;AAAA,MAAA,CACV;AAAA,IAAA;AAGH,WAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MAC1B,OAAO;AAAA,MACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,IAAA,CACnD;AAAA,EAAA;AAEL;AAGa,MAAA,qBAAqC,OAAO,KAAK,QAAQ;AAChE,MAAA;AACI,UAAA,EAAE,WAAW,IAAI;AAEvB,QAAI,CAAC,QAAQ;AACX,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAGK,YAAA,IAAI,wCAAwC,MAAM;AAEpD,UAAA,iBAAiB,QAAQ,IAAI,0BAA0B;AAC7D,UAAM,UAAU,eAAe,QAAQ,eAAe,EAAE;AACxD,UAAM,MAAM,GAAG,OAAO,8BAA8B,MAAM;AAElD,YAAA,IAAI,+BAA+B,GAAG;AAE9C,UAAM,WAAW,MAAM,MAAM,IAAI,KAAK;AAAA,MACpC,SAAS;AAAA,IAAA,CACV;AAED,QAAI,SAAS,WAAW,OAAO,SAAS,MAAM;AAC5C,cAAQ,IAAI,WAAW,SAAS,KAAK,UAAU,CAAC,oBAAoB;AAC7D,aAAA,IAAI,KAAK,SAAS,IAAI;AAAA,IAAA,OACxB;AACG,cAAA,MAAM,sCAAsC,SAAS,IAAI;AACjE,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,QACP,SAAS,SAAS;AAAA,MAAA,CACnB;AAAA,IAAA;AAAA,WAEI,OAAO;AACN,YAAA,MAAM,qCAAqC,KAAK;AAEpD,QAAA,MAAM,aAAa,KAAK,GAAG;AAC7B,YAAM,eAAe,MAAM,UAAU,MAAM,WAAW,MAAM;AAC5D,aAAO,IAAI,OAAO,MAAM,UAAU,UAAU,GAAG,EAAE,KAAK;AAAA,QACpD,OAAO;AAAA,QACP,SAAS;AAAA,MAAA,CACV;AAAA,IAAA;AAGH,WAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MAC1B,OAAO;AAAA,MACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,IAAA,CACnD;AAAA,EAAA;AAEL;AChFA,MAAM,aAAa,cAAc,YAAY,GAAG;AAChD,MAAMC,cAAY,KAAK,QAAQ,UAAU;AAElC,SAAS,eAAe;AAC7B,QAAMC,OAAMC,iBAAQ;AAGpB,QAAM,qBAAqB,YAAY;AACjC,QAAA;AACI,YAAA,KAAK,SAAS,YAAY;AAChC,YAAM,GAAG,QAAQ;AAAA,aACV,OAAO;AACN,cAAA,MAAM,kCAAkC,KAAK;AAAA,IAAA;AAAA,EAGzD;AAGmB,qBAAA;AAGf,EAAAD,KAAA,IAAI,MAAM;AACV,EAAAA,KAAA,IAAIC,iBAAQ,MAAM;AACtB,EAAAD,KAAI,IAAIC,iBAAQ,WAAW,EAAE,UAAU,KAAA,CAAM,CAAC;AAG9C,EAAAD,KAAI,IAAI,CAAC,KAAK,KAAK,SAAS;AAC1B,YAAQ,IAAI,GAAG,IAAI,MAAM,IAAI,IAAI,IAAI,OAAU,oBAAA,KAAO,GAAA,YAAA,CAAa,EAAE;AAChE,SAAA;AAAA,EAAA,CACN;AAGD,EAAAA,KAAI,IAAI,aAAa,CAAC,MAAM,QAAQ;AAClC,YAAQ,IAAI,4BAA4B;AACxC,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,QAAQ;AAAA,IAAA,CACT;AAAA,EAAA,CACF;AAEG,EAAAA,KAAA,IAAI,aAAa,UAAU;AAG/B,EAAAA,KAAI,IAAI,wBAAwB,CAAC,MAAM,QAAQ;AAC7C,YAAQ,IAAI,8BAA8B;AAC1C,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,QAAQ;AAAA,IAAA,CACT;AAAA,EAAA,CACF;AAGG,EAAAA,KAAA,IAAI,kBAAkB,YAAY;AAClC,EAAAA,KAAA,KAAK,kBAAkB,cAAc;AACrC,EAAAA,KAAA,IAAI,sBAAsB,WAAW;AACrC,EAAAA,KAAA,IAAI,sBAAsB,cAAc;AACxC,EAAAA,KAAA,OAAO,sBAAsB,cAAc;AAC3C,EAAAA,KAAA,IAAI,+BAA+B,sBAAsB;AACzD,EAAAA,KAAA,IAAI,6BAA6B,oBAAoB;AACrD,EAAAA,KAAA,KAAK,oCAAoC,wBAAwB;AACjE,EAAAA,KAAA,KAAK,8BAA8B,kBAAkB;AAGrD,EAAAA,KAAA,IAAI,iBAAiB,WAAW;AAChC,EAAAA,KAAA,KAAK,iBAAiB,aAAa;AACnC,EAAAA,KAAA,IAAI,wBAAwB,gBAAgB;AAC5C,EAAAA,KAAA,IAAI,qBAAqB,UAAU;AACnC,EAAAA,KAAA,IAAI,qBAAqB,aAAa;AACtC,EAAAA,KAAA,IAAI,8BAA8B,qBAAqB;AACvD,EAAAA,KAAA,IAAI,qCAAqC,8BAA8B;AACvE,EAAAA,KAAA,OAAO,qBAAqB,aAAa;AAGzC,EAAAA,KAAA,IAAI,0BAA0B,mBAAmB;AACjD,EAAAA,KAAA,KAAK,0BAA0B,qBAAqB;AACpD,EAAAA,KAAA,IAAI,8BAA8B,kBAAkB;AACpD,EAAAA,KAAA,IAAI,8BAA8B,qBAAqB;AACvD,EAAAA,KAAA,OAAO,8BAA8B,qBAAqB;AAC1D,EAAAA,KAAA,KAAK,uCAAuC,kBAAkB;AAG9D,EAAAA,KAAA,IAAI,wBAAwB,iBAAiB;AAC7C,EAAAA,KAAA,KAAK,wBAAwB,mBAAmB;AAChD,EAAAA,KAAA,KAAK,mCAAmC,2BAA2B;AAEnE,EAAAA,KAAA,IAAI,uCAAuC,0BAA0B;AAErE,EAAAA,KAAA,IAAI,mCAAmC,0BAA0B;AAGjE,EAAAA,KAAA,IAAI,4BAA4B,oBAAoB;AACpD,EAAAA,KAAA,IAAI,+CAA+C,kBAAkB;AACrE,EAAAA,KAAA,IAAI,wCAAwC,sBAAsB;AAClE,EAAAA,KAAA,IAAI,uCAAuC,cAAc;AACzD,EAAAA,KAAA,KAAK,kCAAkC,cAAc;AACzD,EAAAA,KAAI,IAAI,6BAA6B,CAAC,KAAK,KAAK,SAAS;AACvD,YAAQ,IAAI,4BAA4B;AAAA,MACtC,OAAO,IAAI;AAAA,MACX,KAAK,IAAI;AAAA,MACT,QAAQ,IAAI;AAAA,IAAA,CACb;AACa,kBAAA,KAAK,GAAS;AAAA,EAAA,CAC7B;AACG,EAAAA,KAAA,IAAI,yBAAyB,gBAAgB;AAG7C,EAAAA,KAAA,KAAK,kBAAkB,WAAW;AAClC,EAAAA,KAAA,IAAI,oBAAoB,aAAa;AAGrC,EAAAA,KAAA,IAAI,mCAAmC,iBAAiB;AAGxD,EAAAA,KAAA,IAAI,wBAAwB,iBAAiB;AAC7C,EAAAA,KAAA,KAAK,wBAAwB,mBAAmB;AAChD,EAAAA,KAAA,IAAI,4BAA4B,gBAAgB;AAChD,EAAAA,KAAA,IAAI,4BAA4B,mBAAmB;AACnD,EAAAA,KAAA,OAAO,4BAA4B,mBAAmB;AACtD,EAAAA,KAAA,IAAI,wCAAwC,oBAAoB;AAGhE,EAAAA,KAAA,IAAI,mBAAmB,kBAAkB;AACzC,EAAAA,KAAA,IAAI,uBAAuB,oBAAoB;AAGR;AACzC,UAAME,YAAW,KAAK,KAAKH,aAAW,QAAQ;AAEtC,YAAA,IAAI,iCAAiCG,SAAQ;AAGrD,IAAAF,KAAI,IAAIC,iBAAQ,OAAOC,SAAQ,CAAC;AAGhC,IAAAF,KAAI,IAAI,KAAK,CAAC,KAAK,QAAQ;AAEzB,UAAI,IAAI,KAAK,WAAW,OAAO,GAAG;AACzB,eAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,0BAA0B;AAAA,MAAA;AAGjE,YAAM,YAAY,KAAK,KAAKE,WAAU,YAAY;AAC1C,cAAA,IAAI,8BAA8B,IAAI,IAAI;AAClD,UAAI,SAAS,SAAS;AAAA,IAAA,CACvB;AAAA,EAAA;AAGI,SAAAF;AACT;ACnNA,MAAM,MAAM,aAAa;AACzB,MAAM,OAAO,QAAQ,IAAI,QAAQ;AAGjC,MAAM,YAAY,YAAY;AAC9B,MAAM,WAAW,KAAK,KAAK,WAAW,QAAQ;AAG9C,IAAI,IAAI,QAAQ,OAAO,QAAQ,CAAC;AAGhC,IAAI,IAAI,KAAK,CAAC,KAAK,QAAQ;AAErB,MAAA,IAAI,KAAK,WAAW,OAAO,KAAK,IAAI,KAAK,WAAW,SAAS,GAAG;AAC3D,WAAA,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,0BAA0B;AAAA,EAAA;AAGjE,MAAI,SAAS,KAAK,KAAK,UAAU,YAAY,CAAC;AAChD,CAAC;AAED,IAAI,OAAO,MAAM,MAAM;AACb,UAAA,IAAI,4CAA4C,IAAI,EAAE;AACtD,UAAA,IAAI,iCAAiC,IAAI,EAAE;AAC3C,UAAA,IAAI,4BAA4B,IAAI,MAAM;AACpD,CAAC;AAGD,QAAQ,GAAG,WAAW,MAAM;AAC1B,UAAQ,IAAI,+CAA+C;AAC3D,UAAQ,KAAK,CAAC;AAChB,CAAC;AAED,QAAQ,GAAG,UAAU,MAAM;AACzB,UAAQ,IAAI,8CAA8C;AAC1D,UAAQ,KAAK,CAAC;AAChB,CAAC;"}