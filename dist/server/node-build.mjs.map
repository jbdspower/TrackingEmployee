{"version":3,"file":"node-build.mjs","sources":["../../server/config/database-indexes.ts","../../server/config/database.ts","../../server/routes/demo.ts","../../server/models/Meeting.ts","../../server/models/MeetingHistory.ts","../../server/models/Attendance.ts","../../server/models/TrackingSession.ts","../../server/models/Employee.ts","../../server/models/RouteSnapshot.ts","../../server/routes/employees.ts","../../server/routes/meetings.ts","../../server/routes/tracking.ts","../../server/services/cache.service.js","../../server/routes/analytics.ts","../../server/routes/data-sync.ts","../../server/routes/debug.ts","../../server/routes/route-snapshots.ts","../../server/routes/follow-ups.ts","../../server/index.ts","../../server/node-build.ts"],"sourcesContent":["// config/database-indexes.ts\nimport mongoose from 'mongoose';\n\nasync function createIndexes() {\n  try {\n    console.log('üîÑ Creating database indexes...');\n    \n    // Get all collections\n    const db = mongoose.connection.db;\n    if (!db) {\n      console.log('‚ùå No database connection available');\n      return;\n    }\n\n    // Create indexes for meetings collection\n    await db.collection('meetings').createIndex({ employeeId: 1 });\n    await db.collection('meetings').createIndex({ startTime: -1 });\n    await db.collection('meetings').createIndex({ employeeId: 1, startTime: -1 });\n    await db.collection('meetings').createIndex({ startTime: -1, employeeId: 1 });\n    await db.collection('meetings').createIndex({ leadId: 1 });\n    await db.collection('meetings').createIndex({ status: 1 });\n    await db.collection('meetings').createIndex({ employeeId: 1, status: 1, startTime: -1 });\n    await db.collection('meetings').createIndex({ followUpId: 1, status: 1, startTime: -1 });\n    await db.collection('meetings').createIndex({ employeeId: 1, clientName: 1, startTime: -1 });\n    await db.collection('meetings').createIndex({ employeeId: 1, meetingStatus: 1, startTime: -1 });\n    console.log('‚úÖ Meeting indexes created');\n    \n    // Create indexes for attendance collection (actual collection: \"attendance\")\n    await db.collection('attendance').createIndex({ employeeId: 1, date: 1 }, { unique: true });\n    await db.collection('attendance').createIndex({ date: 1 });\n    await db.collection('attendance').createIndex({ employeeId: 1 });\n    await db.collection('attendance').createIndex({ employeeId: 1, date: -1 });\n    await db.collection('attendance').createIndex({ date: -1, employeeId: 1 });\n    console.log('‚úÖ Attendance indexes created');\n    \n    // Create indexes for tracking sessions collection (actual collection: \"tracking_sessions\")\n    await db.collection('tracking_sessions').createIndex({ employeeId: 1, startTime: -1 });\n    await db.collection('tracking_sessions').createIndex({ startTime: -1 });\n    await db.collection('tracking_sessions').createIndex({ startTime: -1, employeeId: 1 });\n    await db.collection('tracking_sessions').createIndex({ status: 1 });\n    await db.collection('tracking_sessions').createIndex({ employeeId: 1, status: 1, startTime: -1 });\n    console.log('‚úÖ TrackingSession indexes created');\n\n    // Create indexes for meeting history collection (actual collection: \"meeting_history\")\n    await db.collection('meeting_history').createIndex({ employeeId: 1, timestamp: -1 });\n    await db.collection('meeting_history').createIndex({ leadId: 1, timestamp: -1 });\n    await db.collection('meeting_history').createIndex({ sessionId: 1, timestamp: -1 });\n    console.log('‚úÖ MeetingHistory indexes created');\n\n    console.log('üéâ All database indexes created successfully');\n  } catch (error: any) {\n    console.error('‚ùå Error creating indexes:', error.message);\n    // Don't throw error - continue without indexes if they already exist\n  }\n}\n\nexport { createIndexes };","// config/database.ts\r\nimport mongoose from 'mongoose';\r\nimport dotenv from 'dotenv';\r\nimport { createIndexes } from './database-indexes';\r\n\r\n// Load environment variables\r\ndotenv.config();\r\n\r\ninterface DatabaseConfig {\r\n  MONGODB_URI: string;\r\n  DB_NAME: string;\r\n}\r\n\r\n// Default configuration\r\nexport const dbConfig: DatabaseConfig = {\r\n  MONGODB_URI: process.env.MONGODB_URI || 'mongodb+srv://powerjbds:powerjbds@jbds.hk6xeqm.mongodb.net/',\r\n  DB_NAME: process.env.DB_NAME || 'employee-tracking'\r\n};\r\n\r\nclass Database {\r\n  private static instance: Database;\r\n  private isConnected = false;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): Database {\r\n    if (!Database.instance) {\r\n      Database.instance = new Database();\r\n    }\r\n    return Database.instance;\r\n  }\r\n\r\n  public async connect(): Promise<void> {\r\n    if (this.isConnected) {\r\n      console.log('üì¶ Database: Already connected to MongoDB');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      console.log('üîÑ Database: Connecting to MongoDB...');\r\n      \r\n      await mongoose.connect(dbConfig.MONGODB_URI, {\r\n        dbName: dbConfig.DB_NAME,\r\n        maxPoolSize: 10, // üî• FIX: Reduce from 50 to 10 to prevent connection overload\r\n        serverSelectionTimeoutMS: 20000, // More tolerant for network latency to Atlas\r\n        socketTimeoutMS: 120000, // Avoid false 500s for heavy but valid read queries\r\n        connectTimeoutMS: 10000, // üî• FIX: Reduce from 30s to 10s\r\n        retryWrites: true,\r\n        retryReads: false, // üî• FIX: Disable retry reads to prevent retry storms\r\n        maxIdleTimeMS: 30000, // üî• FIX: Close idle connections after 30s\r\n        heartbeatFrequencyMS: 30000, // üî• FIX: Reduce heartbeat frequency\r\n      });\r\n\r\n\r\n      this.isConnected = true;\r\n      console.log('‚úÖ Database: Successfully connected to MongoDB');\r\n      \r\n      // üî• Create indexes after successful connection\r\n      await createIndexes();\r\n      \r\n      // Handle connection events\r\n      mongoose.connection.on('error', (error) => {\r\n        console.error('‚ùå Database: MongoDB connection error:', error);\r\n        this.isConnected = false;\r\n      });\r\n\r\n      mongoose.connection.on('disconnected', () => {\r\n        console.log('üì¶ Database: MongoDB disconnected');\r\n        this.isConnected = false;\r\n      });\r\n\r\n      mongoose.connection.on('reconnected', () => {\r\n        console.log('üì¶ Database: MongoDB reconnected');\r\n        this.isConnected = true;\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Database: Failed to connect to MongoDB:', error);\r\n      this.isConnected = false;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async disconnect(): Promise<void> {\r\n    if (!this.isConnected) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await mongoose.disconnect();\r\n      this.isConnected = false;\r\n      console.log('üì¶ Database: Disconnected from MongoDB');\r\n    } catch (error) {\r\n      console.error('‚ùå Database: Error disconnecting from MongoDB:', error);\r\n    }\r\n  }\r\n\r\n  public isConnectionActive(): boolean {\r\n    return this.isConnected && mongoose.connection.readyState === 1;\r\n  }\r\n\r\n  public getConnection() {\r\n    return mongoose.connection;\r\n  }\r\n}\r\n\r\nexport default Database;","import { RequestHandler } from \"express\";\r\nimport { DemoResponse } from \"@shared/api\";\r\n\r\nexport const handleDemo: RequestHandler = (req, res) => {\r\n  const response: DemoResponse = {\r\n    message: \"Hello from Express server\",\r\n  };\r\n  res.status(200).json(response);\r\n};\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n\r\n// Customer contact interface\r\ninterface CustomerContact {\r\n customerName: string;\r\n customerEmployeeName: string;\r\n customerEmail?: string;\r\n customerMobile?: string;\r\n customerDesignation?: string;\r\n customerDepartment?: string;\r\n}\r\n\r\n\r\n// Meeting details interface\r\ninterface MeetingDetails {\r\n customers: CustomerContact[];\r\n discussion: string;\r\n attachments?: string[]; // Array of base64 encoded files or URLs\r\n // Legacy fields for backward compatibility\r\n customerName?: string;\r\n customerEmployeeName?: string;\r\n customerEmail?: string;\r\n customerMobile?: string;\r\n customerDesignation?: string;\r\n customerDepartment?: string;\r\n}\r\n\r\n\r\n// Location interface\r\ninterface Location {\r\n lat: number;\r\n lng: number;\r\n address: string;\r\n timestamp: string;\r\n}\r\n\r\n\r\n// Meeting document interface\r\nexport interface IMeeting extends Document {\r\n employeeId: string;\r\n location: Location;\r\n startTime: string;\r\n endTime?: string;\r\n clientName?: string;\r\n notes?: string;\r\n status: 'started' | 'in-progress' | 'completed';\r\n trackingSessionId?: string;\r\n leadId?: string;\r\n leadInfo?: {\r\n   id: string;\r\n   companyName: string;\r\n   contactName: string;\r\n };\r\n followUpId?: string; // Follow-up meeting ID from external API\r\n meetingDetails?: MeetingDetails;\r\n externalMeetingStatus?: string; // Status from external follow-up API\r\n meetingStatus?: string; // Meeting completion status (complete/incomplete)\r\n approvalStatus?: 'ok' | 'not_ok' | 'pending'; // Meeting approval status\r\n approvalReason?: string; // Reason for approval/rejection\r\n approvedBy?: string | null; // userId who approved the meeting\r\n attachments?: string[]; // Array of attachment file URLs/paths\r\n createdAt: Date;\r\n updatedAt: Date;\r\n}\r\n\r\n\r\n// Customer contact schema\r\nconst CustomerContactSchema = new Schema({\r\n customerName: { type: String, required: true },\r\n customerEmployeeName: { type: String, required: true },\r\n customerEmail: { type: String },\r\n customerMobile: { type: String },\r\n customerDesignation: { type: String },\r\n customerDepartment: { type: String }\r\n});\r\n\r\n\r\n// Meeting details schema\r\nconst MeetingDetailsSchema = new Schema({\r\n customers: [CustomerContactSchema],\r\n discussion: { type: String, required: true },\r\n attachments: { type: [String], default: [] }, // Array of base64 encoded files or URLs\r\n // Legacy fields\r\n customerName: { type: String },\r\n customerEmployeeName: { type: String },\r\n customerEmail: { type: String },\r\n customerMobile: { type: String },\r\n customerDesignation: { type: String },\r\n customerDepartment: { type: String }\r\n});\r\n\r\n\r\n// Location schema\r\nconst CoordinateSchema = new Schema({\r\n lat: { type: Number, required: true },\r\n lng: { type: Number, required: true },\r\n address: { type: String, required: true },\r\n timestamp: { type: String }\r\n}, { _id: false });\r\n\r\n\r\nconst LocationSchema = new Schema({\r\n lat: { type: Number, required: true },\r\n lng: { type: Number, required: true },\r\n address: { type: String, required: true },\r\n endLocation: { type: CoordinateSchema },\r\n timestamp: { type: String, required: true }\r\n});\r\n\r\n\r\n\r\n\r\n// Lead info schema\r\n// const LeadInfoSchema = new Schema({\r\n//  id: { type: String, required: true },\r\n//  companyName: { type: String, required: true },\r\n//  contactName: { type: String, required: true }\r\n// });\r\n\r\n// Lead info schema (FULLY OPTIONAL)\r\nconst LeadInfoSchema = new Schema(\r\n  {\r\n    id: {type: String },\r\n    companyName: { type: String },\r\n    contactName: { type: String}\r\n  },\r\n  // { _id: false } // optional but recommended\r\n);\r\n\r\n\r\n\r\n// Main meeting schema\r\nconst MeetingSchema = new Schema({\r\n employeeId: {\r\n   type: String,\r\n   required: true,\r\n   index: true\r\n },\r\n location: {\r\n   type: LocationSchema,\r\n   required: true\r\n },\r\n startTime: {\r\n   type: String,\r\n   required: true,\r\n   index: true\r\n },\r\n endTime: {\r\n   type: String\r\n },\r\n clientName: {\r\n   type: String\r\n },\r\n notes: {\r\n   type: String\r\n },\r\n status: {\r\n   type: String,\r\n   enum: ['started', 'in-progress', 'completed'],\r\n   default: 'in-progress',\r\n   index: true\r\n },\r\n trackingSessionId: {\r\n   type: String\r\n },\r\n leadId: {\r\n   type: String,\r\n   index: true\r\n },\r\n//  leadInfo: LeadInfoSchema,\r\n//  followUpId: {\r\n//    type: String,\r\n//    index: true\r\n//  },\r\nleadInfo: {\r\n  type: LeadInfoSchema,\r\n  default: null // ‚úÖ IMPORTANT\r\n},\r\n followUpId: {\r\n   type: String,\r\n   index: true\r\n },\r\n meetingDetails: MeetingDetailsSchema,\r\n externalMeetingStatus: {\r\n   type: String\r\n },\r\n meetingStatus: {\r\n   type: String,\r\n   index: true\r\n },\r\n approvalStatus: {\r\n   type: String,\r\n   enum: ['ok', 'not_ok', 'pending'],\r\n   index: true\r\n },\r\n approvalReason: {\r\n   type: String\r\n },\r\n approvedBy: {\r\n   type: String,\r\n   default: null // userId who approved the meeting\r\n },\r\n attachments: {\r\n   type: [String],\r\n   default: [] // Array of attachment file URLs/paths\r\n }\r\n}, {\r\n timestamps: true,\r\n collection: 'meetings'\r\n});\r\n\r\n\r\n// Create indexes for better query performance\r\nMeetingSchema.index({ employeeId: 1, startTime: -1 });\r\n// Helps all-employees-details when scanning many employees with startTime sort/range\r\nMeetingSchema.index({ startTime: -1, employeeId: 1 });\r\nMeetingSchema.index({ leadId: 1, startTime: -1 });\r\nMeetingSchema.index({ status: 1, startTime: -1 });\r\n// Fast path for active meeting lookup on end/start flows\r\nMeetingSchema.index({ employeeId: 1, status: 1, startTime: -1 });\r\nMeetingSchema.index({ followUpId: 1, status: 1, startTime: -1 });\r\n// Fast path for approval lookup by details and day-scoped meeting fetches\r\nMeetingSchema.index({ employeeId: 1, clientName: 1, startTime: -1 });\r\nMeetingSchema.index({ employeeId: 1, meetingStatus: 1, startTime: -1 });\r\n\r\n\r\nexport const Meeting = mongoose.model<IMeeting>('Meeting', MeetingSchema);\r\n\r\n\r\n\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n// Meeting details interface (reused from Meeting model)\r\ninterface MeetingDetails {\r\n  customers: Array<{\r\n    customerName: string;\r\n    customerEmployeeName: string;\r\n    customerEmail?: string;\r\n    customerMobile?: string;\r\n    customerDesignation?: string;\r\n    customerDepartment?: string;\r\n  }>;\r\n  discussion: string;\r\n  // Incomplete meeting tracking\r\n  incomplete?: boolean;\r\n  incompleteReason?: string;\r\n  // Legacy fields\r\n  customerName?: string;\r\n  customerEmployeeName?: string;\r\n  customerEmail?: string;\r\n  customerMobile?: string;\r\n  customerDesignation?: string;\r\n  customerDepartment?: string;\r\n}\r\n\r\n// Meeting history document interface\r\nexport interface IMeetingHistory extends Document {\r\n  sessionId: string;\r\n  employeeId: string;\r\n  meetingDetails: MeetingDetails;\r\n  timestamp: string;\r\n  leadId?: string;\r\n  leadInfo?: {\r\n    id: string;\r\n    companyName: string;\r\n    contactName: string;\r\n  };\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Customer contact schema (reused)\r\nconst CustomerContactSchema = new Schema({\r\n  customerName: { type: String, required: true },\r\n  customerEmployeeName: { type: String, required: true },\r\n  customerEmail: { type: String },\r\n  customerMobile: { type: String },\r\n  customerDesignation: { type: String },\r\n  customerDepartment: { type: String }\r\n});\r\n\r\n// Meeting details schema (reused)\r\nconst MeetingDetailsSchema = new Schema({\r\n  customers: [CustomerContactSchema],\r\n  discussion: { type: String, required: true },\r\n  // Incomplete meeting tracking\r\n  incomplete: { type: Boolean, default: false, index: true },\r\n  incompleteReason: { type: String },\r\n  // Legacy fields\r\n  customerName: { type: String },\r\n  customerEmployeeName: { type: String },\r\n  customerEmail: { type: String },\r\n  customerMobile: { type: String },\r\n  customerDesignation: { type: String },\r\n  customerDepartment: { type: String }\r\n});\r\n\r\n// Lead info schema (reused)\r\nconst LeadInfoSchema = new Schema({\r\n  id: { type: String, required: true },\r\n  companyName: { type: String, required: true },\r\n  contactName: { type: String, required: true }\r\n});\r\n\r\n// Meeting history schema\r\nconst MeetingHistorySchema = new Schema({\r\n  sessionId: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  employeeId: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  meetingDetails: { \r\n    type: MeetingDetailsSchema, \r\n    required: true \r\n  },\r\n  timestamp: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  leadId: { \r\n    type: String,\r\n    index: true \r\n  },\r\n  leadInfo: LeadInfoSchema\r\n}, {\r\n  timestamps: true,\r\n  collection: 'meeting_history'\r\n});\r\n\r\n// Create indexes for better query performance\r\nMeetingHistorySchema.index({ employeeId: 1, timestamp: -1 });\r\nMeetingHistorySchema.index({ leadId: 1, timestamp: -1 });\r\nMeetingHistorySchema.index({ sessionId: 1, timestamp: -1 });\r\n\r\nexport const MeetingHistory = mongoose.model<IMeetingHistory>('MeetingHistory', MeetingHistorySchema);\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n// Attendance document interface\r\nexport interface IAttendance extends Document {\r\n  employeeId: string;\r\n  date: string; // YYYY-MM-DD format\r\n  attendanceStatus: 'full_day' | 'half_day' | 'off' | 'short_leave' | 'ot' | 'absent';\r\n  attendanceReason: string;\r\n  attendenceCreated: string | null; // userId who created the attendance (null for tracking employee)\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Attendance schema\r\nconst AttendanceSchema = new Schema({\r\n  employeeId: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  date: { \r\n    type: String, \r\n    required: true,\r\n    index: true,\r\n    match: /^\\d{4}-\\d{2}-\\d{2}$/ // YYYY-MM-DD format validation\r\n  },\r\n  attendanceStatus: { \r\n    type: String, \r\n    enum: ['full_day', 'half_day', 'off', 'short_leave', 'ot', 'absent'],\r\n    required: true,\r\n    default: 'full_day'\r\n  },\r\n  attendanceReason: { \r\n    type: String,\r\n    default: ''\r\n  },\r\n  attendenceCreated: {\r\n    type: String,\r\n    default: null // null for tracking employee, userId from CRM dashboard\r\n  }\r\n}, {\r\n  timestamps: true,\r\n  collection: 'attendance'\r\n});\r\n\r\n// Create compound unique index to prevent duplicate attendance records for same employee-date\r\nAttendanceSchema.index({ employeeId: 1, date: 1 }, { unique: true });\r\n\r\n// Create indexes for better query performance\r\nAttendanceSchema.index({ employeeId: 1, date: -1 });\r\n// Helps all-employees-details when date range is wide and employee list is large\r\nAttendanceSchema.index({ date: -1, employeeId: 1 });\r\nAttendanceSchema.index({ date: -1, attendanceStatus: 1 });\r\n\r\nexport const Attendance = mongoose.model<IAttendance>('Attendance', AttendanceSchema);\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n// Location data interface\r\ninterface LocationData {\r\n  lat: number;\r\n  lng: number;\r\n  address: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Tracking session document interface\r\nexport interface ITrackingSession extends Document {\r\n  id: string;\r\n  employeeId: string;\r\n  startTime: string;\r\n  endTime?: string;\r\n  startLocation: LocationData;\r\n  endLocation?: LocationData;\r\n  route: LocationData[];\r\n  totalDistance: number;\r\n  duration?: number;\r\n  status: 'active' | 'completed' | 'paused';\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Location data schema\r\nconst LocationDataSchema = new Schema({\r\n  lat: { type: Number, required: true },\r\n  lng: { type: Number, required: true },\r\n  address: { type: String, required: true },\r\n  timestamp: { type: String, required: true }\r\n});\r\n\r\n// Tracking session schema\r\nconst TrackingSessionSchema = new Schema({\r\n  id: { \r\n    type: String, \r\n    required: true,\r\n    unique: true,\r\n    index: true \r\n  },\r\n  employeeId: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  startTime: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  endTime: { \r\n    type: String \r\n  },\r\n  startLocation: { \r\n    type: LocationDataSchema, \r\n    required: true \r\n  },\r\n  endLocation: { \r\n    type: LocationDataSchema \r\n  },\r\n  route: [LocationDataSchema],\r\n  totalDistance: { \r\n    type: Number, \r\n    default: 0 \r\n  },\r\n  duration: { \r\n    type: Number // Duration in seconds\r\n  },\r\n  status: { \r\n    type: String, \r\n    enum: ['active', 'completed', 'paused'],\r\n    default: 'active',\r\n    index: true \r\n  }\r\n}, {\r\n  timestamps: true,\r\n  collection: 'tracking_sessions'\r\n});\r\n\r\n// Create indexes for better query performance\r\nTrackingSessionSchema.index({ employeeId: 1, startTime: -1 });\r\n// Helps all-employees-details when querying broad date windows across many employees\r\nTrackingSessionSchema.index({ startTime: -1, employeeId: 1 });\r\nTrackingSessionSchema.index({ status: 1, startTime: -1 });\r\nTrackingSessionSchema.index({ employeeId: 1, status: 1, startTime: -1 });\r\n\r\nexport const TrackingSession = mongoose.model<ITrackingSession>('TrackingSession', TrackingSessionSchema);\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n// Location interface\r\ninterface Location {\r\n  lat: number;\r\n  lng: number;\r\n  address: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Employee document interface\r\nexport interface IEmployee extends Document {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  phone?: string;\r\n  status: 'active' | 'inactive' | 'meeting';\r\n  location?: Location;\r\n  lastUpdate?: string;\r\n  currentTask?: string;\r\n  deviceId?: string;\r\n  designation?: string;\r\n  department?: string;\r\n  companyName?: string;\r\n  reportTo?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Location schema\r\nconst LocationSchema = new Schema({\r\n  lat: { type: Number, required: true },\r\n  lng: { type: Number, required: true },\r\n  address: { type: String, required: true },\r\n  timestamp: { type: String, required: true }\r\n});\r\n\r\n// Employee schema\r\nconst EmployeeSchema = new Schema({\r\n  id: { \r\n    type: String, \r\n    required: true,\r\n    unique: true,\r\n    index: true \r\n  },\r\n  name: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  email: { \r\n    type: String, \r\n    required: true,\r\n    unique: true,\r\n    index: true \r\n  },\r\n  phone: { \r\n    type: String \r\n  },\r\n  status: { \r\n    type: String, \r\n    enum: ['active', 'inactive', 'meeting'],\r\n    default: 'inactive',\r\n    index: true \r\n  },\r\n  location: LocationSchema,\r\n  lastUpdate: { \r\n    type: String \r\n  },\r\n  currentTask: { \r\n    type: String \r\n  },\r\n  deviceId: { \r\n    type: String,\r\n    index: true \r\n  },\r\n  designation: { \r\n    type: String \r\n  },\r\n  department: { \r\n    type: String \r\n  },\r\n  companyName: { \r\n    type: String \r\n  },\r\n  reportTo: { \r\n    type: String \r\n  }\r\n}, {\r\n  timestamps: true,\r\n  collection: 'employees'\r\n});\r\n\r\n// Create indexes for better query performance\r\nEmployeeSchema.index({ status: 1, name: 1 });\r\nEmployeeSchema.index({ companyName: 1, department: 1 });\r\nEmployeeSchema.index({ name: 'text', email: 'text' }); // Text search index\r\n\r\nexport const Employee = mongoose.model<IEmployee>('Employee', EmployeeSchema);\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\n\r\n// Location data interface\r\ninterface LocationData {\r\n  lat: number;\r\n  lng: number;\r\n  address: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Meeting snapshot data interface\r\ninterface MeetingSnapshot {\r\n  id: string;\r\n  location: LocationData;\r\n  clientName?: string;\r\n  startTime: string;\r\n  endTime?: string;\r\n  status: string;\r\n}\r\n\r\n// Route snapshot document interface\r\nexport interface IRouteSnapshot extends Document {\r\n  id: string;\r\n  employeeId: string;\r\n  employeeName: string;\r\n  trackingSessionId?: string;\r\n  captureTime: string;\r\n  startLocation: LocationData;\r\n  endLocation?: LocationData;\r\n  route: LocationData[];\r\n  meetings: MeetingSnapshot[];\r\n  totalDistance: number;\r\n  duration?: number;\r\n  status: 'active' | 'completed';\r\n  title: string;\r\n  description?: string;\r\n  mapBounds: {\r\n    north: number;\r\n    south: number;\r\n    east: number;\r\n    west: number;\r\n  };\r\n  snapshotMetadata: {\r\n    routeColor: string;\r\n    mapZoom: number;\r\n    routePointsCount: number;\r\n    meetingsCount: number;\r\n  };\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Location data schema\r\nconst LocationDataSchema = new Schema({\r\n  lat: { type: Number, required: true },\r\n  lng: { type: Number, required: true },\r\n  address: { type: String, required: true },\r\n  timestamp: { type: String, required: true }\r\n});\r\n\r\n// Meeting snapshot schema\r\nconst MeetingSnapshotSchema = new Schema({\r\n  id: { type: String, required: true },\r\n  location: { type: LocationDataSchema, required: true },\r\n  clientName: { type: String },\r\n  startTime: { type: String, required: true },\r\n  endTime: { type: String },\r\n  status: { type: String, required: true }\r\n});\r\n\r\n// Map bounds schema\r\nconst MapBoundsSchema = new Schema({\r\n  north: { type: Number, required: true },\r\n  south: { type: Number, required: true },\r\n  east: { type: Number, required: true },\r\n  west: { type: Number, required: true }\r\n});\r\n\r\n// Snapshot metadata schema\r\nconst SnapshotMetadataSchema = new Schema({\r\n  routeColor: { type: String, default: '#3b82f6' },\r\n  mapZoom: { type: Number, default: 12 },\r\n  routePointsCount: { type: Number, default: 0 },\r\n  meetingsCount: { type: Number, default: 0 }\r\n});\r\n\r\n// Route snapshot schema\r\nconst RouteSnapshotSchema = new Schema({\r\n  id: { \r\n    type: String, \r\n    required: true,\r\n    unique: true,\r\n    index: true \r\n  },\r\n  employeeId: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  employeeName: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  trackingSessionId: { \r\n    type: String,\r\n    index: true \r\n  },\r\n  captureTime: { \r\n    type: String, \r\n    required: true,\r\n    index: true \r\n  },\r\n  startLocation: { \r\n    type: LocationDataSchema, \r\n    required: true \r\n  },\r\n  endLocation: { \r\n    type: LocationDataSchema \r\n  },\r\n  route: [LocationDataSchema],\r\n  meetings: [MeetingSnapshotSchema],\r\n  totalDistance: { \r\n    type: Number, \r\n    default: 0 \r\n  },\r\n  duration: { \r\n    type: Number // Duration in seconds\r\n  },\r\n  status: { \r\n    type: String, \r\n    enum: ['active', 'completed'],\r\n    default: 'active',\r\n    index: true \r\n  },\r\n  title: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  description: {\r\n    type: String\r\n  },\r\n  mapBounds: {\r\n    type: MapBoundsSchema,\r\n    required: true\r\n  },\r\n  snapshotMetadata: {\r\n    type: SnapshotMetadataSchema,\r\n    required: true\r\n  }\r\n}, {\r\n  timestamps: true,\r\n  collection: 'route_snapshots'\r\n});\r\n\r\n// Create indexes for better query performance\r\nRouteSnapshotSchema.index({ employeeId: 1, captureTime: -1 });\r\nRouteSnapshotSchema.index({ trackingSessionId: 1, captureTime: -1 });\r\nRouteSnapshotSchema.index({ status: 1, captureTime: -1 });\r\nRouteSnapshotSchema.index({ employeeId: 1, status: 1, captureTime: -1 });\r\n\r\nexport const RouteSnapshot = mongoose.model<IRouteSnapshot>('RouteSnapshot', RouteSnapshotSchema);\r\n","import { RequestHandler } from \"express\";\r\nimport axios from \"axios\";\r\nimport {\r\n  Employee,\r\n  ExternalUser,\r\n  EmployeesResponse,\r\n  LocationUpdate,\r\n  LocationUpdateResponse,\r\n} from \"@shared/api\";\r\nimport {\r\n  Employee as EmployeeModel,\r\n  IEmployee,\r\n  TrackingSession,\r\n} from \"../models\";\r\n\r\n// Configuration\r\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\r\nconst NOMINATIM_URL = \"https://nominatim.openstreetmap.org/reverse\";\r\nconst GEOCACHE_TTL = 60 * 60 * 1000; // 1 hour cache TTL\r\n\r\n// Types\r\ninterface EmployeeStatus {\r\n  status: \"active\" | \"inactive\" | \"meeting\";\r\n  location: {\r\n    lat: number;\r\n    lng: number;\r\n    address: string;\r\n    timestamp: string;\r\n  };\r\n  lastUpdate: string;\r\n  currentTask?: string;\r\n}\r\n\r\ninterface GeocodeCacheItem {\r\n  address: string;\r\n  expires: number;\r\n}\r\n\r\n// State\r\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\r\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\r\n\r\n// Utility Functions\r\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\r\n  if (lat === 0 && lng === 0) return \"Location not available\";\r\n\r\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\r\n  const cached = geocodeCache.get(cacheKey);\r\n\r\n  if (cached && cached.expires > Date.now()) {\r\n    return cached.address;\r\n  }\r\n\r\n  try {\r\n    const response = await axios.get(NOMINATIM_URL, {\r\n      params: {\r\n        format: \"json\",\r\n        lat,\r\n        lon: lng,\r\n        zoom: 18,\r\n        addressdetails: 1,\r\n      },\r\n      headers: {\r\n        \"User-Agent\": \"FieldTracker/1.0 (contact@yourdomain.com)\",\r\n      },\r\n      timeout: 5000,\r\n    });\r\n\r\n    const address =\r\n      response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n\r\n    geocodeCache.set(cacheKey, {\r\n      address,\r\n      expires: Date.now() + GEOCACHE_TTL,\r\n    });\r\n\r\n    return address;\r\n  } catch (error) {\r\n    console.error(\"Geocoding failed:\", error);\r\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n  }\r\n}\r\n\r\n// Replace your getAddressFromCoordinates function with this:\r\nasync function getAddressFromCoordinates(\r\n  lat: number,\r\n  lng: number,\r\n): Promise<string> {\r\n  if (lat === 0 && lng === 0) return \"Location not available\";\r\n\r\n  const fallbackAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\r\n  const cached = geocodeCache.get(cacheKey);\r\n\r\n  // Return cached address if available and not expired\r\n  if (cached && cached.expires > Date.now()) {\r\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\r\n    return cached.address;\r\n  }\r\n\r\n  // üîπ FIX: Wait for geocoding instead of returning fallback immediately\r\n  try {\r\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\r\n    const response = await axios.get(NOMINATIM_URL, {\r\n      params: {\r\n        format: \"json\",\r\n        lat,\r\n        lon: lng,\r\n        zoom: 18,\r\n        addressdetails: 1,\r\n      },\r\n      headers: {\r\n        \"User-Agent\": \"EmployeeTrackingApp/1.0\",\r\n      },\r\n      timeout: 5000, // 5 second timeout\r\n    });\r\n\r\n    const address = response.data?.display_name || fallbackAddress;\r\n    console.log(`‚úÖ Address resolved: ${address}`);\r\n\r\n    // Cache the result for future use\r\n    geocodeCache.set(cacheKey, {\r\n      address,\r\n      expires: Date.now() + GEOCACHE_TTL,\r\n    });\r\n\r\n    return address;\r\n  } catch (error) {\r\n    console.warn(`‚ö†Ô∏è Geocoding failed for ${lat}, ${lng}, using coordinates:`, error.message);\r\n    // Return fallback if geocoding fails\r\n    return fallbackAddress;\r\n  }\r\n}\r\n\r\nasync function getEmployeeLatestLocation(employeeId: string) {\r\n  try {\r\n    // First try Employee model with timeout\r\n    const employee = (await Promise.race([\r\n      EmployeeModel.findOne({ id: employeeId }).lean(),\r\n      new Promise((_, reject) =>\r\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\r\n      ),\r\n    ])) as any;\r\n\r\n    if (employee?.location?.lat && employee.location.lng !== 0) {\r\n      const address =\r\n        employee.location.address ||\r\n        `${employee.location.lat.toFixed(6)}, ${employee.location.lng.toFixed(6)}`;\r\n\r\n      return {\r\n        lat: employee.location.lat,\r\n        lng: employee.location.lng,\r\n        address,\r\n        timestamp: employee.location.timestamp,\r\n        lastUpdate: employee.lastUpdate || \"Recently updated\",\r\n      };\r\n    }\r\n\r\n    // Quick fallback to tracking sessions\r\n    const latestSession = (await Promise.race([\r\n      TrackingSession.findOne({\r\n        employeeId,\r\n        $or: [{ status: \"active\" }, { status: \"completed\" }],\r\n      })\r\n        .sort({ startTime: -1 })\r\n        .lean(),\r\n      new Promise((_, reject) =>\r\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\r\n      ),\r\n    ])) as any;\r\n\r\n    if (latestSession) {\r\n      const latestLocation = latestSession.route?.length\r\n        ? latestSession.route[latestSession.route.length - 1]\r\n        : latestSession.startLocation;\r\n\r\n      if (latestLocation?.lat !== 0 && latestLocation?.lng !== 0) {\r\n        const address =\r\n          latestLocation.address ||\r\n          `${latestLocation.lat.toFixed(6)}, ${latestLocation.lng.toFixed(6)}`;\r\n\r\n        return {\r\n          lat: latestLocation.lat,\r\n          lng: latestLocation.lng,\r\n          address,\r\n          timestamp: latestLocation.timestamp,\r\n          lastUpdate:\r\n            latestSession.status === \"active\"\r\n              ? \"Currently tracking\"\r\n              : \"From last session\",\r\n        };\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.warn(`Location lookup failed for ${employeeId}:`, error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\r\n  try {\r\n    geocodeCache.clear();\r\n    res.json({ success: true, message: \"Geocode cache cleared\" });\r\n  } catch (error) {\r\n    console.error(\"Error clearing cache:\", error);\r\n    res.status(500).json({ error: \"Failed to clear cache\" });\r\n  }\r\n};\r\n\r\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\r\n  try {\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), 15000);\r\n\r\n    const response = await fetch(EXTERNAL_API_URL, {\r\n      signal: controller.signal,\r\n      headers: { Accept: \"application/json\" },\r\n    });\r\n\r\n    clearTimeout(timeout);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP ${response.status}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return Array.isArray(data) ? data : [];\r\n  } catch (error) {\r\n    console.error(\"External API fetch failed:\", error);\r\n    return [];\r\n  }\r\n}\r\n\r\nasync function mapExternalUserToEmployee(\r\n  user: ExternalUser,\r\n  index: number,\r\n): Promise<Employee> {\r\n  const userId = user._id;\r\n\r\n  // Try to get location but don't block on it\r\n  let realLocation = null;\r\n  try {\r\n    realLocation = (await Promise.race([\r\n      getEmployeeLatestLocation(userId),\r\n      new Promise((_, reject) =>\r\n        setTimeout(() => reject(new Error(\"timeout\")), 1000),\r\n      ),\r\n    ])) as any;\r\n  } catch (error) {\r\n    // Use default location if lookup fails/times out\r\n    realLocation = null;\r\n  }\r\n\r\n  // Initialize or update status\r\n  if (!employeeStatuses[userId]) {\r\n    employeeStatuses[userId] = {\r\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\r\n      location: realLocation || {\r\n        lat: 28.6139 + (Math.random() - 0.5) * 0.1, // Delhi area with variation\r\n        lng: 77.209 + (Math.random() - 0.5) * 0.1,\r\n        address: `Employee ${index + 1} Location`,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n      lastUpdate: realLocation?.lastUpdate || \"Recently\",\r\n      currentTask:\r\n        index === 0\r\n          ? \"Client meeting\"\r\n          : index === 1\r\n            ? \"Equipment installation\"\r\n            : undefined,\r\n    };\r\n  } else if (realLocation) {\r\n    employeeStatuses[userId].location = {\r\n      lat: realLocation.lat,\r\n      lng: realLocation.lng,\r\n      address: realLocation.address,\r\n      timestamp: realLocation.timestamp,\r\n    };\r\n    employeeStatuses[userId].lastUpdate = realLocation.lastUpdate;\r\n  }\r\n\r\n  const status = employeeStatuses[userId];\r\n\r\n  return {\r\n    id: userId,\r\n    name: user.name,\r\n    email: user.email,\r\n    phone: user.mobileNumber,\r\n    status: status.status,\r\n    location: status.location,\r\n    lastUpdate: status.lastUpdate,\r\n    currentTask: status.currentTask,\r\n    deviceId: `device_${userId.slice(-6)}`,\r\n    designation: user.designation,\r\n    department: user.department,\r\n    companyName: user.companyName[0]?.companyName,\r\n    reportTo: user.report?.name,\r\n  };\r\n}\r\n\r\n// API Handlers\r\nexport const getEmployees: RequestHandler = async (req, res) => {\r\n  try {\r\n    if (req.query.clearCache === \"true\") {\r\n      employeeStatuses = {};\r\n      geocodeCache.clear();\r\n    }\r\n\r\n    const externalUsers = await fetchExternalUsers();\r\n    if (externalUsers.length > 0) {\r\n      const employees = await Promise.all(\r\n        externalUsers.map((user, index) =>\r\n          mapExternalUserToEmployee(user, index),\r\n        ),\r\n      );\r\n\r\n      // Sync to MongoDB\r\n      try {\r\n        await Promise.all(\r\n          employees.map((employee) =>\r\n            EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\r\n              upsert: true,\r\n              new: true,\r\n            }),\r\n          ),\r\n        );\r\n      } catch (dbError) {\r\n        console.warn(\"MongoDB sync failed:\", dbError);\r\n      }\r\n\r\n      return res.json({ employees, total: employees.length });\r\n    }\r\n\r\n    // Fallback to MongoDB\r\n    try {\r\n      const mongoEmployees = await EmployeeModel.find({}).lean();\r\n      return res.json({\r\n        employees: mongoEmployees,\r\n        total: mongoEmployees.length,\r\n      });\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB fallback failed:\", dbError);\r\n      return res.json({ employees: [], total: 0 });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Employee fetch failed:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch employees\" });\r\n  }\r\n};\r\n\r\nexport const getEmployee: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const externalUsers = await fetchExternalUsers();\r\n\r\n    if (externalUsers.length > 0) {\r\n      const user = externalUsers.find((u) => u._id === id);\r\n      if (user) {\r\n        const employee = await mapExternalUserToEmployee(\r\n          user,\r\n          externalUsers.indexOf(user),\r\n        );\r\n\r\n        try {\r\n          await EmployeeModel.findOneAndUpdate({ id }, employee, {\r\n            upsert: true,\r\n            new: true,\r\n          });\r\n        } catch (dbError) {\r\n          console.warn(\"MongoDB update failed:\", dbError);\r\n        }\r\n\r\n        return res.json(employee);\r\n      }\r\n    }\r\n\r\n    // Fallback to MongoDB\r\n    try {\r\n      const employee = await EmployeeModel.findOne({ id }).lean();\r\n      if (employee) return res.json(employee);\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed:\", dbError);\r\n    }\r\n\r\n    return res.status(404).json({ error: \"Employee not found\" });\r\n  } catch (error) {\r\n    console.error(\"Employee fetch failed:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch employee\" });\r\n  }\r\n};\r\n\r\nexport const updateEmployeeLocation: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { lat, lng } = req.body;\r\n\r\n    // Get human-readable address\r\n    const address = await getAddressFromCoordinates(lat, lng);\r\n\r\n    const locationUpdate = {\r\n      location: {\r\n        lat,\r\n        lng,\r\n        address, // Now contains human-readable address\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n      lastUpdate: \"Just now\",\r\n      status: \"active\",\r\n    };\r\n\r\n    // Rest of your existing implementation...\r\n    try {\r\n      const updatedEmployee = await EmployeeModel.findOneAndUpdate(\r\n        { id },\r\n        { $set: locationUpdate },\r\n        { new: true },\r\n      );\r\n\r\n      if (updatedEmployee) {\r\n        return res.json({ success: true, employee: updatedEmployee });\r\n      }\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB update failed:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory\r\n    const externalUsers = await fetchExternalUsers();\r\n    const userIndex = externalUsers.findIndex((user) => user._id === id);\r\n\r\n    if (userIndex === -1) {\r\n      return res.status(404).json({ error: \"Employee not found\" });\r\n    }\r\n\r\n    employeeStatuses[id] = employeeStatuses[id]\r\n      ? { ...employeeStatuses[id], ...locationUpdate }\r\n      : { ...locationUpdate, status: \"active\", currentTask: undefined };\r\n\r\n    const employee = await mapExternalUserToEmployee(\r\n      externalUsers[userIndex],\r\n      userIndex,\r\n    );\r\n    res.json({ success: true, employee });\r\n  } catch (error) {\r\n    console.error(\"Error updating location:\", error);\r\n    res.status(500).json({ error: \"Failed to update location\" });\r\n  }\r\n};\r\n\r\nexport const updateEmployeeStatus: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { status, currentTask } = req.body;\r\n    const update = { status, currentTask, lastUpdate: \"Just now\" };\r\n\r\n    try {\r\n      const employee = await EmployeeModel.findOneAndUpdate(\r\n        { id },\r\n        { $set: update },\r\n        { new: true },\r\n      );\r\n\r\n      if (employee) return res.json(employee);\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB update failed:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory\r\n    const externalUsers = await fetchExternalUsers();\r\n    const user = externalUsers.find((u) => u._id === id);\r\n\r\n    if (!user) return res.status(404).json({ error: \"Employee not found\" });\r\n\r\n    if (!employeeStatuses[id]) {\r\n      const location = await getEmployeeLatestLocation(id);\r\n      employeeStatuses[id] = {\r\n        status: \"active\",\r\n        location: location || {\r\n          lat: 0,\r\n          lng: 0,\r\n          address: \"Location not available\",\r\n          timestamp: new Date().toISOString(),\r\n        },\r\n        lastUpdate: location?.lastUpdate || \"Location not tracked\",\r\n      };\r\n    }\r\n\r\n    employeeStatuses[id] = { ...employeeStatuses[id], ...update };\r\n    const employee = await mapExternalUserToEmployee(\r\n      user,\r\n      externalUsers.indexOf(user),\r\n    );\r\n    res.json(employee);\r\n  } catch (error) {\r\n    console.error(\"Status update failed:\", error);\r\n    res.status(500).json({ error: \"Failed to update status\" });\r\n  }\r\n};\r\n\r\nexport const clearLocationCache: RequestHandler = async (req, res) => {\r\n  try {\r\n    employeeStatuses = {};\r\n    geocodeCache.clear();\r\n    res.json({ success: true, message: \"Cache cleared successfully\" });\r\n  } catch (error) {\r\n    console.error(\"Cache clear failed:\", error);\r\n    res.status(500).json({ error: \"Failed to clear cache\" });\r\n  }\r\n};\r\n\r\nexport const refreshEmployeeLocations: RequestHandler = async (req, res) => {\r\n  try {\r\n    employeeStatuses = {};\r\n    const externalUsers = await fetchExternalUsers();\r\n    const employees = await Promise.all(\r\n      externalUsers.map((user, index) =>\r\n        mapExternalUserToEmployee(user, index),\r\n      ),\r\n    );\r\n\r\n    try {\r\n      await Promise.all(\r\n        employees.map((employee) =>\r\n          EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\r\n            upsert: true,\r\n            new: true,\r\n          }),\r\n        ),\r\n      );\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB sync failed:\", dbError);\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: `Refreshed ${employees.length} employees`,\r\n      employees,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Refresh failed:\", error);\r\n    res.status(500).json({ error: \"Failed to refresh locations\" });\r\n  }\r\n};\r\n\r\n// Placeholder handlers\r\nexport const createEmployee: RequestHandler = (req, res) =>\r\n  res.status(501).json({ error: \"Use external API for creation\" });\r\n\r\nexport const updateEmployee: RequestHandler = (req, res) =>\r\n  res.status(501).json({ error: \"Use external API for updates\" });\r\n\r\nexport const deleteEmployee: RequestHandler = (req, res) =>\r\n  res.status(501).json({ error: \"Use external API for deletion\" });\r\n","import { RequestHandler } from \"express\";\r\nimport multer from \"multer\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport axios from 'axios';\r\nimport NodeCache from 'node-cache';\r\nimport {\r\n  MeetingLog,\r\n  MeetingLogsResponse,\r\n  CreateMeetingRequest,\r\n} from \"@shared/api\";\r\nimport { Meeting, IMeeting } from \"../models\";\r\nimport Database from \"../config/database\";\r\nimport CacheService from \"../services/cache\";\r\n\r\n// Initialize cache with 1 hour TTL\r\nconst geocodeCache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });\r\n\r\nconst uploadsRoot = path.join(process.cwd(), \"uploads\", \"meetings\");\r\nconst storage = multer.diskStorage({\r\n  destination: (req, _file, cb) => {\r\n    const meetingId = req.params.id || \"unknown\";\r\n    const dir = path.join(uploadsRoot, meetingId);\r\n    fs.mkdirSync(dir, { recursive: true });\r\n    cb(null, dir);\r\n  },\r\n  filename: (_req, file, cb) => {\r\n    const safeName = file.originalname.replace(/[^a-zA-Z0-9._-]/g, \"_\");\r\n    const uniqueName = `${Date.now()}-${Math.round(Math.random() * 1e9)}-${safeName}`;\r\n    cb(null, uniqueName);\r\n  },\r\n});\r\n\r\nconst upload = multer({\r\n  storage,\r\n  limits: { fileSize: 10 * 1024 * 1024 },\r\n});\r\n\r\n// üîπ Helper function to format time for IST display\r\nfunction formatTimeForIST(utcTime: string): string {\r\n  const date = new Date(utcTime);\r\n  // Return IST formatted time\r\n  return date.toLocaleString('en-IN', {\r\n    timeZone: 'Asia/Kolkata',\r\n    year: 'numeric',\r\n    month: '2-digit',\r\n    day: '2-digit',\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n    second: '2-digit',\r\n    hour12: false\r\n  });\r\n}\r\n\r\n// üîπ Helper function to get current time in IST\r\nfunction getCurrentTimeIST(): string {\r\n  const now = new Date();\r\n  return now.toISOString(); // Keep UTC in database, format on display\r\n}\r\n\r\n// Helper function for reverse geocoding\r\n// Rate limiting for Nominatim API (max 1 request per second)\r\nlet lastGeocodingTime = 0;\r\nconst GEOCODING_DELAY = 1000; // 1 second\r\n\r\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\r\n  if (lat === 0 && lng === 0) return \"Location not available\";\r\n\r\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\r\n  const cachedAddress = geocodeCache.get<string>(cacheKey);\r\n  if (cachedAddress) {\r\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cachedAddress}`);\r\n    return cachedAddress;\r\n  }\r\n\r\n  try {\r\n    // Rate limiting: wait if needed\r\n    const now = Date.now();\r\n    const timeSinceLastRequest = now - lastGeocodingTime;\r\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\r\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\r\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\r\n      await new Promise(resolve => setTimeout(resolve, waitTime));\r\n    }\r\n    lastGeocodingTime = Date.now();\r\n\r\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\r\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\r\n      params: {\r\n        format: 'json',\r\n        lat,\r\n        lon: lng,\r\n        zoom: 18,\r\n        addressdetails: 1\r\n      },\r\n      headers: {\r\n        'User-Agent': 'EmployeeTrackingApp/1.0'\r\n      },\r\n      timeout: 5000\r\n    });\r\n\r\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n    console.log(`‚úÖ Address resolved: ${address}`);\r\n    geocodeCache.set(cacheKey, address);\r\n    return address;\r\n  } catch (error) {\r\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\r\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n  }\r\n}\r\n\r\n// Enhanced meeting conversion with address handling\r\nasync function convertMeetingToMeetingLog(meeting: IMeeting): Promise<MeetingLog> {\r\n  const location = meeting.location;\r\n  const address = await reverseGeocode(location.lat, location.lng);\r\n\r\n  return {\r\n    id: meeting._id.toString(),\r\n    employeeId: meeting.employeeId,\r\n    location: {\r\n      ...location,\r\n      address // Use the geocoded address\r\n    },\r\n    startTime: meeting.startTime,\r\n    endTime: meeting.endTime,\r\n    clientName: meeting.clientName,\r\n    notes: meeting.notes,\r\n    status: meeting.status as \"started\" | \"in-progress\" | \"completed\",\r\n    trackingSessionId: meeting.trackingSessionId,\r\n    leadId: meeting.leadId,\r\n    leadInfo: meeting.leadInfo,\r\n    followUpId: meeting.followUpId, // üîπ Include follow-up ID\r\n    meetingDetails: meeting.meetingDetails,\r\n    approvalStatus: meeting.approvalStatus, // Meeting approval status\r\n    approvalReason: meeting.approvalReason, // Meeting approval reason\r\n    approvedBy: meeting.approvedBy, // User ID who approved the meeting\r\n  };\r\n}\r\n\r\n// In-memory fallback storage\r\nlet inMemoryMeetings: MeetingLog[] = [];\r\n\r\n// Export for analytics fallback\r\nexport { inMemoryMeetings };\r\n\r\nexport const getMeetings: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\r\n\r\n    // Build query\r\n    const query: any = {};\r\n    if (employeeId) query.employeeId = employeeId;\r\n    if (status) query.status = status;\r\n\r\n    if (startDate || endDate) {\r\n      query.startTime = {};\r\n      if (startDate) query.startTime.$gte = new Date(startDate as string);\r\n      if (endDate) query.startTime.$lte = new Date(endDate as string);\r\n    }\r\n\r\n    console.log(\"üì• Fetching meetings with query:\", JSON.stringify(query, null, 2));\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      // üîπ DEBUG: Count total meetings for this employee\r\n      if (employeeId) {\r\n        const totalCount = await Meeting.countDocuments({ employeeId });\r\n        console.log(`üìä Total meetings in DB for employee ${employeeId}:`, totalCount);\r\n      }\r\n\r\n      const mongoMeetings = await Meeting.find(query)\r\n        .sort({ startTime: -1 })\r\n        .limit(parseInt(limit as string))\r\n        .lean();\r\n\r\n      // Convert all meetings with proper addresses\r\n      const meetingLogs = await Promise.all(\r\n        mongoMeetings.map(meeting => convertMeetingToMeetingLog(meeting))\r\n      );\r\n\r\n      const response: MeetingLogsResponse = {\r\n        meetings: meetingLogs,\r\n        total: meetingLogs.length,\r\n      };\r\n\r\n      console.log(`‚úÖ Found ${meetingLogs.length} meetings matching query:`,\r\n        meetingLogs.map(m => ({ id: m.id, status: m.status, followUpId: m.followUpId, client: m.clientName }))\r\n      );\r\n\r\n      // üîπ DEBUG: If no meetings found but we expected some\r\n      if (meetingLogs.length === 0 && employeeId) {\r\n        console.warn(\"‚ö†Ô∏è No meetings found for query, checking all statuses...\");\r\n        const allMeetings = await Meeting.find({ employeeId }).lean();\r\n        console.log(\"üìã All meetings for this employee:\",\r\n          allMeetings.map(m => ({ id: m._id, status: m.status, followUpId: m.followUpId }))\r\n        );\r\n      }\r\n\r\n      res.json(response);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    let filteredMeetings = inMemoryMeetings;\r\n\r\n    if (employeeId) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => meeting.employeeId === employeeId,\r\n      );\r\n    }\r\n\r\n    if (status) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => meeting.status === status,\r\n      );\r\n    }\r\n\r\n    if (startDate) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => new Date(meeting.startTime) >= new Date(startDate as string),\r\n      );\r\n    }\r\n\r\n    if (endDate) {\r\n      filteredMeetings = filteredMeetings.filter(\r\n        (meeting) => new Date(meeting.startTime) <= new Date(endDate as string),\r\n      );\r\n    }\r\n\r\n    filteredMeetings.sort(\r\n      (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\r\n    );\r\n\r\n    if (limit) {\r\n      filteredMeetings = filteredMeetings.slice(0, parseInt(limit as string));\r\n    }\r\n\r\n    const response: MeetingLogsResponse = {\r\n      meetings: filteredMeetings,\r\n      total: filteredMeetings.length,\r\n    };\r\n\r\n    console.log(`Found ${filteredMeetings.length} meetings in memory`);\r\n    res.json(response);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meetings:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch meetings\" });\r\n  }\r\n};\r\n\r\nexport const getMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const meeting = await Meeting.findById(id).lean();\r\n      if (!meeting) {\r\n        return res.status(404).json({ error: \"Meeting not found in database\" });\r\n      }\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(meeting);\r\n      console.log(\"Meeting found in MongoDB:\", meeting._id);\r\n      res.json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const meeting = inMemoryMeetings.find((meeting) => meeting.id === id);\r\n\r\n    if (!meeting) {\r\n      return res.status(404).json({ error: \"Meeting not found\" });\r\n    }\r\n\r\n    console.log(\"Meeting found in memory:\", meeting.id);\r\n    res.json(meeting);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch meeting\" });\r\n  }\r\n};\r\n\r\n// export const createMeeting: RequestHandler = async (req, res) => {\r\n//   try {\r\n//     const { employeeId, location, clientName, notes, leadId, leadInfo, followUpId, externalMeetingStatus, startTime } = req.body;\r\n\r\n//     if (!employeeId || !location) {\r\n//       return res.status(400).json({ error: \"Employee ID and location are required\" });\r\n//     }\r\n\r\n//     // Get human-readable address\r\n//     const address = await reverseGeocode(location.lat, location.lng);\r\n\r\n//     // üîπ CRITICAL FIX: Store times in UTC, don't convert to IST on server\r\n//     const meetingStartTime = startTime || new Date().toISOString();\r\n\r\n//     console.log(\"üìÖ Meeting start time (UTC):\", {\r\n//       clientProvided: !!startTime,\r\n//       utcTime: meetingStartTime,\r\n//       istDisplay: formatTimeForIST(meetingStartTime),\r\n//       currentUTC: new Date().toISOString(),\r\n//       currentISTDisplay: formatTimeForIST(new Date().toISOString())\r\n//     });\r\n\r\n//     const meetingData = {\r\n//       employeeId,\r\n//       location: {\r\n//         ...location,\r\n//         address,\r\n//         timestamp: new Date().toISOString()\r\n//       },\r\n//       startTime: meetingStartTime, // üîπ Use the exact time when user clicked start\r\n//       clientName,\r\n//       notes,\r\n//       status: \"in-progress\" as const,\r\n//       leadId: leadId || undefined,\r\n//       leadInfo: leadInfo || undefined,\r\n//       followUpId: followUpId || undefined, // üîπ Store follow-up meeting ID\r\n//       externalMeetingStatus: externalMeetingStatus || undefined, // üîπ NEW: Store external meeting status\r\n//     };\r\n\r\n//     // Try MongoDB first\r\n//     try {\r\n//       const newMeeting = new Meeting(meetingData);\r\n//       const savedMeeting = await newMeeting.save();\r\n//       const meetingLog = await convertMeetingToMeetingLog(savedMeeting);\r\n\r\n//       console.log(\"‚úÖ Meeting saved to MongoDB:\", {\r\n//         id: savedMeeting._id,\r\n//         employeeId: savedMeeting.employeeId,\r\n//         followUpId: savedMeeting.followUpId,\r\n//         status: savedMeeting.status,\r\n//         clientName: savedMeeting.clientName\r\n//       });\r\n\r\n//       // üîπ VERIFICATION: Immediately query to confirm it was saved\r\n//       try {\r\n//         const verification = await Meeting.findById(savedMeeting._id);\r\n//         if (verification) {\r\n//           console.log(\"‚úÖ VERIFIED: Meeting exists in database\");\r\n//           console.log(\"‚úÖ VERIFIED followUpId:\", verification.followUpId);\r\n//           console.log(\"‚úÖ VERIFIED status:\", verification.status);\r\n\r\n//           // Also verify we can find it by followUpId\r\n//           if (verification.followUpId) {\r\n//             const byFollowUpId = await Meeting.findOne({ \r\n//               followUpId: verification.followUpId,\r\n//               status: { $in: [\"in-progress\", \"started\"] }\r\n//             });\r\n//             if (byFollowUpId) {\r\n//               console.log(\"‚úÖ VERIFIED: Can find meeting by followUpId\");\r\n//             } else {\r\n//               console.error(\"‚ùå VERIFICATION FAILED: Cannot find meeting by followUpId!\");\r\n//             }\r\n//           }\r\n//         } else {\r\n//           console.error(\"‚ùå VERIFICATION FAILED: Meeting not found after save!\");\r\n//         }\r\n//       } catch (verifyError) {\r\n//         console.error(\"‚ùå VERIFICATION ERROR:\", verifyError);\r\n//       }\r\n\r\n//       res.status(201).json(meetingLog);\r\n//       return;\r\n//     } catch (dbError) {\r\n//       console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\r\n//     }\r\n\r\n//     // Fallback to in-memory storage\r\n//     const meetingId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n//     const meetingLog: MeetingLog = {\r\n//       id: meetingId,\r\n//       employeeId: meetingData.employeeId,\r\n//       location: meetingData.location,\r\n//       startTime: meetingData.startTime,\r\n//       clientName: meetingData.clientName,\r\n//       notes: meetingData.notes,\r\n//       status: meetingData.status,\r\n//       leadId: meetingData.leadId,\r\n//       leadInfo: meetingData.leadInfo,\r\n//     };\r\n\r\n//     inMemoryMeetings.push(meetingLog);\r\n\r\n//     console.log(\"Meeting saved to memory:\", meetingId);\r\n//     res.status(201).json(meetingLog);\r\n//   } catch (error) {\r\n//     console.error(\"Error creating meeting:\", error);\r\n//     res.status(500).json({ error: \"Failed to create meeting\" });\r\n//   }\r\n// };\r\n\r\nexport const createMeeting: RequestHandler = async (req, res) => {\r\n\r\n  console.log(\"bodyy before try of start:\", req.body);\r\n\r\n  try {\r\n    const {\r\n      employeeId,\r\n      location,\r\n      clientName,\r\n      notes,\r\n      leadId,\r\n      leadInfo,\r\n      followUpId,\r\n      externalMeetingStatus,\r\n      startTime,\r\n    } = req.body;\r\n    console.log(\"bodyy of start:\", req.body);\r\n\r\n    if (!employeeId || !location) {\r\n      return res.status(400).json({ error: \"Employee ID and location are required\" });\r\n    }\r\n\r\n    const address = await reverseGeocode(location.lat, location.lng);\r\n\r\n    // üîí START TIME ‚Äî SET ONCE\r\n    const meetingStartTime = startTime ?? new Date().toISOString();\r\n    const sanitizedLeadInfo =\r\n      leadInfo && Object.keys(leadInfo).length > 0 ? leadInfo : undefined;\r\n\r\n\r\n    const meetingData = {\r\n      employeeId,\r\n      location: {\r\n        ...location,\r\n        address,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n      startTime: meetingStartTime,\r\n      clientName,\r\n      notes,\r\n      status: \"in-progress\",\r\n      meetingStatus: \"in-progress\", // Initialize meetingStatus\r\n      leadId,\r\n      leadInfo: sanitizedLeadInfo || undefined,\r\n      followUpId,\r\n      externalMeetingStatus,\r\n    };\r\n\r\n    const db = Database.getInstance();\r\n    if (!db.isConnectionActive()) {\r\n      console.warn(\"‚ö†Ô∏è Database not connected, saving meeting in memory\");\r\n      const meetingId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      const meetingLog: MeetingLog = {\r\n        id: meetingId,\r\n        employeeId: meetingData.employeeId,\r\n        location: meetingData.location,\r\n        startTime: meetingData.startTime,\r\n        endTime: undefined,\r\n        clientName: meetingData.clientName,\r\n        notes: meetingData.notes,\r\n        status: meetingData.status,\r\n        trackingSessionId: undefined,\r\n        leadId: meetingData.leadId,\r\n        leadInfo: meetingData.leadInfo,\r\n        followUpId: meetingData.followUpId,\r\n        meetingDetails: undefined,\r\n        approvalStatus: undefined,\r\n        approvalReason: undefined,\r\n        approvedBy: undefined,\r\n      };\r\n\r\n      inMemoryMeetings.push(meetingLog);\r\n      res.status(201).json(meetingLog);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const meeting = await Meeting.create(meetingData);\r\n\r\n      console.log(\"‚úÖ START MEETING:\", {\r\n        id: meeting._id,\r\n        startTime: meeting.startTime,\r\n      });\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(meeting);\r\n      res.status(201).json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    const meetingId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const meetingLog: MeetingLog = {\r\n      id: meetingId,\r\n      employeeId: meetingData.employeeId,\r\n      location: meetingData.location,\r\n      startTime: meetingData.startTime,\r\n      endTime: undefined,\r\n      clientName: meetingData.clientName,\r\n      notes: meetingData.notes,\r\n      status: meetingData.status,\r\n      trackingSessionId: undefined,\r\n      leadId: meetingData.leadId,\r\n      leadInfo: meetingData.leadInfo,\r\n      followUpId: meetingData.followUpId,\r\n      meetingDetails: undefined,\r\n      approvalStatus: undefined,\r\n      approvalReason: undefined,\r\n      approvedBy: undefined,\r\n    };\r\n\r\n    inMemoryMeetings.push(meetingLog);\r\n    res.status(201).json(meetingLog);\r\n  } catch (error) {\r\n    console.error(\"‚ùå Error starting meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to start meeting\" });\r\n  }\r\n};\r\n\r\nexport const updateMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const updates = req.body;\r\n\r\n    let meeting = null;\r\n\r\n    // 1Ô∏è‚É£ Try by ID (normal flow)\r\n    if (id && id !== \"undefined\" && id !== \"null\") {\r\n      try {\r\n        meeting = await Meeting.findById(id);\r\n        console.log(`üîç Found meeting by ID: ${id}`, meeting ? \"‚úÖ\" : \"‚ùå\");\r\n      } catch (error) {\r\n        console.warn(`‚ö†Ô∏è Invalid meeting ID format: ${id}`);\r\n      }\r\n    }\r\n\r\n    // 2Ô∏è‚É£ FALLBACK ‚Äî tab was closed, find active meeting by employeeId\r\n    if (!meeting) {\r\n      const { employeeId, followUpId } = req.body;\r\n\r\n      if (!employeeId) {\r\n        return res.status(400).json({ error: \"employeeId required to end meeting\" });\r\n      }\r\n\r\n      console.log(`üîç Searching for active meeting - employeeId: ${employeeId}, followUpId: ${followUpId}`);\r\n\r\n      const startOfToday = new Date();\r\n      startOfToday.setHours(0, 0, 0, 0);\r\n\r\n      // Build query to find active meeting\r\n      const query: any = {\r\n        employeeId,\r\n        status: { $in: [\"in-progress\", \"started\"] },\r\n        startTime: { $gte: startOfToday.toISOString() },\r\n      };\r\n\r\n      // Add followUpId to query if provided for more specific matching\r\n      if (followUpId) {\r\n        query.followUpId = followUpId;\r\n      }\r\n\r\n      // Exclude already completed meetings\r\n      query.$or = [\r\n        { meetingStatus: { $exists: false } },\r\n        { meetingStatus: { $ne: \"complete\" } }\r\n      ];\r\n\r\n      console.log(\"üîç Active meeting query:\", JSON.stringify(query, null, 2));\r\n\r\n      meeting = await Meeting.findOne(query).sort({ startTime: -1 });\r\n      \r\n      if (meeting) {\r\n        console.log(`‚úÖ Found active meeting by fallback search: ${meeting._id}`);\r\n      } else {\r\n        console.log(\"‚ùå No active meeting found with fallback search\");\r\n        \r\n        // Debug: Check what meetings exist for this employee today\r\n        const allTodayMeetings = await Meeting.find({\r\n          employeeId,\r\n          startTime: { $gte: startOfToday.toISOString() }\r\n        }).lean();\r\n        \r\n        console.log(\"üìã All meetings for employee today:\", allTodayMeetings.map(m => ({\r\n          id: m._id,\r\n          status: m.status,\r\n          meetingStatus: m.meetingStatus,\r\n          followUpId: m.followUpId,\r\n          startTime: m.startTime\r\n        })));\r\n      }\r\n    }\r\n\r\n    if (!meeting) {\r\n      return res.status(404).json({ error: \"No active meeting found to end\" });\r\n    }\r\n\r\n    console.log(`üìù Ending meeting: ${meeting._id}`);\r\n\r\n    // üîí ABSOLUTE PROTECTION - never allow these to be overwritten\r\n    delete updates.startTime;\r\n    delete updates.status;\r\n\r\n    // ‚úÖ Set completion status deterministically\r\n    meeting.status = \"completed\";\r\n    meeting.meetingStatus = \"complete\";\r\n    meeting.endTime = updates.endTime || new Date().toISOString();\r\n\r\n    // Optional fields (only if provided)\r\n    if (updates.meetingDetails) {\r\n      meeting.meetingDetails = updates.meetingDetails;\r\n    }\r\n\r\n    if (updates.externalMeetingStatus) {\r\n      meeting.externalMeetingStatus = updates.externalMeetingStatus;\r\n    }\r\n\r\n    // üìç End location (matches your current logic)\r\n    if (updates.endLocation) {\r\n      meeting.location.endLocation = {\r\n        lat: updates.endLocation.lat,\r\n        lng: updates.endLocation.lng,\r\n        address:\r\n          updates.endLocation.address ||\r\n          `${updates.endLocation.lat}, ${updates.endLocation.lng}`,\r\n        timestamp: updates.endLocation.timestamp || new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // üîí FINAL CONSISTENCY GUARANTEE\r\n    if (meeting.status === \"completed\") {\r\n      meeting.meetingStatus = \"complete\";\r\n    }\r\n\r\n    if (meeting.meetingStatus === \"complete\") {\r\n      meeting.status = \"completed\";\r\n    }\r\n\r\n    await meeting.save();\r\n\r\n    console.log(\"‚úÖ END MEETING SAVED:\", {\r\n      id: meeting._id,\r\n      status: meeting.status,\r\n      meetingStatus: meeting.meetingStatus,\r\n      startTime: meeting.startTime,\r\n      endTime: meeting.endTime,\r\n    });\r\n\r\n    const meetingLog = await convertMeetingToMeetingLog(meeting);\r\n    res.status(200).json(meetingLog);\r\n  } catch (error) {\r\n    console.error(\"‚ùå Error ending meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to end meeting\" });\r\n  }\r\n};\r\n\r\nexport const uploadMeetingAttachments: RequestHandler = (req, res) => {\r\n  upload.array(\"files\", 10)(req, res, async (error) => {\r\n    if (error) {\r\n      return res.status(400).json({ error: error.message || \"Upload failed\" });\r\n    }\r\n\r\n    try {\r\n      const { id } = req.params;\r\n      if (!id) {\r\n        return res.status(400).json({ error: \"Meeting ID is required\" });\r\n      }\r\n\r\n      const meeting = await Meeting.findById(id);\r\n      if (!meeting) {\r\n        return res.status(404).json({ error: \"Meeting not found\" });\r\n      }\r\n\r\n      const files = (req.files as Express.Multer.File[]) || [];\r\n      if (files.length === 0) {\r\n        return res.status(400).json({ error: \"No files uploaded\" });\r\n      }\r\n\r\n      const baseUrl = `${req.protocol}://${req.get(\"host\")}`;\r\n      const attachmentUrls = files.map(\r\n        (file) => `${baseUrl}/uploads/meetings/${id}/${file.filename}`,\r\n      );\r\n\r\n      meeting.attachments = [...(meeting.attachments || []), ...attachmentUrls];\r\n      if (meeting.meetingDetails?.attachments) {\r\n        meeting.meetingDetails.attachments = [\r\n          ...meeting.meetingDetails.attachments,\r\n          ...attachmentUrls,\r\n        ];\r\n      }\r\n\r\n      await meeting.save();\r\n      return res.status(200).json({ attachments: attachmentUrls });\r\n    } catch (err) {\r\n      console.error(\"‚ùå Error uploading meeting attachments:\", err);\r\n      return res.status(500).json({ error: \"Failed to upload attachments\" });\r\n    }\r\n  });\r\n};\r\n\r\n\r\n// export const updateMeeting: RequestHandler = async (req, res) => {\r\n//   try {\r\n//     const { id } = req.params;\r\n//     const updates = req.body;\r\n\r\n//     console.log(`üìù Updating meeting ${id} with status: ${updates.status}`);\r\n//     console.log(`üìç End location in request:`, updates.endLocation);\r\n\r\n//     // üîπ CRITICAL FIX: Never allow startTime to be overwritten\r\n//     if (updates.startTime) {\r\n//       console.warn(\"‚ö†Ô∏è Attempt to update startTime blocked - preserving original startTime\");\r\n//       delete updates.startTime;\r\n//     }\r\n\r\n//     // üîπ ADDITIONAL PROTECTION: Ensure endTime is never set to startTime for today's meetings\r\n//     if (updates.endTime && updates.status === \"completed\") {\r\n//       console.log(`üìã Meeting completion - endTime: ${updates.endTime}`);\r\n\r\n//       // Validate that endTime is different from startTime (if we can access it)\r\n//       try {\r\n//         const currentMeeting = await Meeting.findById(id).lean();\r\n//         if (currentMeeting && currentMeeting.startTime) {\r\n//           const startTime = new Date(currentMeeting.startTime).getTime();\r\n//           const endTime = new Date(updates.endTime).getTime();\r\n//           const timeDifference = endTime - startTime;\r\n\r\n//           console.log(`‚è∞ Time validation:`, {\r\n//             startTime: currentMeeting.startTime,\r\n//             endTime: updates.endTime,\r\n//             differenceMs: timeDifference,\r\n//             differenceMinutes: Math.round(timeDifference / (1000 * 60))\r\n//           });\r\n\r\n//           // For Today's Meetings specifically: ensure endTime is at least 1 minute after startTime\r\n//           if (timeDifference <= 0) {\r\n//             console.error(\"‚ùå CRITICAL: End time must be after start time!\");\r\n//             updates.endTime = new Date(startTime + 60000).toISOString(); // Add 1 minute minimum\r\n//             console.log(`üîß FIXED: Adjusted endTime to be 1 minute after startTime: ${updates.endTime}`);\r\n//           } else if (timeDifference < 30000) {\r\n//             // Warn if times are suspiciously close (less than 30 seconds apart)\r\n//             console.warn(\"‚ö†Ô∏è WARNING: Start and end times are very close together!\");\r\n//             console.warn(\"This might indicate a timing issue in the client or server.\");\r\n//           }\r\n//         }\r\n//       } catch (validationError) {\r\n//         console.warn(\"Could not validate meeting times:\", validationError);\r\n//       }\r\n//     }\r\n\r\n//     // Log attachments info\r\n//     if (updates.meetingDetails?.attachments) {\r\n//       console.log(`üìé Attachments received: ${updates.meetingDetails.attachments.length} files`);\r\n//       updates.meetingDetails.attachments.forEach((att: string, idx: number) => {\r\n//         const size = att.length;\r\n//         const type = att.match(/data:([^;]+);/)?.[1] || 'unknown';\r\n//         console.log(`   File ${idx + 1}: ${type}, ${(size / 1024).toFixed(2)} KB`);\r\n//       });\r\n//     } else {\r\n//       console.log(`üìé No attachments in request`);\r\n//     }\r\n\r\n//     // Handle meeting completion\r\n//     if (updates.status === \"completed\") {\r\n//       if (!updates.endTime) {\r\n//         // Only set endTime if not provided by client - store in UTC\r\n//         updates.endTime = new Date().toISOString();\r\n//         console.log(`‚è∞ Setting endTime to current server time (UTC): ${updates.endTime}`);\r\n//         console.log(`‚è∞ IST display: ${formatTimeForIST(updates.endTime)}`);\r\n//         console.warn(`‚ö†Ô∏è WARNING: Client did not provide endTime, using server time instead`);\r\n//       } else {\r\n//         // Keep client-provided endTime as UTC\r\n//         console.log(`‚è∞ Using client-provided endTime (UTC): ${updates.endTime}`);\r\n//         console.log(`‚è∞ IST display: ${formatTimeForIST(updates.endTime)}`);\r\n\r\n//         // üîπ CRITICAL VALIDATION: Ensure endTime is not the same as startTime\r\n//         try {\r\n//           const currentMeeting = await Meeting.findById(id).lean();\r\n//           if (currentMeeting && currentMeeting.startTime) {\r\n//             if (updates.endTime === currentMeeting.startTime) {\r\n//               console.error(`‚ùå CRITICAL ERROR: Client provided endTime is identical to startTime!`);\r\n//               console.error(`   StartTime: ${currentMeeting.startTime}`);\r\n//               console.error(`   EndTime: ${updates.endTime}`);\r\n//               console.error(`   This will cause the timing issue! Using server time instead.`);\r\n\r\n//               // Use server time to prevent the timing issue\r\n//               updates.endTime = new Date().toISOString();\r\n//               console.log(`üîß FIXED: Using server time instead: ${updates.endTime}`);\r\n//             } else {\r\n//               const startTime = new Date(currentMeeting.startTime).getTime();\r\n//               const endTime = new Date(updates.endTime).getTime();\r\n//               const duration = endTime - startTime;\r\n\r\n//               console.log(`‚úÖ VALIDATION PASSED: Times are different`);\r\n//               console.log(`   Duration: ${Math.round(duration / (1000 * 60))} minutes`);\r\n//             }\r\n//           }\r\n//         } catch (validationError) {\r\n//           console.warn(\"Could not validate meeting times:\", validationError);\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     // Validate meeting details\r\n//     if (updates.meetingDetails && !updates.meetingDetails.discussion?.trim()) {\r\n//       return res.status(400).json({ error: \"Discussion details are required\" });\r\n//     }\r\n\r\n//     // üîπ CRITICAL FIX: Capture end location when meeting is completed\r\n//     if (updates.status === \"completed\" && updates.endLocation) {\r\n//       console.log(\"üìç Capturing end location for meeting:\", JSON.stringify(updates.endLocation, null, 2));\r\n//       // Store end location in the location.endLocation field\r\n//       updates[\"location.endLocation\"] = {\r\n//         lat: updates.endLocation.lat,\r\n//         lng: updates.endLocation.lng,\r\n//         address: updates.endLocation.address || `${updates.endLocation.lat.toFixed(6)}, ${updates.endLocation.lng.toFixed(6)}`,\r\n//         timestamp: updates.endLocation.timestamp || new Date().toISOString(),\r\n//       };\r\n//       console.log(\"‚úÖ End location formatted:\", JSON.stringify(updates[\"location.endLocation\"], null, 2));\r\n//       // Remove the top-level endLocation field as it's now nested\r\n//       delete updates.endLocation;\r\n//     } else if (updates.status === \"completed\") {\r\n//       console.warn(\"‚ö†Ô∏è Meeting completed but no endLocation provided in request!\");\r\n//     }\r\n\r\n//     // Try MongoDB first\r\n//     try {\r\n//       // üîπ VERIFICATION: Get the current meeting data before update\r\n//       const currentMeeting = await Meeting.findById(id);\r\n//       if (!currentMeeting) {\r\n//         return res.status(404).json({ error: \"Meeting not found in database\" });\r\n//       }\r\n\r\n//       console.log(\"üìã Current meeting before update:\", {\r\n//         id: currentMeeting._id,\r\n//         startTime: currentMeeting.startTime,\r\n//         endTime: currentMeeting.endTime,\r\n//         status: currentMeeting.status,\r\n//         clientName: currentMeeting.clientName\r\n//       });\r\n\r\n//       const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n//         id,\r\n//         { $set: updates },\r\n//         { new: true, runValidators: true }\r\n//       );\r\n\r\n//       if (!updatedMeeting) {\r\n//         return res.status(404).json({ error: \"Meeting not found in database\" });\r\n//       }\r\n\r\n//       console.log(\"üìã Meeting after update:\", {\r\n//         id: updatedMeeting._id,\r\n//         startTime: updatedMeeting.startTime,\r\n//         endTime: updatedMeeting.endTime,\r\n//         status: updatedMeeting.status,\r\n//         clientName: updatedMeeting.clientName\r\n//       });\r\n\r\n//       // üîπ VERIFICATION: Ensure startTime was not changed\r\n//       if (currentMeeting.startTime !== updatedMeeting.startTime) {\r\n//         console.error(\"‚ùå CRITICAL ERROR: startTime was changed during update!\");\r\n//         console.error(\"Original startTime:\", currentMeeting.startTime);\r\n//         console.error(\"New startTime:\", updatedMeeting.startTime);\r\n//       } else {\r\n//         console.log(\"‚úÖ VERIFIED: startTime preserved correctly\");\r\n//       }\r\n\r\n//       console.log(\"Meeting updated in MongoDB:\", updatedMeeting._id);\r\n//       if (updatedMeeting.location?.endLocation) {\r\n//         console.log(\"‚úÖ End location saved:\", updatedMeeting.location.endLocation);\r\n//       }\r\n\r\n//       // Log attachments storage\r\n//       if (updatedMeeting.meetingDetails?.attachments) {\r\n//         console.log(`‚úÖ Attachments stored: ${updatedMeeting.meetingDetails.attachments.length} files`);\r\n//       } else {\r\n//         console.log(`‚ö†Ô∏è No attachments in stored meeting`);\r\n//       }\r\n\r\n//       const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n\r\n//       // Verify attachments in response\r\n//       if (meetingLog.meetingDetails?.attachments) {\r\n//         console.log(`‚úÖ Attachments in response: ${meetingLog.meetingDetails.attachments.length} files`);\r\n//       } else {\r\n//         console.log(`‚ö†Ô∏è No attachments in response`);\r\n//       }\r\n\r\n//       res.json(meetingLog);\r\n//       return;\r\n//     } catch (dbError) {\r\n//       console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\r\n//     }\r\n\r\n//     // Fallback to in-memory storage\r\n//     const meetingIndex = inMemoryMeetings.findIndex((meeting) => meeting.id === id);\r\n//     if (meetingIndex === -1) {\r\n//       return res.status(404).json({ error: \"Meeting not found\" });\r\n//     }\r\n\r\n//     inMemoryMeetings[meetingIndex] = {\r\n//       ...inMemoryMeetings[meetingIndex],\r\n//       ...updates,\r\n//     };\r\n\r\n//     console.log(\"Meeting updated in memory:\", id);\r\n//     res.json(inMemoryMeetings[meetingIndex]);\r\n//   } catch (error) {\r\n//     console.error(\"Error updating meeting:\", error);\r\n//     res.status(500).json({ error: \"Failed to update meeting\" });\r\n//   }\r\n// };\r\n\r\nexport const deleteMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      const deletedMeeting = await Meeting.findByIdAndDelete(id);\r\n      if (!deletedMeeting) {\r\n        return res.status(404).json({ error: \"Meeting not found\" });\r\n      }\r\n\r\n      res.status(204).send();\r\n      return;\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB delete failed:\", dbError);\r\n      throw dbError;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error deleting meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to delete meeting\" });\r\n  }\r\n};\r\n\r\n// üîπ NEW ENDPOINT: Get active meeting for employee (by employeeId or followUpId)\r\nexport const getActiveMeeting: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, followUpId } = req.query;\r\n\r\n    if (!employeeId && !followUpId) {\r\n      return res.status(400).json({\r\n        error: \"Either employeeId or followUpId is required\"\r\n      });\r\n    }\r\n\r\n    console.log(\"üîç Searching for active meeting:\", { employeeId, followUpId });\r\n\r\n    // Try MongoDB first\r\n    try {\r\n      // Build query to find active meetings\r\n      const query: any = {\r\n        status: { $in: [\"in-progress\", \"started\"] },\r\n        $or: [\r\n          { meetingStatus: { $exists: false } },\r\n          { meetingStatus: { $ne: \"complete\" } }\r\n        ]\r\n      };\r\n\r\n      if (followUpId) {\r\n        // If followUpId is provided, search by it (most specific)\r\n        query.followUpId = followUpId;\r\n      } else if (employeeId) {\r\n        // Otherwise search by employeeId\r\n        query.employeeId = employeeId;\r\n      }\r\n\r\n      console.log(\"üì• Query:\", JSON.stringify(query, null, 2));\r\n\r\n      const activeMeeting = await Meeting.findOne(query)\r\n        .sort({ startTime: -1 }) // Get the most recent one\r\n        .lean();\r\n\r\n      if (!activeMeeting) {\r\n        console.log(\"‚ö†Ô∏è No active meeting found with query:\", JSON.stringify(query, null, 2));\r\n\r\n        // üîπ DEBUG: Check what meetings exist for this employee\r\n        let allMeetings: any[] = [];\r\n        if (employeeId) {\r\n          allMeetings = await Meeting.find({ employeeId }).lean();\r\n          console.log(\"üìã All meetings for employee:\", allMeetings.map(m => ({\r\n            id: m._id,\r\n            status: m.status,\r\n            followUpId: m.followUpId,\r\n            startTime: m.startTime\r\n          })));\r\n        }\r\n\r\n        // üîπ DEBUG: Check if there are ANY active meetings\r\n        const anyActiveMeetings = await Meeting.find({\r\n          status: { $in: [\"in-progress\", \"started\"] },\r\n          $or: [\r\n            { meetingStatus: { $exists: false } },\r\n            { meetingStatus: { $ne: \"complete\" } }\r\n          ]\r\n        }).lean();\r\n        console.log(\"üìã All active meetings in database:\", anyActiveMeetings.map(m => ({\r\n          id: m._id,\r\n          employeeId: m.employeeId,\r\n          followUpId: m.followUpId,\r\n          status: m.status\r\n        })));\r\n\r\n        return res.status(404).json({\r\n          error: \"No active meeting found\",\r\n          employeeId,\r\n          followUpId,\r\n          debug: {\r\n            totalMeetingsForEmployee: allMeetings?.length || 0,\r\n            totalActiveMeetings: anyActiveMeetings?.length || 0\r\n          }\r\n        });\r\n      }\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(activeMeeting);\r\n      console.log(\"‚úÖ Active meeting found:\", {\r\n        id: meetingLog.id,\r\n        followUpId: meetingLog.followUpId,\r\n        status: meetingLog.status,\r\n        client: meetingLog.clientName\r\n      });\r\n\r\n      res.json(meetingLog);\r\n      return;\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB query failed:\", dbError);\r\n      return res.status(500).json({ error: \"Database query failed\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error getting active meeting:\", error);\r\n    res.status(500).json({ error: \"Failed to get active meeting\" });\r\n  }\r\n};\r\n\r\n// Add this endpoint to clear geocoding cache\r\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\r\n  try {\r\n    geocodeCache.flushAll();\r\n    res.json({ success: true, message: \"Geocode cache cleared\" });\r\n  } catch (error) {\r\n    console.error(\"Error clearing cache:\", error);\r\n    res.status(500).json({ error: \"Failed to clear cache\" });\r\n  }\r\n};\r\n\r\n// Update meeting approval status\r\nexport const updateMeetingApproval: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { approvalStatus, approvalReason, approvedBy } = req.body;\r\n\r\n    // Validate inputs\r\n    if (!approvalStatus || !['ok', 'not_ok', 'pending'].includes(approvalStatus)) {\r\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok or pending) is required\" });\r\n    }\r\n\r\n    if (!approvalReason || !approvalReason.trim()) {\r\n      return res.status(400).json({ error: \"Approval reason is required\" });\r\n    }\r\n\r\n    console.log(`üìù Updating meeting approval ${id}:`, { approvalStatus, approvalReason, approvedBy });\r\n    console.log(`üìù approvedBy value type:`, typeof approvedBy, `value:`, approvedBy);\r\n\r\n    try {\r\n      const updateData = {\r\n        approvalStatus,\r\n        approvalReason: approvalReason.trim(),\r\n        approvedBy: approvedBy !== undefined ? approvedBy : null\r\n      };\r\n\r\n      console.log(`üìù Update data being sent to MongoDB:`, updateData);\r\n\r\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n        id,\r\n        { $set: updateData },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedMeeting) {\r\n        return res.status(404).json({ error: \"Meeting not found\" });\r\n      }\r\n\r\n      console.log(\"‚úÖ Meeting approval updated:\", updatedMeeting._id);\r\n      console.log(\"‚úÖ Approved by user ID stored in DB:\", updatedMeeting.approvedBy);\r\n      console.log(\"‚úÖ Full updated meeting:\", JSON.stringify({\r\n        id: updatedMeeting._id,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason,\r\n        approvedBy: updatedMeeting.approvedBy\r\n      }));\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n      res.json({\r\n        success: true,\r\n        meeting: meetingLog,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason,\r\n        approvedBy: updatedMeeting.approvedBy\r\n      });\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB update failed:\", dbError);\r\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating meeting approval:\", error);\r\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n  }\r\n};\r\n\r\n// Update meeting approval by composite details (when meetingId is not available)\r\nexport const updateMeetingApprovalByDetails: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, date, companyName, meetingInTime, approvalStatus, approvalReason, approvedBy } = req.body;\r\n\r\n    // Validate inputs\r\n    if (!employeeId || !date || !companyName || !meetingInTime) {\r\n      return res.status(400).json({ error: \"Employee ID, date, company name, and meeting time are required\" });\r\n    }\r\n\r\n    if (!approvalStatus || !['ok', 'not_ok', 'pending'].includes(approvalStatus)) {\r\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok or pending) is required\" });\r\n    }\r\n\r\n    if (!approvalReason || !approvalReason.trim()) {\r\n      return res.status(400).json({ error: \"Approval reason is required\" });\r\n    }\r\n\r\n    console.log(`üìù Updating meeting approval by details:`, {\r\n      employeeId,\r\n      date,\r\n      companyName,\r\n      meetingInTime,\r\n      approvalStatus,\r\n      approvalReason,\r\n      approvedBy\r\n    });\r\n\r\n    try {\r\n      // Parse the date and time to create a date range for the query\r\n      const startOfDayDate = new Date(date);\r\n      startOfDayDate.setHours(0, 0, 0, 0);\r\n\r\n      const endOfDayDate = new Date(date);\r\n      endOfDayDate.setHours(23, 59, 59, 999);\r\n\r\n      // Find the meeting by composite details\r\n      const meeting = await Meeting.findOne({\r\n        employeeId: employeeId,\r\n        clientName: companyName,\r\n        startTime: {\r\n          $gte: startOfDayDate.toISOString(),\r\n          $lte: endOfDayDate.toISOString(),\r\n        },\r\n        meetingStatus: { $ne: \"complete\" }\r\n      }).lean();\r\n\r\n      if (!meeting) {\r\n        console.error(\"‚ùå Meeting not found with details:\", { employeeId, date, companyName });\r\n        return res.status(404).json({\r\n          error: \"Meeting not found\",\r\n          details: { employeeId, date, companyName, meetingInTime }\r\n        });\r\n      }\r\n\r\n      console.log(`‚úÖ Found meeting by details: ${meeting._id}`);\r\n      console.log(`üìù approvedBy value type:`, typeof approvedBy, `value:`, approvedBy);\r\n\r\n      const updateData = {\r\n        approvalStatus,\r\n        approvalReason: approvalReason.trim(),\r\n        approvedBy: approvedBy !== undefined ? approvedBy : null\r\n      };\r\n\r\n      console.log(`üìù Update data being sent to MongoDB:`, updateData);\r\n\r\n      // Update the meeting\r\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\r\n        meeting._id,\r\n        { $set: updateData },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedMeeting) {\r\n        return res.status(404).json({ error: \"Failed to update meeting\" });\r\n      }\r\n\r\n      console.log(\"‚úÖ Meeting approval updated by details:\", updatedMeeting._id);\r\n      console.log(\"‚úÖ Approved by user ID stored in DB:\", updatedMeeting.approvedBy);\r\n      console.log(\"‚úÖ Full updated meeting:\", JSON.stringify({\r\n        id: updatedMeeting._id,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason,\r\n        approvedBy: updatedMeeting.approvedBy\r\n      }));\r\n\r\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\r\n      res.json({\r\n        success: true,\r\n        meeting: meetingLog,\r\n        approvalStatus: updatedMeeting.approvalStatus,\r\n        approvalReason: updatedMeeting.approvalReason,\r\n        approvedBy: updatedMeeting.approvedBy\r\n      });\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB update failed:\", dbError);\r\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating meeting approval by details:\", error);\r\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\r\n  }\r\n};\r\n\r\n// Get today's meetings for duty completion summary\r\nexport const getTodaysMeetings: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId } = req.query;\r\n\r\n    if (!employeeId) {\r\n      return res.status(400).json({ error: \"Employee ID is required\" });\r\n    }\r\n\r\n    console.log(\"üìÖ Fetching today's meetings for employee:\", employeeId);\r\n\r\n    // Get today's date range in UTC\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    const tomorrow = new Date(today);\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n\r\n    console.log(\"üìÖ Date range:\", {\r\n      start: today.toISOString(),\r\n      end: tomorrow.toISOString()\r\n    });\r\n\r\n    try {\r\n      // Query for today's meetings\r\n      const todaysMeetings = await Meeting.find({\r\n        employeeId: employeeId,\r\n        startTime: {\r\n          $gte: today.toISOString(),\r\n          $lt: tomorrow.toISOString()\r\n        }\r\n      })\r\n      .sort({ startTime: -1 })\r\n      .lean();\r\n\r\n      console.log(`üìä Found ${todaysMeetings.length} meetings for today`);\r\n\r\n      // Convert to meeting logs with proper addresses\r\n      const meetingLogs = await Promise.all(\r\n        todaysMeetings.map(meeting => convertMeetingToMeetingLog(meeting))\r\n      );\r\n\r\n      // Calculate total duty hours for completed meetings\r\n      const completedMeetings = meetingLogs.filter(m => m.status === 'completed' && m.endTime);\r\n      const totalDutyHours = completedMeetings.reduce((total, meeting) => {\r\n        if (meeting.startTime && meeting.endTime) {\r\n          const duration = new Date(meeting.endTime).getTime() - new Date(meeting.startTime).getTime();\r\n          const hours = duration / (1000 * 60 * 60);\r\n          return total + hours;\r\n        }\r\n        return total;\r\n      }, 0);\r\n\r\n      // Determine attendance status based on total hours\r\n      let attendanceStatus = \"Pending Verification\";\r\n      let badgeClass = \"bg-gray-500\";\r\n      \r\n      if (totalDutyHours >= 8) {\r\n        attendanceStatus = \"Full Day (Pending Verification)\";\r\n        badgeClass = \"bg-green-500\";\r\n      } else if (totalDutyHours >= 4) {\r\n        attendanceStatus = \"Half Day (Pending Verification)\";\r\n        badgeClass = \"bg-yellow-500\";\r\n      } else if (totalDutyHours > 0) {\r\n        attendanceStatus = \"Short Duration (Pending Verification)\";\r\n        badgeClass = \"bg-blue-500\";\r\n      }\r\n\r\n      const response = {\r\n        meetings: meetingLogs,\r\n        summary: {\r\n          totalMeetings: meetingLogs.length,\r\n          completedMeetings: completedMeetings.length,\r\n          totalDutyHours: Math.round(totalDutyHours * 10) / 10, // Round to 1 decimal\r\n          attendanceStatus,\r\n          badgeClass\r\n        }\r\n      };\r\n\r\n      console.log(\"‚úÖ Today's meetings summary:\", response.summary);\r\n      res.json(response);\r\n    } catch (dbError) {\r\n      console.error(\"MongoDB query failed:\", dbError);\r\n      res.status(500).json({ error: \"Failed to fetch today's meetings\" });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching today's meetings:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch today's meetings\" });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport axios from \"axios\";\r\nimport {\r\n  TrackingSession as TrackingSessionType,\r\n  TrackingSessionResponse,\r\n  LocationData,\r\n  MeetingDetails,\r\n  MeetingHistoryResponse,\r\n} from \"@shared/api\";\r\nimport { MeetingHistory, TrackingSession as TrackingSessionModel } from \"../models\";\r\nimport type { IMeetingHistory, ITrackingSession } from \"../models\";\r\n\r\n// Rate limiting for Nominatim API (max 1 request per second)\r\nlet lastGeocodingTime = 0;\r\nconst GEOCODING_DELAY = 2000; // üî• FIX: Increase from 1s to 2s to reduce API load\r\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\r\nconst GEOCACHE_TTL = 7200000; // üî• FIX: Increase cache from 1 hour to 2 hours\r\n\r\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\r\n  if (lat === 0 && lng === 0) return \"Location not available\";\r\n  \r\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\r\n  const cached = geocodeCache.get(cacheKey);\r\n  if (cached && cached.expires > Date.now()) {\r\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\r\n    return cached.address;\r\n  }\r\n\r\n  try {\r\n    // Rate limiting: wait if needed\r\n    const now = Date.now();\r\n    const timeSinceLastRequest = now - lastGeocodingTime;\r\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\r\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\r\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\r\n      await new Promise(resolve => setTimeout(resolve, waitTime));\r\n    }\r\n    lastGeocodingTime = Date.now();\r\n\r\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\r\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\r\n      params: {\r\n        format: 'json',\r\n        lat,\r\n        lon: lng,\r\n        zoom: 18,\r\n        addressdetails: 1\r\n      },\r\n      headers: {\r\n        'User-Agent': 'EmployeeTrackingApp/1.0'\r\n      },\r\n      timeout: 8000 // üî• FIX: Increase timeout from 5s to 8s to reduce failures\r\n    });\r\n\r\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n    console.log(`‚úÖ Address resolved: ${address}`);\r\n    \r\n    geocodeCache.set(cacheKey, {\r\n      address,\r\n      expires: Date.now() + GEOCACHE_TTL\r\n    });\r\n    \r\n    return address;\r\n  } catch (error) {\r\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\r\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\r\n  }\r\n}\r\n\r\n// In-memory storage for demo purposes\r\nlet trackingSessions: TrackingSessionType[] = [];\r\nlet sessionIdCounter = 1;\r\n\r\n// In-memory storage for meeting history with customer details\r\nlet meetingHistory: Array<{\r\n  id: string;\r\n  sessionId: string;\r\n  employeeId: string;\r\n  meetingDetails: MeetingDetails;\r\n  timestamp: string;\r\n  leadId?: string;\r\n  leadInfo?: any;\r\n}> = [];\r\nlet historyIdCounter = 1;\r\n\r\nexport const getTrackingSessions: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\r\n\r\n    // Build MongoDB query\r\n    const query: any = {};\r\n\r\n    if (employeeId) {\r\n      query.employeeId = employeeId;\r\n    }\r\n\r\n    if (status) {\r\n      query.status = status;\r\n    }\r\n\r\n    if (startDate || endDate) {\r\n      query.startTime = {};\r\n      if (startDate) {\r\n        query.startTime.$gte = new Date(startDate as string).toISOString();\r\n      }\r\n      if (endDate) {\r\n        query.startTime.$lte = new Date(endDate as string).toISOString();\r\n      }\r\n    }\r\n\r\n    console.log(\"Fetching tracking sessions with query:\", query);\r\n\r\n    // Try to fetch from MongoDB first\r\n    try {\r\n      const mongoSessions = await TrackingSessionModel.find(query)\r\n        .sort({ startTime: -1 })\r\n        .limit(parseInt(limit as string))\r\n        .lean();\r\n\r\n      const response: TrackingSessionResponse = {\r\n        sessions: mongoSessions as any as TrackingSessionType[],\r\n        total: mongoSessions.length,\r\n      };\r\n\r\n      console.log(`Found ${mongoSessions.length} tracking sessions in MongoDB`);\r\n      res.json(response);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    let filteredSessions = trackingSessions;\r\n\r\n    if (employeeId) {\r\n      filteredSessions = filteredSessions.filter(\r\n        (session) => session.employeeId === employeeId,\r\n      );\r\n    }\r\n\r\n    if (status) {\r\n      filteredSessions = filteredSessions.filter(\r\n        (session) => session.status === status,\r\n      );\r\n    }\r\n\r\n    if (startDate) {\r\n      filteredSessions = filteredSessions.filter(\r\n        (session) =>\r\n          new Date(session.startTime) >= new Date(startDate as string),\r\n      );\r\n    }\r\n\r\n    if (endDate) {\r\n      filteredSessions = filteredSessions.filter(\r\n        (session) => new Date(session.startTime) <= new Date(endDate as string),\r\n      );\r\n    }\r\n\r\n    filteredSessions.sort(\r\n      (a, b) =>\r\n        new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\r\n    );\r\n\r\n    if (limit) {\r\n      filteredSessions = filteredSessions.slice(0, parseInt(limit as string));\r\n    }\r\n\r\n    const response: TrackingSessionResponse = {\r\n      sessions: filteredSessions,\r\n      total: filteredSessions.length,\r\n    };\r\n\r\n    console.log(`Found ${filteredSessions.length} tracking sessions in memory`);\r\n    res.json(response);\r\n  } catch (error) {\r\n    console.error(\"Error fetching tracking sessions:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch tracking sessions\" });\r\n  }\r\n};\r\n\r\nexport const createTrackingSession: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id, employeeId, startTime, startLocation, route, totalDistance, status } = req.body;\r\n\r\n    if (!employeeId || !startLocation) {\r\n      return res.status(400).json({\r\n        error: \"Employee ID and start location are required\",\r\n      });\r\n    }\r\n\r\n    console.log(\"üìç Creating tracking session:\", { id, employeeId, startTime });\r\n\r\n    // üîπ Resolve start location address if not already resolved\r\n    let resolvedStartLocation = { ...startLocation };\r\n    if (startLocation.lat && startLocation.lng) {\r\n      try {\r\n        console.log(\"üó∫Ô∏è Resolving start location address...\");\r\n        const address = await reverseGeocode(startLocation.lat, startLocation.lng);\r\n        resolvedStartLocation.address = address;\r\n        console.log(\"‚úÖ Start location address resolved:\", address);\r\n      } catch (error) {\r\n        console.warn(\"‚ö†Ô∏è Failed to resolve start location address:\", error);\r\n        // Keep the address as-is\r\n      }\r\n    }\r\n\r\n    const sessionData = {\r\n      id: id || `session_${String(sessionIdCounter++).padStart(3, \"0\")}`,\r\n      employeeId,\r\n      startTime: startTime || new Date().toISOString(),\r\n      startLocation: {\r\n        ...resolvedStartLocation,\r\n        timestamp: resolvedStartLocation.timestamp || new Date().toISOString(),\r\n      },\r\n      route: route || [resolvedStartLocation],\r\n      totalDistance: totalDistance || 0,\r\n      status: status || \"active\" as const,\r\n    };\r\n\r\n    // Try to save to MongoDB first\r\n    try {\r\n      const newSession = new TrackingSessionModel(sessionData);\r\n      const savedSession = await newSession.save();\r\n\r\n      console.log(\"Tracking session saved to MongoDB:\", savedSession.id);\r\n      res.status(201).json(savedSession);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const newSession = sessionData;\r\n    trackingSessions.push(newSession);\r\n\r\n    console.log(\"Tracking session saved to memory:\", newSession.id);\r\n    res.status(201).json(newSession);\r\n  } catch (error) {\r\n    console.error(\"Error creating tracking session:\", error);\r\n    res.status(500).json({ error: \"Failed to create tracking session\" });\r\n  }\r\n};\r\n\r\nexport const updateTrackingSession: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const updates = req.body;\r\n\r\n    console.log(\"üìç Updating tracking session:\", id);\r\n    console.log(\"üìç Updates:\", JSON.stringify(updates, null, 2));\r\n\r\n    // If ending the session, set end time and calculate duration\r\n    if (updates.status === \"completed\" && !updates.endTime) {\r\n      updates.endTime = new Date().toISOString();\r\n      // Duration calculation will be done in the database or after fetch\r\n    }\r\n\r\n    // üîπ CRITICAL FIX: Resolve end location address if coordinates provided\r\n    if (updates.endLocation && updates.endLocation.lat && updates.endLocation.lng) {\r\n      try {\r\n        console.log(\"üó∫Ô∏è Resolving end location address...\");\r\n        const address = await reverseGeocode(updates.endLocation.lat, updates.endLocation.lng);\r\n        updates.endLocation.address = address;\r\n        console.log(\"‚úÖ End location address resolved:\", address);\r\n      } catch (error) {\r\n        console.warn(\"‚ö†Ô∏è Failed to resolve end location address:\", error);\r\n        // Keep the address as-is (might be coordinates)\r\n      }\r\n    }\r\n\r\n    // Try to update in MongoDB first\r\n    try {\r\n      const updatedSession = await TrackingSessionModel.findOneAndUpdate(\r\n        { id },\r\n        { $set: updates },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!updatedSession) {\r\n        console.warn(\"‚ö†Ô∏è Tracking session not found in database:\", id);\r\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\r\n      }\r\n\r\n      // Calculate duration if completing session\r\n      if (updates.status === \"completed\" && updatedSession.startTime && updatedSession.endTime) {\r\n        const startTime = new Date(updatedSession.startTime).getTime();\r\n        const endTime = new Date(updatedSession.endTime).getTime();\r\n        const duration = Math.floor((endTime - startTime) / 1000);\r\n\r\n        await TrackingSessionModel.findOneAndUpdate(\r\n          { id },\r\n          { $set: { duration } },\r\n          { new: true }\r\n        );\r\n        updatedSession.duration = duration;\r\n        console.log(\"‚úÖ Duration calculated:\", duration, \"seconds\");\r\n      }\r\n\r\n      console.log(\"‚úÖ Tracking session updated in MongoDB:\", updatedSession.id);\r\n      if (updatedSession.endLocation) {\r\n        console.log(\"‚úÖ End location saved:\", updatedSession.endLocation);\r\n      }\r\n      res.json(updatedSession);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const sessionIndex = trackingSessions.findIndex(\r\n      (session) => session.id === id,\r\n    );\r\n    if (sessionIndex === -1) {\r\n      return res.status(404).json({ error: \"Tracking session not found\" });\r\n    }\r\n\r\n    // Calculate duration for in-memory sessions\r\n    if (updates.status === \"completed\" && !trackingSessions[sessionIndex].endTime) {\r\n      const startTime = new Date(trackingSessions[sessionIndex].startTime).getTime();\r\n      const endTime = new Date(updates.endTime).getTime();\r\n      updates.duration = Math.floor((endTime - startTime) / 1000);\r\n    }\r\n\r\n    trackingSessions[sessionIndex] = {\r\n      ...trackingSessions[sessionIndex],\r\n      ...updates,\r\n    };\r\n\r\n    console.log(\"Tracking session updated in memory:\", trackingSessions[sessionIndex].id);\r\n    res.json(trackingSessions[sessionIndex]);\r\n  } catch (error) {\r\n    console.error(\"Error updating tracking session:\", error);\r\n    res.status(500).json({ error: \"Failed to update tracking session\" });\r\n  }\r\n};\r\n\r\nexport const addLocationToRoute: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { location } = req.body;\r\n\r\n    if (!location) {\r\n      return res.status(400).json({ error: \"Location is required\" });\r\n    }\r\n\r\n    // Add timestamp to location if not provided\r\n    const locationWithTimestamp: LocationData = {\r\n      ...location,\r\n      timestamp: location.timestamp || new Date().toISOString(),\r\n    };\r\n\r\n    // Try to update in MongoDB first\r\n    try {\r\n      const session = await TrackingSessionModel.findOne({ id });\r\n      if (!session) {\r\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\r\n      }\r\n\r\n      // Add to route\r\n      session.route.push(locationWithTimestamp);\r\n\r\n      // Calculate distance if this isn't the first location\r\n      if (session.route.length > 1) {\r\n        const prevLocation = session.route[session.route.length - 2];\r\n        const distance = calculateDistance(\r\n          prevLocation.lat,\r\n          prevLocation.lng,\r\n          location.lat,\r\n          location.lng,\r\n        );\r\n        session.totalDistance += distance;\r\n      }\r\n\r\n      await session.save();\r\n\r\n      console.log(\"Location added to route in MongoDB:\", session.id);\r\n      res.json(session);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const sessionIndex = trackingSessions.findIndex(\r\n      (session) => session.id === id,\r\n    );\r\n    if (sessionIndex === -1) {\r\n      return res.status(404).json({ error: \"Tracking session not found\" });\r\n    }\r\n\r\n    const session = trackingSessions[sessionIndex];\r\n\r\n    // Add to route\r\n    session.route.push(locationWithTimestamp);\r\n\r\n    // Calculate distance if this isn't the first location\r\n    if (session.route.length > 1) {\r\n      const prevLocation = session.route[session.route.length - 2];\r\n      const distance = calculateDistance(\r\n        prevLocation.lat,\r\n        prevLocation.lng,\r\n        location.lat,\r\n        location.lng,\r\n      );\r\n      session.totalDistance += distance;\r\n    }\r\n\r\n    console.log(\"Location added to route in memory:\", session.id);\r\n    res.json(session);\r\n  } catch (error) {\r\n    console.error(\"Error adding location to route:\", error);\r\n    res.status(500).json({ error: \"Failed to add location to route\" });\r\n  }\r\n};\r\n\r\nexport const getTrackingSession: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Try to fetch from MongoDB first\r\n    try {\r\n      const session = await TrackingSessionModel.findOne({ id });\r\n      if (session) {\r\n        console.log(\"Tracking session found in MongoDB:\", session.id);\r\n        res.json(session);\r\n        return;\r\n      }\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const session = trackingSessions.find((session) => session.id === id);\r\n\r\n    if (!session) {\r\n      return res.status(404).json({ error: \"Tracking session not found\" });\r\n    }\r\n\r\n    console.log(\"Tracking session found in memory:\", session.id);\r\n    res.json(session);\r\n  } catch (error) {\r\n    console.error(\"Error fetching tracking session:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch tracking session\" });\r\n  }\r\n};\r\n\r\nexport const deleteTrackingSession: RequestHandler = (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const sessionIndex = trackingSessions.findIndex(\r\n      (session) => session.id === id,\r\n    );\r\n\r\n    if (sessionIndex === -1) {\r\n      return res.status(404).json({ error: \"Tracking session not found\" });\r\n    }\r\n\r\n    trackingSessions.splice(sessionIndex, 1);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error(\"Error deleting tracking session:\", error);\r\n    res.status(500).json({ error: \"Failed to delete tracking session\" });\r\n  }\r\n};\r\n\r\n// Meeting History endpoints\r\nexport const getMeetingHistory: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, page = 1, limit = 50, dateRange, startDate, endDate, leadId } = req.query;\r\n\r\n    // Build MongoDB query\r\n    const query: any = {};\r\n    if (employeeId) {\r\n      query.employeeId = employeeId;\r\n    }\r\n    if (leadId) {\r\n      query.leadId = leadId;\r\n    }\r\n\r\n    // Add date filtering\r\n    if (dateRange || startDate || endDate) {\r\n      const now = new Date();\r\n      let start: Date, end: Date;\r\n\r\n      if (dateRange && dateRange !== \"custom\") {\r\n        switch (dateRange) {\r\n          case \"all\":\r\n            // Don't set start/end to include all meetings\r\n            break;\r\n          case \"today\":\r\n            start = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\r\n            break;\r\n          case \"yesterday\":\r\n            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n            start = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());\r\n            end = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);\r\n            break;\r\n          case \"week\":\r\n            const startOfWeek = new Date(now.getTime() - (now.getDay() || 7) * 24 * 60 * 60 * 1000);\r\n            start = new Date(startOfWeek.getFullYear(), startOfWeek.getMonth(), startOfWeek.getDate());\r\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\r\n            break;\r\n          case \"month\":\r\n            start = new Date(now.getFullYear(), now.getMonth(), 1);\r\n            end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);\r\n            break;\r\n        }\r\n      } else if (startDate && endDate) {\r\n        start = new Date(startDate as string);\r\n        end = new Date(endDate as string);\r\n        end.setHours(23, 59, 59, 999);\r\n      }\r\n\r\n      if (start && end) {\r\n        query.timestamp = {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        };\r\n        console.log(`Meeting history date filter: ${start.toISOString()} to ${end.toISOString()}`);\r\n      }\r\n    }\r\n\r\n    console.log(\"=== MEETING HISTORY REQUEST ===\");\r\n    console.log(\"Meeting history params:\", { employeeId, leadId, dateRange, startDate, endDate });\r\n    console.log(\"Built MongoDB query:\", JSON.stringify(query, null, 2));\r\n\r\n    // Debug: Check what data exists in the database\r\n    if (!employeeId && dateRange === \"all\") {\r\n      try {\r\n        const totalMeetings = await MeetingHistory.countDocuments();\r\n        const uniqueEmployeeIds = await MeetingHistory.distinct('employeeId');\r\n        const uniqueLeadIds = await MeetingHistory.distinct('leadId');\r\n        console.log(\"=== DATABASE DEBUG INFO ===\");\r\n        console.log(`Total meetings in database: ${totalMeetings}`);\r\n        console.log(`Unique employee IDs (${uniqueEmployeeIds.length}):`, uniqueEmployeeIds);\r\n        console.log(`Unique lead IDs (${uniqueLeadIds.filter(id => id).length}):`, uniqueLeadIds.filter(id => id));\r\n\r\n        // Check for the specific lead IDs mentioned by user\r\n        const specificLeads = await MeetingHistory.find({\r\n          leadId: { $in: ['JBDSL-0044', 'JBDSL-0001'] }\r\n        }).lean();\r\n        console.log(`Meetings with JBDSL-0044 or JBDSL-0001: ${specificLeads.length}`);\r\n        specificLeads.forEach((meeting) => {\r\n          console.log(`  - Lead: ${meeting.leadId}, Employee: ${meeting.employeeId}, Customer: ${meeting.meetingDetails?.customerName || meeting.meetingDetails?.customers?.[0]?.customerName}`);\r\n        });\r\n      } catch (debugError) {\r\n        console.log(\"Debug info failed:\", debugError.message);\r\n      }\r\n    }\r\n\r\n    // Try to fetch from MongoDB first\r\n    try {\r\n      const pageNum = parseInt(page as string);\r\n      const limitNum = parseInt(limit as string);\r\n      const skip = (pageNum - 1) * limitNum;\r\n\r\n      const mongoHistory = await MeetingHistory.find(query)\r\n        .sort({ timestamp: -1 })\r\n        .skip(skip)\r\n        .limit(limitNum)\r\n        .lean();\r\n\r\n      const total = await MeetingHistory.countDocuments(query);\r\n\r\n      const response = {\r\n        meetings: mongoHistory,\r\n        total,\r\n        page: pageNum,\r\n        totalPages: Math.ceil(total / limitNum),\r\n      };\r\n\r\n      console.log(`Found ${mongoHistory.length} meeting history entries in MongoDB for employeeId: ${employeeId}`);\r\n      if (mongoHistory.length > 0) {\r\n        console.log(\"Sample meeting data:\", {\r\n          firstMeeting: {\r\n            employeeId: mongoHistory[0].employeeId,\r\n            leadId: mongoHistory[0].leadId,\r\n            customerName: mongoHistory[0].meetingDetails?.customerName,\r\n            timestamp: mongoHistory[0].timestamp\r\n          }\r\n        });\r\n        // Show all unique employee IDs in the results\r\n        const uniqueEmployeeIds = [...new Set(mongoHistory.map(m => m.employeeId))];\r\n        console.log(\"All employee IDs in results:\", uniqueEmployeeIds);\r\n      }\r\n      res.json(response);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    let filteredHistory = meetingHistory;\r\n\r\n    if (employeeId) {\r\n      filteredHistory = filteredHistory.filter(\r\n        (history) => history.employeeId === employeeId,\r\n      );\r\n    }\r\n\r\n    if (leadId) {\r\n      filteredHistory = filteredHistory.filter(\r\n        (history) => history.leadId === leadId,\r\n      );\r\n    }\r\n\r\n    filteredHistory.sort(\r\n      (a, b) =>\r\n        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\r\n    );\r\n\r\n    const pageNum = parseInt(page as string);\r\n    const limitNum = parseInt(limit as string);\r\n    const startIndex = (pageNum - 1) * limitNum;\r\n    const endIndex = startIndex + limitNum;\r\n    const paginatedHistory = filteredHistory.slice(startIndex, endIndex);\r\n\r\n    const response = {\r\n      meetings: paginatedHistory,\r\n      total: filteredHistory.length,\r\n      page: pageNum,\r\n      totalPages: Math.ceil(filteredHistory.length / limitNum),\r\n    };\r\n\r\n    console.log(`Found ${paginatedHistory.length} meeting history entries in memory`);\r\n    res.json(response);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meeting history:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch meeting history\" });\r\n  }\r\n};\r\n\r\nexport const addMeetingToHistory: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { sessionId, employeeId, meetingDetails, leadId, leadInfo } = req.body;\r\n\r\n    console.log(\"Adding meeting to history:\", {\r\n      sessionId,\r\n      employeeId,\r\n      meetingDetails,\r\n      leadId,\r\n      leadInfo,\r\n    });\r\n\r\n    if (!sessionId || !employeeId || !meetingDetails) {\r\n      return res.status(400).json({\r\n        error: \"Session ID, employee ID, and meeting details are required\",\r\n      });\r\n    }\r\n\r\n    // Validate that discussion is provided (mandatory field)\r\n    if (!meetingDetails.discussion || !meetingDetails.discussion.trim()) {\r\n      return res.status(400).json({\r\n        error: \"Discussion details are required\",\r\n      });\r\n    }\r\n\r\n    // Validate customers array or legacy customer fields\r\n    if (!meetingDetails.customers || meetingDetails.customers.length === 0) {\r\n      // Check if legacy fields are provided for backward compatibility\r\n      if (!meetingDetails.customerName || !meetingDetails.customerEmployeeName) {\r\n        return res.status(400).json({\r\n          error: \"At least one customer contact is required\",\r\n        });\r\n      }\r\n\r\n      // Convert legacy fields to new format\r\n      meetingDetails.customers = [{\r\n        customerName: meetingDetails.customerName,\r\n        customerEmployeeName: meetingDetails.customerEmployeeName,\r\n        customerEmail: meetingDetails.customerEmail || \"\",\r\n        customerMobile: meetingDetails.customerMobile || \"\",\r\n        customerDesignation: meetingDetails.customerDesignation || \"\",\r\n        customerDepartment: meetingDetails.customerDepartment || \"\",\r\n      }];\r\n    }\r\n\r\n    const historyData = {\r\n      sessionId,\r\n      employeeId,\r\n      meetingDetails,\r\n      timestamp: new Date().toISOString(),\r\n      leadId: leadId || undefined,\r\n      leadInfo: leadInfo || undefined,\r\n    };\r\n\r\n    // Try to save to MongoDB first\r\n    try {\r\n      const newHistoryEntry = new MeetingHistory(historyData);\r\n      const savedHistory = await newHistoryEntry.save();\r\n\r\n      console.log(\"Meeting history saved to MongoDB:\", savedHistory._id);\r\n\r\n      // Format the response to match the expected structure\r\n      const formattedResponse = {\r\n        id: savedHistory._id.toString(),\r\n        sessionId: savedHistory.sessionId,\r\n        employeeId: savedHistory.employeeId,\r\n        meetingDetails: savedHistory.meetingDetails,\r\n        timestamp: savedHistory.timestamp,\r\n        leadId: savedHistory.leadId,\r\n        leadInfo: savedHistory.leadInfo,\r\n        _id: savedHistory._id,\r\n        createdAt: savedHistory.createdAt,\r\n        updatedAt: savedHistory.updatedAt\r\n      };\r\n\r\n      res.status(201).json(formattedResponse);\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\r\n      // Log the exact error for debugging\r\n      console.error(\"MongoDB error details:\", {\r\n        message: dbError.message,\r\n        stack: dbError.stack,\r\n        data: historyData\r\n      });\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const newHistoryEntry = {\r\n      id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\r\n      ...historyData,\r\n    };\r\n\r\n    meetingHistory.push(newHistoryEntry);\r\n\r\n    console.log(\"Meeting history entry added to memory:\", newHistoryEntry);\r\n    console.log(\"Total meeting history entries:\", meetingHistory.length);\r\n\r\n    res.status(201).json(newHistoryEntry);\r\n  } catch (error) {\r\n    console.error(\"Error adding meeting to history:\", error);\r\n    res.status(500).json({ error: \"Failed to add meeting to history\" });\r\n  }\r\n};\r\n\r\n// Save incomplete meeting remarks (called on logout with pending meetings)\r\nexport const saveIncompleteMeetingRemark: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, reason, pendingMeetings } = req.body;\r\n\r\n    if (!employeeId || !pendingMeetings || pendingMeetings.length === 0) {\r\n      return res.status(400).json({\r\n        error: \"Employee ID and at least one pending meeting are required\",\r\n      });\r\n    }\r\n\r\n    console.log(\"=== SAVING INCOMPLETE MEETING REMARKS ===\");\r\n    console.log(\"Employee ID:\", employeeId, \"Type:\", typeof employeeId);\r\n    console.log(\"General reason:\", reason);\r\n    console.log(\"Pending meetings count:\", pendingMeetings.length);\r\n\r\n    // Save a history entry for each incomplete meeting with its individual reason\r\n    const savedEntries = await Promise.all(\r\n      pendingMeetings.map(async (meeting: any, idx: number) => {\r\n        // Use individual meeting reason if provided, otherwise fall back to general reason\r\n        const meetingReason = meeting.incompleteReason || reason || \"Meeting not completed\";\r\n        \r\n        const meetingDetails = {\r\n          discussion: meetingReason,\r\n          incomplete: true,\r\n          incompleteReason: meetingReason,\r\n          customers: [\r\n            {\r\n              customerName: meeting.customerName || \"\",\r\n              customerEmployeeName: meeting.customerName || \"\",\r\n              customerEmail: meeting.customerEmail || \"\",\r\n              customerMobile: meeting.customerMobile || \"\",\r\n              customerDesignation: meeting.customerDesignation || \"\",\r\n              customerDepartment: \"\",\r\n            },\r\n          ],\r\n        };\r\n\r\n        const historyData = {\r\n          sessionId: `logout_incomplete_${Date.now()}_${idx}`,\r\n          employeeId: String(employeeId), // Ensure it's a string\r\n          meetingDetails,\r\n          timestamp: new Date().toISOString(),\r\n          leadId: meeting.leadId,\r\n          leadInfo: {\r\n            id: meeting.leadId,\r\n            companyName: meeting.companyName,\r\n          },\r\n        };\r\n\r\n        console.log(`Processing meeting ${idx + 1}:`, {\r\n          employeeId: historyData.employeeId,\r\n          companyName: meeting.companyName,\r\n          customerName: meeting.customerName,\r\n          leadId: meeting.leadId,\r\n          reason: meetingReason,\r\n        });\r\n\r\n        // Try to save to MongoDB first\r\n        try {\r\n          const newEntry = new MeetingHistory(historyData);\r\n          const saved = await newEntry.save();\r\n          console.log(\"‚úì Incomplete meeting remark saved to MongoDB:\", saved._id);\r\n          console.log(\"  - Company:\", meeting.companyName);\r\n          console.log(\"  - Saved employeeId:\", saved.employeeId);\r\n          console.log(\"  - Saved incomplete flag:\", saved.meetingDetails?.incomplete);\r\n          console.log(\"  - Reason:\", meetingReason);\r\n          return {\r\n            success: true,\r\n            meetingId: meeting._id,\r\n            historyId: saved._id,\r\n            companyName: meeting.companyName,\r\n            reason: meetingReason,\r\n          };\r\n        } catch (dbError) {\r\n          console.warn(\"MongoDB save failed for incomplete meeting remark:\", dbError);\r\n          // Fallback: save to in-memory\r\n          meetingHistory.push({\r\n            id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\r\n            ...historyData,\r\n          });\r\n          console.log(\"‚úì Incomplete meeting remark saved to in-memory storage\");\r\n          return { \r\n            success: true, \r\n            meetingId: meeting._id,\r\n            companyName: meeting.companyName,\r\n            reason: meetingReason,\r\n          };\r\n        }\r\n      }),\r\n    );\r\n\r\n    console.log(\"=== SAVED INCOMPLETE MEETING REMARKS ===\");\r\n    console.log(\"Total entries saved:\", savedEntries.length);\r\n    savedEntries.forEach((entry, idx) => {\r\n      console.log(`  ${idx + 1}. ${entry.companyName}: ${entry.reason}`);\r\n    });\r\n\r\n    res.status(201).json({\r\n      success: true,\r\n      reason,\r\n      meetingsProcessed: savedEntries.length,\r\n      entries: savedEntries,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error saving incomplete meeting remarks:\", error);\r\n    res.status(500).json({ error: \"Failed to save incomplete meeting remarks\" });\r\n  }\r\n};\r\n\r\n\r\nexport const getIncompleteMeetingRemark: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId } = req.query;\r\n\r\n    if (!employeeId) {\r\n      return res.status(400).json({\r\n        error: \"Employee ID is required\",\r\n      });\r\n    }\r\n\r\n    console.log(\"Fetching incomplete meeting remarks for employee:\", employeeId);\r\n    console.log(\"Query filter - employeeId type:\", typeof employeeId, \"value:\", employeeId);\r\n\r\n    // Try to fetch from MongoDB first\r\n    try {\r\n      // Build query - ensure employeeId is a string for comparison\r\n      const query = {\r\n        employeeId: String(employeeId),\r\n        \"meetingDetails.incomplete\": true,\r\n      };\r\n      \r\n      console.log(\"MongoDB query:\", JSON.stringify(query, null, 2));\r\n\r\n      const incompleteMeetings = await MeetingHistory.find(query).lean();\r\n\r\n      console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in MongoDB`);\r\n      \r\n      // Debug: Show all incomplete meetings regardless of employeeId\r\n      const allIncomplete = await MeetingHistory.find({\r\n        \"meetingDetails.incomplete\": true,\r\n      }).lean();\r\n      console.log(`Total incomplete meetings in DB (all employees): ${allIncomplete.length}`);\r\n      \r\n      res.json({ meetings: incompleteMeetings });\r\n      return;\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\r\n    }\r\n\r\n    // Fallback to in-memory storage\r\n    const incompleteMeetings = meetingHistory.filter(\r\n      (history) =>\r\n        String(history.employeeId) === String(employeeId) &&\r\n        history.meetingDetails.incomplete,\r\n    );\r\n\r\n    console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in memory`);\r\n    res.json({ meetings: incompleteMeetings });\r\n  } catch (error) {\r\n    console.error(\"Error fetching incomplete meeting remarks:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch incomplete meeting remarks\" });\r\n  }\r\n};\r\n\r\n// Helper function to calculate distance between two points using Haversine formula\r\nfunction calculateDistance(\r\n  lat1: number,\r\n  lng1: number,\r\n  lat2: number,\r\n  lng2: number,\r\n): number {\r\n  const R = 6371e3; // Earth's radius in meters\r\n  const œÜ1 = (lat1 * Math.PI) / 180;\r\n  const œÜ2 = (lat2 * Math.PI) / 180;\r\n  const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;\r\n  const ŒîŒª = ((lng1 - lng2) * Math.PI) / 180;\r\n\r\n  const a =\r\n    Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +\r\n    Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n  return R * c; // Distance in meters\r\n}\r\n","// services/cache.service.js\r\nimport NodeCache from 'node-cache';\r\n\r\nclass CacheService {\r\n  constructor() {\r\n    this.cache = new NodeCache({ \r\n      stdTTL: 300, // 5 minutes default TTL\r\n      checkperiod: 60 \r\n    });\r\n    this.externalApiUrl = \"https://jbdspower.in/LeafNetServer/api/user\";\r\n  }\r\n\r\n  get(key) {\r\n    return this.cache.get(key);\r\n  }\r\n\r\n  set(key, value, ttl = 300) {\r\n    return this.cache.set(key, value, ttl);\r\n  }\r\n\r\n  del(keys) {\r\n    return this.cache.del(keys);\r\n  }\r\n\r\n  flush() {\r\n    return this.cache.flushAll();\r\n  }\r\n\r\n  // External API fetch function\r\n  async fetchExternalUsers() {\r\n    try {\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), 10000);\r\n\r\n      const response = await fetch(this.externalApiUrl, {\r\n        signal: controller.signal,\r\n        headers: {\r\n          Accept: \"application/json\",\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const users = await response.json();\r\n      console.log(`External API: ${users.length} users fetched`);\r\n      return users;\r\n    } catch (error) {\r\n      console.error(\"Error fetching external users:\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Cache external users for 10 minutes\r\n  async getExternalUsers() {\r\n    const cacheKey = 'external_users';\r\n    let users = this.get(cacheKey);\r\n    \r\n    if (!users) {\r\n      console.log('Cache miss: fetching external users');\r\n      users = await this.fetchExternalUsers();\r\n      this.set(cacheKey, users, 600); // 10 minutes\r\n    } else {\r\n      console.log('Cache hit: using cached external users');\r\n    }\r\n    \r\n    return users;\r\n  }\r\n}\r\n\r\nexport const cacheService = new CacheService();","import { RequestHandler } from \"express\";\nimport {\n  format,\n  startOfDay,\n  endOfDay,\n  subDays,\n  startOfWeek,\n  endOfWeek,\n  startOfMonth,\n  endOfMonth,\n  isToday,\n  parseISO,\n} from \"date-fns\";\n// We'll create our own functions here since the employees module doesn't export what we need\nimport { ExternalUser, Employee as EmployeeType } from \"@shared/api\";\nimport { Meeting, Attendance, TrackingSession, Employee } from \"../models/index.js\";\nimport { cacheService } from \"../services/cache.service.js\";\nimport Database from \"../config/database.js\";\nimport mongoose from \"mongoose\";\n\n// Replicate the external API fetch function\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\n\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\n  try {\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000);\n\n    const response = await fetch(EXTERNAL_API_URL, {\n      signal: controller.signal,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const users: ExternalUser[] = await response.json();\n    console.log(\n      `External API response: { count: ${users.length}, sample: ${JSON.stringify(users[0] || {}, null, 2)} }`,\n    );\n\n    return users;\n  } catch (error) {\n    console.error(\"Error fetching external users:\", error);\n    if (error.name === \"AbortError\") {\n      console.error(\"External API request timed out after 30 seconds\");\n    } else if (error.message.includes(\"fetch\")) {\n      console.error(\"Network error connecting to external API\");\n    }\n    return [];\n  }\n}\n\n// Replicate the mapping function\ninterface EmployeeStatus {\n  status: \"active\" | \"inactive\" | \"meeting\";\n  location: {\n    lat: number;\n    lng: number;\n    address: string;\n    timestamp: string;\n  };\n  lastUpdate: string;\n  currentTask?: string;\n}\n\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\n\nfunction getRealisticIndianLocation(index: number) {\n  const locations = [\n    { lat: 28.6139, lng: 77.209, address: \"New Delhi, India\" },\n    { lat: 19.076, lng: 72.8777, address: \"Mumbai, Maharashtra\" },\n    { lat: 12.9716, lng: 77.5946, address: \"Bangalore, Karnataka\" },\n    { lat: 13.0827, lng: 80.2707, address: \"Chennai, Tamil Nadu\" },\n    { lat: 22.5726, lng: 88.3639, address: \"Kolkata, West Bengal\" },\n    { lat: 26.9124, lng: 75.7873, address: \"Jaipur, Rajasthan\" },\n    { lat: 21.1458, lng: 79.0882, address: \"Nagpur, Maharashtra\" },\n    { lat: 23.0225, lng: 72.5714, address: \"Ahmedabad, Gujarat\" },\n    { lat: 17.385, lng: 78.4867, address: \"Hyderabad, Telangana\" },\n    { lat: 18.5204, lng: 73.8567, address: \"Pune, Maharashtra\" },\n  ];\n  return locations[index % locations.length];\n}\n\nfunction mapExternalUserToEmployee(\n  user: ExternalUser,\n  index: number,\n): EmployeeType {\n  const userId = user._id;\n\n  if (!employeeStatuses[userId]) {\n    const realisticLocation = getRealisticIndianLocation(index);\n    employeeStatuses[userId] = {\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\n      location: {\n        ...realisticLocation,\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: `${Math.floor(Math.random() * 15) + 1} minutes ago`,\n      currentTask:\n        index === 0\n          ? \"Client meeting\"\n          : index === 1\n            ? \"Equipment installation\"\n            : undefined,\n    };\n  }\n\n  const status = employeeStatuses[userId];\n\n  return {\n    id: userId,\n    name: user.name,\n    email: user.email,\n    phone: user.mobileNumber,\n    status: status.status,\n    location: status.location,\n    lastUpdate: status.lastUpdate,\n    currentTask: status.currentTask,\n    deviceId: `device_${userId.slice(-6)}`,\n    designation: user.designation,\n    department: user.department,\n    companyName: user.companyName[0]?.companyName,\n    reportTo: user.report?.name,\n  };\n}\n\n// Function to get date range based on filter\nfunction getDateRange(dateRange: string, startDate?: string, endDate?: string) {\n  const now = new Date();\n\n  switch (dateRange) {\n    case \"all\":\n      // Return a very wide date range to include all meetings\n      return {\n        start: new Date(\"2020-01-01\"), // Far past date\n        end: new Date(\"2030-12-31\"), // Far future date\n      };\n    case \"today\":\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n    case \"yesterday\":\n      const yesterday = subDays(now, 1);\n      return {\n        start: startOfDay(yesterday),\n        end: endOfDay(yesterday),\n      };\n    case \"week\":\n      return {\n        start: startOfWeek(now, { weekStartsOn: 1 }), // Monday\n        end: endOfWeek(now, { weekStartsOn: 1 }),\n      };\n    case \"month\":\n      return {\n        start: startOfMonth(now),\n        end: endOfMonth(now),\n      };\n    case \"custom\":\n      if (startDate && endDate) {\n        return {\n          start: startOfDay(parseISO(startDate)),\n          end: endOfDay(parseISO(endDate)),\n        };\n      }\n      // Fallback to today\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n    default:\n      return {\n        start: startOfDay(now),\n        end: endOfDay(now),\n      };\n  }\n}\n\n// Function to calculate meeting duration in hours\nfunction calculateMeetingDuration(startTime: string, endTime?: string): number {\n  if (!startTime) return 0;\n\n  try {\n    const start = new Date(startTime);\n    const end = endTime ? new Date(endTime) : new Date();\n\n    // Validate dates\n    if (isNaN(start.getTime())) return 0;\n    if (endTime && isNaN(end.getTime())) {\n      // If end time is invalid, use current time\n      const durationMs = new Date().getTime() - start.getTime();\n      return Math.max(0, durationMs / (1000 * 60 * 60));\n    }\n\n    const durationMs = end.getTime() - start.getTime();\n    if (durationMs < 0) return 0; // Invalid if end is before start\n\n    return Math.max(0, durationMs / (1000 * 60 * 60)); // Convert to hours\n  } catch (error) {\n    console.error(\"Error calculating meeting duration:\", error);\n    return 0;\n  }\n}\n\n// Function to calculate duty hours (placeholder - would need tracking data)\nfunction calculateDutyHours(\n  employeeId: string,\n  dateRange: { start: Date; end: Date },\n): number {\n  // This is a placeholder calculation\n  // In a real app, this would calculate based on tracking sessions, check-ins, etc.\n  // For now, we'll assume 8 hours per working day in the date range\n  const daysInRange = Math.ceil(\n    (dateRange.end.getTime() - dateRange.start.getTime()) /\n    (1000 * 60 * 60 * 24),\n  );\n  return Math.min(daysInRange * 8, 40); // Max 40 hours per week\n}\n\nexport const getEmployeeAnalytics: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      dateRange = \"today\",\n      startDate,\n      endDate,\n      search,\n    } = req.query;\n\n    // Get date range\n    const { start, end } = getDateRange(\n      dateRange as string,\n      startDate as string,\n      endDate as string,\n    );\n\n    console.log(`Analytics date filter - Range: ${dateRange}, Start: ${startDate}, End: ${endDate}`);\n    console.log(`Calculated date range: ${start.toISOString()} to ${end.toISOString()}`);\n\n    // Fetch all employees\n    const externalUsers = await fetchExternalUsers();\n    let employees = externalUsers.map((user, index) =>\n      mapExternalUserToEmployee(user, index),\n    );\n\n    // Filter by employee if specified\n    if (employeeId && employeeId !== \"all\") {\n      employees = employees.filter((emp) => emp.id === employeeId);\n    }\n\n    // Filter by search term if specified\n    if (search) {\n      const searchTerm = (search as string).toLowerCase();\n      employees = employees.filter(\n        (emp) =>\n          emp.name.toLowerCase().includes(searchTerm) ||\n          emp.email.toLowerCase().includes(searchTerm),\n      );\n    }\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      // Try to get meetings from MongoDB first\n      // Get ALL meetings for total counts, but we'll filter them properly later\n      const mongoMeetings = await Meeting.find({}).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => ({\n        id: meeting._id.toString(),\n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime,\n        clientName: meeting.clientName,\n        leadId: meeting.leadId,\n        status: meeting.status,\n        meetingDetails: meeting.meetingDetails,\n        location: meeting.location\n      }));\n\n      console.log(`Found ${actualMeetings.length} total meetings in MongoDB`);\n      console.log(`Date range filter: ${start.toISOString()} to ${end.toISOString()}`);\n\n      // If no MongoDB data, fallback to in-memory\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import(\"./meetings\");\n        actualMeetings = inMemoryMeetings || [];\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import(\"./meetings\");\n      actualMeetings = inMemoryMeetings || [];\n    }\n\n    console.log(\"Using meetings data:\", actualMeetings.length, \"meetings\");\n    console.log(\"Available employees:\", employees.map(e => ({ id: e.id, name: e.name })));\n    console.log(\"Meeting employee IDs:\", actualMeetings.map(m => m.employeeId));\n\n    // Calculate analytics for each employee\n    const analytics = employees.map((employee) => {\n      // Get meetings for this employee\n      const employeeMeetings = actualMeetings.filter(\n        (meeting) => meeting.employeeId === employee.id,\n      );\n\n      console.log(`Employee ${employee.name} (${employee.id}): found ${employeeMeetings.length} meetings`);\n\n      // Filter meetings by date range for the specific metrics\n      const meetingsInRange = employeeMeetings.filter((meeting) => {\n        const meetingDate = new Date(meeting.startTime);\n        const meetingTime = meetingDate.getTime();\n        const startTime = start.getTime();\n        const endTime = end.getTime();\n        const inRange = meetingTime >= startTime && meetingTime <= endTime;\n\n        if (inRange) {\n          console.log(`‚úÖ Meeting ${meeting.id} IN range: ${meeting.startTime} (${meeting.clientName || 'No client'})`);\n        } else {\n          console.log(`‚ùå Meeting ${meeting.id} OUT of range: ${meeting.startTime} (not between ${start.toISOString()} and ${end.toISOString()})`);\n        }\n        return inRange;\n      });\n\n      // Calculate today's meetings\n      const todayMeetings = employeeMeetings.filter((meeting) =>\n        isToday(new Date(meeting.startTime)),\n      ).length;\n\n      // Calculate total meeting hours for the filtered range\n      // For \"all\" filter, this will be total hours across all meetings\n      const totalMeetingHours = meetingsInRange.reduce((total, meeting) => {\n        return (\n          total + calculateMeetingDuration(meeting.startTime, meeting.endTime)\n        );\n      }, 0);\n\n      console.log(`Employee ${employee.name} (${employee.id}): ${employeeMeetings.length} total meetings, ${meetingsInRange.length} in date range (${dateRange}), ${totalMeetingHours.toFixed(1)}h meeting time`);\n\n      // Calculate duty hours\n      const totalDutyHours = calculateDutyHours(employee.id, { start, end });\n\n      return {\n        employeeId: employee.id,\n        employeeName: employee.name,\n        totalMeetings: employeeMeetings.length, // Total meetings for this employee (all time, never filtered)\n        todayMeetings,\n        totalMeetingHours, // This uses filtered range which is correct\n        totalDutyHours,\n        status: employee.status,\n      };\n    });\n\n    // Calculate summary statistics\n    const summary = {\n      totalEmployees: employees.length,\n      activeMeetings: employees.filter((emp) => emp.status === \"meeting\")\n        .length,\n      totalMeetingsToday: analytics.reduce(\n        (sum, emp) => sum + emp.todayMeetings,\n        0,\n      ),\n      avgMeetingDuration:\n        analytics.length > 0\n          ? analytics.reduce((sum, emp) => sum + emp.totalMeetingHours, 0) /\n          Math.max(\n            analytics.reduce((sum, emp) => sum + emp.totalMeetings, 0),\n            1,\n          )\n          : 0,\n    };\n\n    res.json({\n      analytics,\n      summary,\n      dateRange: {\n        start: start.toISOString(),\n        end: end.toISOString(),\n        label: dateRange,\n      },\n    });\n  } catch (error) {\n    console.error(\"Error fetching employee analytics:\", error);\n    res.status(500).json({ error: \"Failed to fetch analytics\" });\n  }\n};\n\n// Mock meeting data generator for demonstration\nfunction generateMockMeetings(\n  employees: any[],\n  startDate: Date,\n  endDate: Date,\n) {\n  const meetings: any[] = [];\n  const customers = [\n    \"Tech Corp\",\n    \"ABC Industries\",\n    \"XYZ Solutions\",\n    \"Global Systems\",\n    \"Innovation Ltd\",\n  ];\n  const leadIds = [\"LEAD-001\", \"LEAD-002\", \"LEAD-003\", \"LEAD-004\", \"LEAD-005\"];\n\n  employees.forEach((employee, empIndex) => {\n    // Generate 1-5 meetings per employee in the date range\n    const meetingCount = Math.floor(Math.random() * 5) + 1;\n\n    for (let i = 0; i < meetingCount; i++) {\n      // Random date within range\n      const randomTime = new Date(\n        startDate.getTime() +\n        Math.random() * (endDate.getTime() - startDate.getTime()),\n      );\n\n      // Random meeting duration (30 minutes to 3 hours)\n      const durationHours = Math.random() * 2.5 + 0.5;\n      const endTime = new Date(\n        randomTime.getTime() + durationHours * 60 * 60 * 1000,\n      );\n\n      meetings.push({\n        id: `meeting_${empIndex}_${i}`,\n        employeeId: employee.id,\n        startTime: randomTime.toISOString(),\n        endTime: endTime.toISOString(),\n        clientName: customers[Math.floor(Math.random() * customers.length)],\n        leadId: leadIds[Math.floor(Math.random() * leadIds.length)],\n        status: \"completed\",\n        location: employee.location,\n      });\n    }\n  });\n\n  return meetings;\n}\n\nexport const getEmployeeDetails: RequestHandler = async (req, res) => {\n\n  const resolveLocationAddress = (location: any): string => {\n    if (!location) return \"\";\n\n    // If location has an endLocation, use that first\n    const endLocation = (location as any)?.endLocation;\n    if (endLocation?.address) {\n      const endAddr = endLocation.address;\n      \n      // Check if it's just coordinates (lat,lng format) like \"28.277276, 76.885777\"\n      const isCoordinates = /^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$/.test(endAddr);\n      \n      if (isCoordinates) {\n        // If end location is coordinates, try to use the start address instead\n        return location.address || \"Location coordinates\";\n      }\n      return endAddr;\n    }\n\n    // Fallback to main address\n    if (typeof location.address === \"string\" && location.address.trim()) {\n      return location.address;\n    }\n\n    // fallback: return empty string\n    return \"\";\n  };\n\n  try {\n    const { employeeId } = req.params;\n    const {\n      dateRange: rawDateRange = \"today\",\n      startDate,\n      endDate,\n      page = \"1\",\n      limit = \"20\",\n      type = \"meetings\", // \"meetings\" or \"days\"\n      includeAttachments = \"false\",\n    } = req.query;\n    const normalizedDateRange = String(rawDateRange || \"today\")\n      .split(\",\")[0]\n      .trim()\n      .toLowerCase();\n    const dateRange = normalizedDateRange || \"today\";\n    const isAllRange = dateRange === \"all\";\n    const shouldIncludeAttachments = String(includeAttachments).trim().toLowerCase() === \"true\";\n\n    // Start timing\n    const startTime = Date.now();\n\n    // Parse pagination parameters\n    const pageNum = parseInt(page as string, 10) || 1;\n    const limitNum = parseInt(limit as string, 10) || 20;\n    const skip = (pageNum - 1) * limitNum;\n\n    // Get date range\n    const { start, end } = getDateRange(dateRange, startDate as string, endDate as string);\n\n    const employeeIdFilters: Array<string | mongoose.Types.ObjectId> = [\n      employeeId,\n    ];\n    if (mongoose.Types.ObjectId.isValid(employeeId)) {\n      employeeIdFilters.push(new mongoose.Types.ObjectId(employeeId));\n    }\n\n    // Resolve employeeId to include both employee.id and _id forms\n    try {\n      if (mongoose.Types.ObjectId.isValid(employeeId)) {\n        const employeeDoc = await Employee.findById(employeeId).select(\"id\").lean();\n        const employeeExternalId = (employeeDoc as any)?.id;\n        if (employeeExternalId) {\n          employeeIdFilters.push(String(employeeExternalId));\n        }\n      } else {\n        const employeeDoc = await Employee.findOne({ id: employeeId }).select(\"_id\").lean();\n        const resolvedId = (employeeDoc as any)?._id?.toString?.() || (employeeDoc as any)?._id;\n        if (resolvedId && mongoose.Types.ObjectId.isValid(resolvedId)) {\n          employeeIdFilters.push(new mongoose.Types.ObjectId(resolvedId));\n        }\n      }\n    } catch (resolveError) {\n      console.warn(\"‚ö†Ô∏è Failed to resolve employeeId mapping:\", resolveError);\n    }\n\n    console.log(\n      `üìä Employee details for ${employeeId} - Date range: ${dateRange} (raw: ${String(rawDateRange)}), Page: ${pageNum}, Limit: ${limitNum}`,\n    );\n    console.log(\"üîé EmployeeId filters:\", employeeIdFilters);\n\n    const startIso = start.toISOString();\n    const endIso = end.toISOString();\n    const mixedStartTimeRangeFilter = {\n      $or: [\n        { startTime: { $gte: startIso, $lte: endIso } }, // startTime stored as string\n        { startTime: { $gte: start, $lte: end } }, // startTime stored as Date\n      ],\n    };\n    const meetingsSelectFields = shouldIncludeAttachments\n      ? \"employeeId startTime endTime clientName leadId status notes externalMeetingStatus meetingDetails location approvalStatus approvalReason approvedBy attachments\"\n      : \"employeeId startTime endTime clientName leadId status notes externalMeetingStatus location approvalStatus approvalReason approvedBy meetingDetails.discussion meetingDetails.customers meetingDetails.customerEmployeeName meetingDetails.incomplete meetingDetails.incompleteReason\";\n\n    // PARALLELIZE DATA FETCHING\n    const [\n      externalUsers,\n      meetingsData,\n      meetingsCount,\n      trackingSessionsData,\n      attendanceRecords,\n      dayMeetingsAggregate\n    ] = await Promise.allSettled([\n      // Get external users from cache\n      cacheService.getExternalUsers(),\n\n      // Fetch meetings with date range filter and pagination\n      Meeting.find({\n        employeeId: { $in: employeeIdFilters },\n        ...mixedStartTimeRangeFilter,\n      })\n        .select(meetingsSelectFields)\n        .sort({ startTime: -1 }) // Sort by latest first\n        .skip(skip)\n        .limit(limitNum)\n        .lean()\n        .exec(),\n\n      // Get total count of meetings for pagination\n      Meeting.countDocuments({\n        employeeId: { $in: employeeIdFilters },\n        ...mixedStartTimeRangeFilter,\n      }),\n\n      // Fetch tracking sessions with date range filter\n      TrackingSession.find({\n        employeeId: { $in: employeeIdFilters },\n        ...mixedStartTimeRangeFilter,\n      })\n        .select('startTime endTime startLocation endLocation status duration')\n        .lean()\n        .exec(),\n\n      // Fetch attendance records\n      Attendance.find({\n        employeeId: { $in: employeeIdFilters },\n        date: {\n          $gte: format(start, \"yyyy-MM-dd\"),\n          $lte: format(end, \"yyyy-MM-dd\")\n        }\n      })\n        .select('date attendanceStatus attendanceReason attendenceCreated')\n        .lean()\n        .exec(),\n\n      // Aggregate day-level meeting stats in MongoDB (faster than loading all rows)\n      Meeting.aggregate([\n        {\n          $match: {\n            employeeId: { $in: employeeIdFilters },\n            ...mixedStartTimeRangeFilter,\n          },\n        },\n        {\n          $addFields: {\n            startDateObj: {\n              $convert: {\n                input: \"$startTime\",\n                to: \"date\",\n                onError: null,\n                onNull: null,\n              },\n            },\n            endDateObj: {\n              $convert: {\n                input: \"$endTime\",\n                to: \"date\",\n                onError: null,\n                onNull: null,\n              },\n            },\n          },\n        },\n        { $match: { startDateObj: { $ne: null } } },\n        {\n          $project: {\n            startTime: 1,\n            endTime: 1,\n            \"location.address\": 1,\n            \"location.endLocation.address\": 1,\n            startDateObj: 1,\n            endDateObj: 1,\n          },\n        },\n        { $sort: { startDateObj: 1 } },\n        {\n          $group: {\n            _id: {\n              $dateToString: { format: \"%Y-%m-%d\", date: \"$startDateObj\" },\n            },\n            totalMeetings: { $sum: 1 },\n            firstStartTime: { $first: \"$startTime\" },\n            firstLocationAddress: { $first: \"$location.address\" },\n            lastEndTime: { $last: \"$endTime\" },\n            lastLocationAddress: { $last: \"$location.address\" },\n            lastEndLocationAddress: { $last: \"$location.endLocation.address\" },\n            meetingTimeMs: {\n              $sum: {\n                $cond: [\n                  { $and: [{ $ne: [\"$startDateObj\", null] }, { $ne: [\"$endDateObj\", null] }] },\n                  { $max: [0, { $subtract: [\"$endDateObj\", \"$startDateObj\"] }] },\n                  0,\n                ],\n              },\n            },\n          },\n        },\n      ]).exec()\n    ]);\n\n    // Handle Promise results\n    const externalUsersResult = externalUsers.status === 'fulfilled' ? externalUsers.value : [];\n    const meetingsDataResult = meetingsData.status === 'fulfilled' ? meetingsData.value : [];\n    const meetingsCountResult = meetingsCount.status === 'fulfilled' ? meetingsCount.value : 0;\n    const trackingSessionsResult = trackingSessionsData.status === 'fulfilled' ? trackingSessionsData.value : [];\n    const attendanceRecordsResult = attendanceRecords.status === 'fulfilled' ? attendanceRecords.value : [];\n    const dayMeetingsAggregateResult = dayMeetingsAggregate.status === 'fulfilled' ? dayMeetingsAggregate.value : [];\n\n    // Log any errors\n    if (externalUsers.status === 'rejected') console.error('Error fetching external users:', externalUsers.reason);\n    if (meetingsData.status === 'rejected') console.error('Error fetching meetings:', meetingsData.reason);\n    if (meetingsCount.status === 'rejected') console.error('Error counting meetings:', meetingsCount.reason);\n    if (trackingSessionsData.status === 'rejected') console.error('Error fetching tracking sessions:', trackingSessionsData.reason);\n    if (attendanceRecords.status === 'rejected') console.error('Error fetching attendance:', attendanceRecords.reason);\n    if (dayMeetingsAggregate.status === 'rejected') console.error('Error aggregating day meetings:', dayMeetingsAggregate.reason);\n\n    let meetings = meetingsDataResult;\n    const trackingSessions = trackingSessionsResult;\n\n    // Safety net: if count says meetings exist but page query returned none (or failed),\n    // refetch with a resilient filter and minimal fields.\n    if (meetingsCountResult > 0 && meetings.length === 0) {\n      try {\n        console.warn(\n          \"‚ö†Ô∏è meetingsCount > 0 but meetings page empty; running fallback meetings fetch\",\n        );\n        meetings = await Meeting.find({\n          employeeId: { $in: employeeIdFilters },\n          ...mixedStartTimeRangeFilter,\n        })\n          .select(meetingsSelectFields)\n          .sort({ startTime: -1 })\n          .skip(skip)\n          .limit(limitNum)\n          .lean()\n          .exec();\n      } catch (meetingsFallbackError) {\n        console.error(\"‚ùå Fallback meetings fetch failed:\", meetingsFallbackError);\n      }\n    }\n\n    console.log(`üìà Fetched data: ${meetings.length} paginated meetings (total count: ${meetingsCountResult}), ${trackingSessions.length} sessions, ${attendanceRecordsResult.length} attendance records, ${dayMeetingsAggregateResult.length} meeting-day aggregates`);\n\n    // Create user map for quick lookups\n    const userMap = new Map(externalUsersResult.map(user => [user._id, user.name]));\n\n    // Resolve display name for the requested employee\n    const normalizedEmployeeIdFilters = employeeIdFilters.map((id) => id.toString());\n    let employeeDisplayName =\n      normalizedEmployeeIdFilters\n        .map((id) => userMap.get(id))\n        .find((name) => typeof name === \"string\" && name.trim().length > 0) || \"\";\n\n    if (!employeeDisplayName) {\n      const meetingEmployeeId = (meetings as any[])?.find((m) => m?.employeeId)?.employeeId;\n      if (meetingEmployeeId) {\n        employeeDisplayName = userMap.get(String(meetingEmployeeId)) || \"\";\n      }\n    }\n\n    if (!employeeDisplayName) {\n      try {\n        const employeeDoc = await Employee.findOne({\n          $or: [\n            { id: employeeId },\n            ...(mongoose.Types.ObjectId.isValid(employeeId)\n              ? [{ _id: new mongoose.Types.ObjectId(employeeId) }]\n              : []),\n          ],\n        })\n          .select(\"name\")\n          .lean();\n        employeeDisplayName = (employeeDoc as any)?.name || \"\";\n      } catch (employeeLookupError) {\n        console.warn(\"‚ö†Ô∏è Failed to resolve employee display name:\", employeeLookupError);\n      }\n    }\n\n    // Map meeting-day aggregate data by date\n    const meetingDayMap = new Map();\n    dayMeetingsAggregateResult.forEach((row: any) => {\n      if (!row?._id) return;\n      meetingDayMap.set(row._id, row);\n    });\n\n    // Fallback/merge path: build day stats from raw meetings only when needed.\n    // To keep this endpoint fast on large data, avoid full-range fallback unless aggregate is empty\n    // or current page meeting dates are missing from day aggregate.\n    const paginatedMeetingDateKeys = new Set<string>();\n    meetings.forEach((meeting: any) => {\n      if (!meeting?.startTime) return;\n      const d = new Date(meeting.startTime);\n      if (!isNaN(d.getTime())) {\n        paginatedMeetingDateKeys.add(format(d, \"yyyy-MM-dd\"));\n      }\n    });\n\n    const missingDayKeysFromPage = Array.from(paginatedMeetingDateKeys).filter(\n      (dateKey) => !meetingDayMap.has(dateKey),\n    );\n\n    if ((meetingDayMap.size === 0 || missingDayKeysFromPage.length > 0) && meetingsCountResult > 0) {\n      try {\n        const fallbackQuery: any = {\n          employeeId: { $in: employeeIdFilters },\n        };\n\n        if (meetingDayMap.size === 0) {\n          fallbackQuery.$or = mixedStartTimeRangeFilter.$or;\n        } else {\n          fallbackQuery.$or = missingDayKeysFromPage.map((dateKey) => ({\n            startTime: { $regex: `^${dateKey}` },\n          }));\n        }\n\n        const fallbackMeetingsForDays = await Meeting.find(fallbackQuery)\n          .select(\"startTime endTime location\")\n          .sort({ startTime: 1 })\n          .lean()\n          .exec();\n\n        fallbackMeetingsForDays.forEach((meeting: any) => {\n          if (!meeting?.startTime) return;\n\n          const startDate = new Date(meeting.startTime);\n          if (isNaN(startDate.getTime())) return;\n\n          const dateKey = format(startDate, \"yyyy-MM-dd\");\n          const existing = meetingDayMap.get(dateKey) || {\n            _id: dateKey,\n            totalMeetings: 0,\n            firstStartTime: \"\",\n            firstLocationAddress: \"\",\n            lastEndTime: \"\",\n            lastLocationAddress: \"\",\n            lastEndLocationAddress: \"\",\n            meetingTimeMs: 0,\n          };\n\n          existing.totalMeetings = (existing.totalMeetings || 0) + 1;\n\n          if (\n            !existing.firstStartTime ||\n            new Date(existing.firstStartTime).getTime() > startDate.getTime()\n          ) {\n            existing.firstStartTime = meeting.startTime;\n            existing.firstLocationAddress =\n              meeting.location?.address || meeting.location?.startLocation?.address || \"\";\n          }\n\n          const endDate = meeting.endTime ? new Date(meeting.endTime) : null;\n          if (endDate && !isNaN(endDate.getTime())) {\n            const existingLastEnd = existing.lastEndTime\n              ? new Date(existing.lastEndTime).getTime()\n              : -1;\n            if (existingLastEnd < endDate.getTime()) {\n              existing.lastEndTime = meeting.endTime;\n              existing.lastLocationAddress =\n                meeting.location?.address || meeting.location?.startLocation?.address || \"\";\n              existing.lastEndLocationAddress =\n                meeting.location?.endLocation?.address || meeting.location?.address || \"\";\n            }\n\n            const meetingDurationMs = endDate.getTime() - startDate.getTime();\n            if (meetingDurationMs > 0) {\n              existing.meetingTimeMs += meetingDurationMs;\n            }\n          }\n\n          meetingDayMap.set(dateKey, existing);\n        });\n\n        console.log(\n          `‚Ü©Ô∏è Merged day aggregates from fallback meetings query (${fallbackMeetingsForDays.length} rows). Total day keys: ${meetingDayMap.size}`,\n        );\n      } catch (fallbackError) {\n        console.error(\"‚ùå Failed fallback day aggregation:\", fallbackError);\n      }\n    }\n\n    const seededMeetingDayKeys = new Set<string>(Array.from(meetingDayMap.keys()));\n\n    // Final hardening: always merge currently fetched meeting rows into day map.\n    // This guarantees dayRecords reflect meetingRecords for visible data, even if\n    // aggregate/fallback queries miss mixed-format rows.\n    meetings.forEach((meeting: any) => {\n      if (!meeting?.startTime) return;\n      const startDateObj = new Date(meeting.startTime);\n      if (isNaN(startDateObj.getTime())) return;\n\n      const dateKey = format(startDateObj, \"yyyy-MM-dd\");\n      const existing = meetingDayMap.get(dateKey) || {\n        _id: dateKey,\n        totalMeetings: 0,\n        firstStartTime: \"\",\n        firstLocationAddress: \"\",\n        lastEndTime: \"\",\n        lastLocationAddress: \"\",\n        lastEndLocationAddress: \"\",\n        meetingTimeMs: 0,\n      };\n\n      if (seededMeetingDayKeys.has(dateKey)) {\n        existing.totalMeetings = existing.totalMeetings || 0;\n      } else {\n        existing.totalMeetings = (existing.totalMeetings || 0) + 1;\n      }\n\n      if (\n        !existing.firstStartTime ||\n        new Date(existing.firstStartTime).getTime() > startDateObj.getTime()\n      ) {\n        existing.firstStartTime = meeting.startTime;\n        existing.firstLocationAddress =\n          meeting.location?.address || meeting.location?.startLocation?.address || \"\";\n      }\n\n      const endDateObj = meeting.endTime ? new Date(meeting.endTime) : null;\n      if (endDateObj && !isNaN(endDateObj.getTime())) {\n        const existingLastEnd = existing.lastEndTime\n          ? new Date(existing.lastEndTime).getTime()\n          : -1;\n        if (existingLastEnd < endDateObj.getTime()) {\n          existing.lastEndTime = meeting.endTime;\n          existing.lastLocationAddress =\n            meeting.location?.address || meeting.location?.startLocation?.address || \"\";\n          existing.lastEndLocationAddress =\n            meeting.location?.endLocation?.address || meeting.location?.address || \"\";\n        }\n      }\n\n      meetingDayMap.set(dateKey, existing);\n    });\n\n    // Group tracking sessions by date\n    const sessionDateGroups = new Map();\n    trackingSessions.forEach(session => {\n      try {\n        const date = format(new Date(session.startTime), \"yyyy-MM-dd\");\n        if (!sessionDateGroups.has(date)) {\n          sessionDateGroups.set(date, []);\n        }\n        sessionDateGroups.get(date).push(session);\n      } catch (error) {\n        console.error('Error processing session date:', error);\n      }\n    });\n\n    const today = new Date();\n    today.setHours(23, 59, 59, 999);\n\n    // Build day list:\n    // - \"all\": only dates where activity exists (meetings/sessions/attendance)\n    // - others: full range up to today\n    let allDatesInRange: string[] = [];\n    if (isAllRange) {\n      const dateSet = new Set<string>();\n      meetingDayMap.forEach((_v, key) => dateSet.add(key));\n      sessionDateGroups.forEach((_v, key) => dateSet.add(key));\n      attendanceRecordsResult.forEach((att: any) => {\n        if (att?.date) dateSet.add(att.date);\n      });\n\n      allDatesInRange = Array.from(dateSet).filter((dateStr) => {\n        const d = new Date(dateStr);\n        return !isNaN(d.getTime()) && d <= today;\n      });\n\n      // Safety net: if dateSet unexpectedly empty while meetings exist, use meeting dates.\n      if (allDatesInRange.length === 0 && meetings.length > 0) {\n        const meetingDates = new Set<string>();\n        meetings.forEach((meeting: any) => {\n          if (!meeting?.startTime) return;\n          const d = new Date(meeting.startTime);\n          if (!isNaN(d.getTime()) && d <= today) {\n            meetingDates.add(format(d, \"yyyy-MM-dd\"));\n          }\n        });\n        allDatesInRange = Array.from(meetingDates);\n      }\n    } else {\n      const currentDate = new Date(start);\n      while (currentDate <= end && currentDate <= today) {\n        allDatesInRange.push(format(currentDate, \"yyyy-MM-dd\"));\n        currentDate.setDate(currentDate.getDate() + 1);\n      }\n    }\n\n    console.log(`üìÖ Building day records from ${allDatesInRange.length} dates`);\n\n    // Generate day records from aggregate + session fallback\n    const dayRecords = allDatesInRange.map((date) => {\n      const meetingDay = meetingDayMap.get(date);\n      const sessions = sessionDateGroups.get(date) || [];\n\n      const totalMeetings = meetingDay?.totalMeetings || 0;\n      const startLocationTime = meetingDay?.firstStartTime\n        ? format(new Date(meetingDay.firstStartTime), \"HH:mm:ss\")\n        : \"\";\n      const startLocationAddress =\n        meetingDay?.firstLocationAddress || meetingDay?.firstStartLocationAddress || \"\";\n      const outLocationTime = meetingDay?.lastEndTime\n        ? format(new Date(meetingDay.lastEndTime), \"HH:mm:ss\")\n        : \"\";\n      const outLocationAddress =\n        meetingDay?.lastEndLocationAddress || meetingDay?.lastLocationAddress || \"\";\n\n      // meetingTime is defined as first meeting start to last meeting end span\n      let meetingTimeHours = 0;\n      if (meetingDay?.firstStartTime && meetingDay?.lastEndTime) {\n        try {\n          const meetingStart = new Date(meetingDay.firstStartTime);\n          const meetingEnd = new Date(meetingDay.lastEndTime);\n          const spanHours = (meetingEnd.getTime() - meetingStart.getTime()) / (1000 * 60 * 60);\n          meetingTimeHours = Math.max(0, spanHours);\n        } catch {\n          meetingTimeHours = 0;\n        }\n      } else if (meetingDay?.firstStartTime) {\n        // Ongoing day: span till now\n        try {\n          const meetingStart = new Date(meetingDay.firstStartTime);\n          meetingTimeHours = Math.max(\n            0,\n            (new Date().getTime() - meetingStart.getTime()) / (1000 * 60 * 60),\n          );\n        } catch {\n          meetingTimeHours = 0;\n        }\n      }\n\n      // Calculate duty hours (meeting span, fallback to tracking sessions)\n      let totalDutyHours = 0;\n      if (meetingDay?.firstStartTime && meetingDay?.lastEndTime) {\n        try {\n          const dutyStart = new Date(meetingDay.firstStartTime);\n          const dutyEnd = new Date(meetingDay.lastEndTime);\n          const dutyDuration = (dutyEnd.getTime() - dutyStart.getTime()) / (1000 * 60 * 60);\n          totalDutyHours = Math.max(0, dutyDuration);\n        } catch (error) {\n          console.error(\"Error calculating duty hours:\", error);\n          totalDutyHours = 0;\n        }\n      } else if (meetingDay?.firstStartTime) {\n        // Only start time available (ongoing meeting)\n        try {\n          const dutyStart = new Date(meetingDay.firstStartTime);\n          const now = new Date();\n          const dutyDuration = (now.getTime() - dutyStart.getTime()) / (1000 * 60 * 60);\n          totalDutyHours = Math.max(0, dutyDuration);\n        } catch (error) {\n          totalDutyHours = 0;\n        }\n      }\n\n      // Fallback duty from sessions if no meeting span exists\n      if (totalDutyHours === 0 && sessions.length > 0) {\n        totalDutyHours = sessions.reduce((acc: number, session: any) => {\n          if (!session?.startTime || !session?.endTime) return acc;\n          try {\n            const s = new Date(session.startTime);\n            const e = new Date(session.endTime);\n            const h = (e.getTime() - s.getTime()) / (1000 * 60 * 60);\n            return h > 0 ? acc + h : acc;\n          } catch {\n            return acc;\n          }\n        }, 0);\n      }\n\n      // Get attendance info\n      const attendance = attendanceRecordsResult.find(att => att.date === date);\n      const attendanceAddedBy = attendance?.attendenceCreated\n        ? userMap.get(attendance.attendenceCreated) || attendance.attendenceCreated\n        : null;\n\n      return {\n        date,\n        totalMeetings,\n        startLocationTime,\n        startLocationAddress,\n        outLocationTime,\n        outLocationAddress,\n        totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\n        meetingTime: parseFloat(meetingTimeHours.toFixed(2)),\n        travelAndLunchTime: Math.max(0, parseFloat((totalDutyHours - meetingTimeHours).toFixed(2))),\n        attendanceAddedBy\n      };\n    });\n\n    // Generate meeting records from PAGINATED meetings only\n    const meetingRecords = meetings.map((meeting) => {\n      const meetingDetails = meeting.meetingDetails as any;\n      const meetingInTime = meeting.startTime ? format(new Date(meeting.startTime), \"HH:mm:ss\") : \"\";\n      const meetingOutTime = meeting.endTime\n        ? format(new Date(meeting.endTime), \"HH:mm:ss\")\n        : \"In Progress\";\n\n      // üîπ FIX: Smart logic for meetingOutLocation\n      let meetingOutLocation = \"Meeting in progress\";\n      \n      if (meeting.endTime) {\n        const endLocation = (meeting.location as any)?.endLocation;\n        if (endLocation?.address) {\n          const endAddr = endLocation.address;\n          \n          // Check if it's just coordinates (e.g., \"28.277276, 76.885777\")\n          const isCoordinates = /^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$/.test(endAddr);\n          \n          if (isCoordinates) {\n            // If end location is coordinates, try to use the start address\n            meetingOutLocation = meeting.location?.address || \"Location coordinates\";\n          } else {\n            // Use the proper end address\n            meetingOutLocation = endAddr;\n          }\n        } else if (meeting.status === \"completed\") {\n          // No endLocation but meeting is completed - use start address\n          console.log(\"meeting.location?.address\",meeting.location?.address);\n          meetingOutLocation = meeting.location?.address || \"Meeting completed\";\n        }\n      }\n\n      // üîπ FIX: Smart logic for meetingPerson\n      let meetingPerson = \"TBD\";\n      if (meeting.status === \"completed\") {\n        if (meeting.meetingDetails?.customers?.length > 0) {\n          meetingPerson = meeting.meetingDetails.customers\n            .map((customer) => customer.customerEmployeeName)\n            .join(\", \");\n        } else if (meeting.meetingDetails?.customerEmployeeName) {\n          meetingPerson = meeting.meetingDetails.customerEmployeeName;\n        } else {\n          meetingPerson = \"Unknown\";\n        }\n      }\n\n      // üîπ FIX: Smart logic for discussion\n      let discussion = \"\";\n      if (meeting.status === \"completed\") {\n        discussion = meeting.meetingDetails?.discussion || meeting.notes || \"\";\n      } else {\n        discussion = \"Meeting in progress\";\n      }\n\n      return {\n        meetingId: meeting._id?.toString() || meeting.id,\n        employeeName: employeeDisplayName || \"Unknown Employee\",\n        companyName: meeting.clientName || \"Unknown Company\",\n        date: meeting.startTime ? format(new Date(meeting.startTime), \"yyyy-MM-dd\") : \"\",\n        leadId: meeting.leadId || \"\",\n        meetingInTime,\n        meetingInLocation: meeting.location?.address || \"Location not available\",\n        meetingOutTime,\n        meetingOutLocation, // Use the fixed value\n        totalStayTime: calculateMeetingDuration(meeting.startTime, meeting.endTime),\n        discussion,\n        meetingPerson,\n        meetingStatus: meeting.status || \"completed\",\n        externalMeetingStatus: meeting.externalMeetingStatus || \"\",\n        incomplete: meetingDetails?.incomplete || false,\n        incompleteReason: meetingDetails?.incompleteReason || \"\",\n        approvalStatus: meeting.approvalStatus || undefined,\n        approvalReason: meeting.approvalReason || undefined,\n        approvedBy: meeting.approvedBy || undefined,\n        approvedByName: meeting.approvedBy ? userMap.get(meeting.approvedBy) || meeting.approvedBy : undefined,\n        attachments: shouldIncludeAttachments\n          ? meeting.meetingDetails?.attachments || meeting.attachments || []\n          : [],\n      };\n    });\n\n    // Apply pagination to dayRecords\n    // First filter out future dates and sort in DESCENDING order (newest first)\n    const todayDate = new Date();\n    const todayStr = format(todayDate, \"yyyy-MM-dd\");\n    const validDayRecords = dayRecords.filter(record => {\n      try {\n        const recordDate = new Date(record.date);\n        return recordDate <= todayDate;\n      } catch {\n        return true;\n      }\n    });\n\n    const dayRecordsSorted = validDayRecords.sort((a, b) => {\n      try {\n        return new Date(b.date).getTime() - new Date(a.date).getTime();\n      } catch {\n        return 0;\n      }\n    });\n\n    const totalDayRecords = dayRecordsSorted.length;\n    const dayRecordsTotalPages = Math.ceil(totalDayRecords / limitNum);\n    const dayRecordsStartIndex = (pageNum - 1) * limitNum;\n    const dayRecordsEndIndex = dayRecordsStartIndex + limitNum;\n    const paginatedDayRecords = dayRecordsSorted.slice(dayRecordsStartIndex, dayRecordsEndIndex);\n\n    console.log(`üìÖ Day records: ${totalDayRecords} valid dates (filtered future dates), showing ${paginatedDayRecords.length} on page ${pageNum}`);\n\n    // Calculate pagination info\n    const totalPages = Math.ceil(meetingsCountResult / limitNum);\n    const hasNextPage = pageNum < totalPages;\n    const hasPreviousPage = pageNum > 1;\n\n    const result = {\n      pagination: {\n        currentPage: pageNum,\n        pageSize: limitNum,\n        totalItems: meetingsCountResult,\n        totalPages: totalPages,\n        hasNextPage,\n        hasPreviousPage,\n        nextPage: hasNextPage ? pageNum + 1 : null,\n        previousPage: hasPreviousPage ? pageNum - 1 : null,\n      },\n      dayRecordsPagination: {\n        currentPage: pageNum,\n        pageSize: limitNum,\n        totalItems: totalDayRecords,\n        totalPages: dayRecordsTotalPages,\n        hasNextDayRecordsPage: pageNum < dayRecordsTotalPages,\n        hasPreviousDayRecordsPage: pageNum > 1,\n      },\n      dayRecords: paginatedDayRecords,\n      meetingRecords: meetingRecords.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()),\n    };\n\n    const endTime = Date.now();\n    console.log(`‚úÖ Employee details fetched in ${endTime - startTime}ms`);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\"Error fetching employee details:\", error);\n    console.error(\"Error details:\", error.message);\n    console.error(\"Error stack:\", error.stack);\n    res.status(500).json({\n      error: \"Failed to fetch employee details\",\n      message: error.message\n    });\n  }\n};\n\nexport const getLeadHistory: RequestHandler = async (req, res) => {\n  try {\n    const { leadId } = req.params;\n\n    console.log(`Fetching history for lead: ${leadId}`);\n\n    // Get actual meeting data from MongoDB\n    let actualMeetings: any[] = [];\n\n    try {\n      // Try to get meetings from MongoDB first\n      const mongoMeetings = await Meeting.find({ leadId }).lean();\n\n      actualMeetings = mongoMeetings.map(meeting => ({\n        id: meeting._id.toString(),\n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime,\n        endTime: meeting.endTime,\n        clientName: meeting.clientName,\n        leadId: meeting.leadId,\n        status: meeting.status,\n        meetingDetails: meeting.meetingDetails,\n        location: meeting.location,\n        leadInfo: meeting.leadInfo\n      }));\n\n      console.log(`Found ${actualMeetings.length} meetings in MongoDB for lead ${leadId}`);\n\n      // If no MongoDB data, fallback to in-memory\n      if (actualMeetings.length === 0) {\n        const { inMemoryMeetings } = await import('./meetings');\n        actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory for lead ${leadId}`);\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\n      const { inMemoryMeetings } = await import('./meetings');\n      actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\n    }\n\n    // Filter meetings by lead ID\n    const leadMeetings = actualMeetings.filter(meeting => meeting.leadId === leadId);\n\n    console.log(`Found ${leadMeetings.length} meetings for lead ${leadId}`);\n\n    // Get employee data for names\n    const externalUsers = await fetchExternalUsers();\n    const employees = externalUsers.map((user, index) => mapExternalUserToEmployee(user, index));\n\n    // Generate history records\n    const history = leadMeetings.map(meeting => {\n      const employee = employees.find(emp => emp.id === meeting.employeeId);\n      const duration = calculateMeetingDuration(meeting.startTime, meeting.endTime);\n\n      return {\n        date: meeting.startTime,\n        employeeName: employee?.name || \"Unknown Employee\",\n        companyName: meeting.clientName || \"Unknown Company\",\n        duration,\n        meetingPerson: meeting.meetingDetails?.customers?.length > 0\n          ? meeting.meetingDetails.customers.map(customer => customer.customerEmployeeName).join(\", \")\n          : meeting.meetingDetails?.customerEmployeeName || \"Unknown\",\n        discussion: meeting.meetingDetails?.discussion || meeting.notes || \"\",\n        status: meeting.status || \"completed\",\n        location: meeting.location?.address || \"\",\n        leadInfo: meeting.leadInfo,\n      };\n    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n    res.json({\n      leadId,\n      history,\n      totalMeetings: history.length,\n      totalDuration: history.reduce((sum, record) => sum + record.duration, 0),\n    });\n\n  } catch (error) {\n    console.error(\"Error fetching lead history:\", error);\n    res.status(500).json({ error: \"Failed to fetch lead history\" });\n  }\n};\n\nexport const saveAttendance: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, date, attendanceStatus, attendanceReason, attendenceCreated } = req.body;\n\n    console.log(`Saving attendance for employee ${employeeId} on ${date}:`, {\n      attendanceStatus,\n      attendanceReason,\n      attendenceCreated\n    });\n\n    // Validate required fields\n    if (!employeeId || !date || !attendanceStatus) {\n      return res.status(400).json({\n        error: \"Employee ID, date, and attendance status are required\"\n      });\n    }\n\n    // Validate attendance status\n    const validStatuses = [\"full_day\", \"half_day\", \"off\", \"short_leave\", \"ot\", \"absent\"];\n    if (!validStatuses.includes(attendanceStatus)) {\n      return res.status(400).json({\n        error: \"Invalid attendance status\"\n      });\n    }\n\n    // Validate date format (YYYY-MM-DD)\n    if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n      return res.status(400).json({\n        error: \"Date must be in YYYY-MM-DD format\"\n      });\n    }\n\n    try {\n      // Try to save to MongoDB using upsert (update if exists, create if not)\n      const savedAttendance = await Attendance.findOneAndUpdate(\n        { employeeId, date },\n        {\n          employeeId,\n          date,\n          attendanceStatus,\n          attendanceReason: attendanceReason || \"\",\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null // Default to null if not provided\n        },\n        {\n          new: true,\n          upsert: true,\n          runValidators: true\n        }\n      );\n\n      console.log(\"Attendance saved to MongoDB:\", savedAttendance._id);\n      console.log(\"Attendance attendenceCreated value:\", savedAttendance.attendenceCreated);\n\n      res.json({\n        success: true,\n        message: \"Attendance saved successfully\",\n        data: {\n          id: savedAttendance._id,\n          employeeId: savedAttendance.employeeId,\n          date: savedAttendance.date,\n          attendanceStatus: savedAttendance.attendanceStatus,\n          attendanceReason: savedAttendance.attendanceReason,\n          attendenceCreated: savedAttendance.attendenceCreated,\n          savedAt: savedAttendance.updatedAt\n        }\n      });\n\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, using fallback:\", dbError);\n\n      // Fallback response (in real app, might save to alternative storage)\n      res.json({\n        success: true,\n        message: \"Attendance saved successfully (fallback mode)\",\n        data: {\n          employeeId,\n          date,\n          attendanceStatus,\n          attendanceReason,\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null,\n          savedAt: new Date().toISOString()\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error(\"Error saving attendance:\", error);\n    res.status(500).json({ error: \"Failed to save attendance\" });\n  }\n};\n\nexport const getMeetingTrends: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, period = \"week\" } = req.query;\n\n    // This would calculate meeting trends over time\n    // For now, return mock data\n    const trends = {\n      labels: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n      datasets: [\n        {\n          label: \"Meetings\",\n          data: [2, 4, 3, 5, 2, 1, 0],\n        },\n        {\n          label: \"Hours\",\n          data: [4, 8, 6, 10, 4, 2, 0],\n        },\n      ],\n    };\n\n    res.json(trends);\n  } catch (error) {\n    console.error(\"Error fetching meeting trends:\", error);\n    res.status(500).json({ error: \"Failed to fetch trends\" });\n  }\n};\n\nexport const getAttendance: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, startDate, endDate, date } = req.query;\n\n    console.log(`Fetching attendance records:`, {\n      employeeId,\n      startDate,\n      endDate,\n      date\n    });\n\n    // Build query filter\n    const filter: any = {};\n\n    if (employeeId) {\n      filter.employeeId = employeeId;\n    }\n\n    if (date) {\n      // Single date query\n      filter.date = date;\n    } else if (startDate && endDate) {\n      // Date range query\n      filter.date = {\n        $gte: startDate,\n        $lte: endDate\n      };\n    }\n\n    try {\n      // Fetch from MongoDB\n      const attendanceRecords = await Attendance.find(filter)\n        .sort({ date: -1 })\n        .lean();\n\n      console.log(`Found ${attendanceRecords.length} attendance records`);\n\n      // Fetch external users to map attendenceCreated IDs to names\n      const externalUsers = await fetchExternalUsers();\n      const userMap = new Map(externalUsers.map(user => [user._id, user.name]));\n\n      // Format the response\n      const formattedRecords = attendanceRecords.map(record => ({\n        id: record._id.toString(),\n        employeeId: record.employeeId,\n        date: record.date,\n        attendanceStatus: record.attendanceStatus,\n        attendanceReason: record.attendanceReason || \"\",\n        attendenceCreated: record.attendenceCreated,\n        attendenceCreatedName: record.attendenceCreated\n          ? userMap.get(record.attendenceCreated) || record.attendenceCreated\n          : null,\n        savedAt: record.updatedAt || record.createdAt\n      }));\n\n      res.json({\n        success: true,\n        count: formattedRecords.length,\n        data: formattedRecords\n      });\n\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed:\", dbError);\n\n      // Fallback response\n      res.json({\n        success: true,\n        count: 0,\n        data: [],\n        message: \"No attendance records found (database unavailable)\"\n      });\n    }\n\n  } catch (error) {\n    console.error(\"Error fetching attendance:\", error);\n    res.status(500).json({\n      success: false,\n      error: \"Failed to fetch attendance records\"\n    });\n  }\n};\n\nexport const getAllEmployeesDetails: RequestHandler = async (req, res) => {\n  try {\n    const {\n      dateRange: rawDateRange = \"today\",\n      startDate,\n      endDate,\n      page = \"1\",\n      limit = \"10\",\n      search = \"\",\n      sortBy = \"employeeName\",\n      sortOrder = \"asc\"\n    } = req.query;\n    const dateRange = String(rawDateRange || \"today\").trim().toLowerCase();\n    const isAllRange = dateRange === \"all\";\n\n    // Start timing\n    const startTime = Date.now();\n\n    // Parse pagination parameters\n    const pageNum = parseInt(page as string, 10) || 1;\n    const limitNum = parseInt(limit as string, 10) || 10;\n    const skip = (pageNum - 1) * limitNum;\n\n    // Get date range\n    const { start, end } = getDateRange(dateRange, startDate as string, endDate as string);\n\n    console.log(`üìä All employees details - Date range: ${dateRange}, Page: ${pageNum}, Limit: ${limitNum}, Search: \"${search}\"`);\n\n    // STEP 1: Get ALL employees from external API\n    const externalUsers = await cacheService.getExternalUsers();\n    console.log(`Found ${externalUsers.length} total employees from cache`);\n\n    // STEP 2: Map all employees\n    let allEmployees = externalUsers.map((user, index) => {\n      const employee = mapExternalUserToEmployee(user, index);\n      return {\n        ...employee,\n        userId: user._id\n      };\n    });\n\n    console.log(`Mapped ${allEmployees.length} total employees`);\n\n    // STEP 3: Apply search filter if provided\n    if (search) {\n      const searchLower = (search as string).toLowerCase();\n      allEmployees = allEmployees.filter(emp =>\n        emp.name.toLowerCase().includes(searchLower) ||\n        emp.email.toLowerCase().includes(searchLower) ||\n        emp.designation?.toLowerCase().includes(searchLower) ||\n        emp.department?.toLowerCase().includes(searchLower)\n      );\n      console.log(`Filtered to ${allEmployees.length} employees after search`);\n    }\n\n    // If no employees after search, return empty result\n    if (allEmployees.length === 0) {\n      const endTime = Date.now();\n      console.log(`‚úÖ No employees found after search in ${endTime - startTime}ms`);\n\n      return res.json({\n        success: true,\n        dateRange: {\n          start: start.toISOString(),\n          end: end.toISOString(),\n          label: dateRange,\n        },\n        pagination: {\n          currentPage: pageNum,\n          pageSize: limitNum,\n          totalItems: 0,\n          totalPages: 0,\n          hasNextPage: false,\n          hasPreviousPage: false,\n          nextPage: null,\n          previousPage: null,\n        },\n        search: search || null,\n        sort: {\n          by: sortBy,\n          order: sortOrder\n        },\n        employees: [],\n      });\n    }\n\n    // Fast fail-safe for local/prod DB outages: don't wait for Mongo timeout.\n    if (!Database.getInstance().isConnectionActive()) {\n      console.warn(\n        \"‚ö†Ô∏è Database connection not active for all-employees-details; returning degraded response.\",\n      );\n\n      const sortDirection = sortOrder === \"desc\" ? -1 : 1;\n      const sortedEmployees = [...allEmployees].sort((a, b) => {\n        switch (sortBy) {\n          case \"employeeName\":\n            return sortDirection * a.name.localeCompare(b.name);\n          case \"email\":\n            return sortDirection * (a.email || \"\").localeCompare(b.email || \"\");\n          case \"designation\":\n            return sortDirection * (a.designation || \"\").localeCompare(b.designation || \"\");\n          case \"department\":\n            return sortDirection * (a.department || \"\").localeCompare(b.department || \"\");\n          default:\n            return sortDirection * a.name.localeCompare(b.name);\n        }\n      });\n\n      const totalEmployees = sortedEmployees.length;\n      const totalPages = Math.ceil(totalEmployees / limitNum);\n      const paginatedEmployees = sortedEmployees.slice(skip, skip + limitNum);\n\n      return res.json({\n        success: true,\n        degraded: true,\n        degradedReason: \"database_not_connected\",\n        dateRange: {\n          start: start.toISOString(),\n          end: end.toISOString(),\n          label: dateRange,\n        },\n        pagination: {\n          currentPage: pageNum,\n          pageSize: limitNum,\n          totalItems: totalEmployees,\n          totalPages,\n          hasNextPage: pageNum < totalPages,\n          hasPreviousPage: pageNum > 1,\n          nextPage: pageNum < totalPages ? pageNum + 1 : null,\n          previousPage: pageNum > 1 ? pageNum - 1 : null,\n        },\n        search: search || null,\n        sort: {\n          by: sortBy,\n          order: sortOrder,\n        },\n        employees: paginatedEmployees.map((employee) => ({\n          employeeId: employee.id,\n          employeeName: employee.name,\n          email: employee.email,\n          phone: employee.phone,\n          designation: employee.designation,\n          department: employee.department,\n          companyName: employee.companyName,\n          reportTo: employee.reportTo,\n          status: employee.status,\n          summary: {\n            totalMeetings: 0,\n            totalMeetingHours: 0,\n            daysWithMeetings: 0,\n            avgMeetingsPerDay: 0,\n          },\n          dayRecords: [],\n          meetingRecords: [],\n        })),\n      });\n    }\n\n    // STEP 4: Get employee IDs for all employees\n    const employeeIds = allEmployees.map((emp) => (emp.userId || emp.id).toString());\n    const employeeIdsSet = new Set<string>(employeeIds);\n    const startIso = start.toISOString();\n    const endIso = end.toISOString();\n    const mixedStartTimeRangeFilter = {\n      $or: [\n        { startTime: { $gte: start, $lte: end } },\n        { startTime: { $gte: startIso, $lte: endIso } },\n      ],\n    };\n\n    // STEP 5: Fetch only DISTINCT employee IDs with activity (fast for wide date ranges)\n    // For \"all\", avoid expensive wide date-range predicates entirely.\n    const meetingActivityFilter: any = isAllRange\n      ? { employeeId: { $in: employeeIds } }\n      : {\n          employeeId: { $in: employeeIds },\n          ...mixedStartTimeRangeFilter,\n        };\n    const attendanceActivityFilter: any = isAllRange\n      ? { employeeId: { $in: employeeIds } }\n      : {\n          employeeId: { $in: employeeIds },\n          date: {\n            $gte: format(start, \"yyyy-MM-dd\"),\n            $lte: format(end, \"yyyy-MM-dd\"),\n          },\n        };\n    const trackingActivityFilter: any = isAllRange\n      ? { employeeId: { $in: employeeIds } }\n      : {\n          employeeId: { $in: employeeIds },\n          ...mixedStartTimeRangeFilter,\n        };\n\n    const [\n      meetingEmployeeIdsResult,\n      attendanceEmployeeIdsResult,\n      trackingEmployeeIdsResult,\n    ] = await Promise.allSettled([\n      Meeting.distinct(\"employeeId\", meetingActivityFilter).maxTimeMS(30000),\n      Attendance.distinct(\"employeeId\", attendanceActivityFilter).maxTimeMS(20000),\n      TrackingSession.distinct(\"employeeId\", trackingActivityFilter).maxTimeMS(20000),\n    ]);\n\n    const meetingEmployeeIds =\n      meetingEmployeeIdsResult.status === \"fulfilled\"\n        ? meetingEmployeeIdsResult.value\n        : [];\n    const attendanceEmployeeIds =\n      attendanceEmployeeIdsResult.status === \"fulfilled\"\n        ? attendanceEmployeeIdsResult.value\n        : [];\n    const trackingEmployeeIds =\n      trackingEmployeeIdsResult.status === \"fulfilled\"\n        ? trackingEmployeeIdsResult.value\n        : [];\n\n    if (meetingEmployeeIdsResult.status === \"rejected\") {\n      console.error(\"‚ùå all-employees activity fetch (meetings) failed:\", meetingEmployeeIdsResult.reason);\n    }\n    if (attendanceEmployeeIdsResult.status === \"rejected\") {\n      console.error(\n        \"‚ùå all-employees activity fetch (attendance) failed:\",\n        attendanceEmployeeIdsResult.reason,\n      );\n    }\n    if (trackingEmployeeIdsResult.status === \"rejected\") {\n      console.error(\"‚ùå all-employees activity fetch (tracking) failed:\", trackingEmployeeIdsResult.reason);\n    }\n\n    console.log(\n      `üìÖ Activity IDs - meetings: ${meetingEmployeeIds.length}, attendance: ${attendanceEmployeeIds.length}, tracking: ${trackingEmployeeIds.length}`,\n    );\n\n    const employeesWithActivity = new Set<string>();\n    meetingEmployeeIds.forEach((id: any) => {\n      const key = String(id);\n      if (employeeIdsSet.has(key)) employeesWithActivity.add(key);\n    });\n    attendanceEmployeeIds.forEach((id: any) => {\n      const key = String(id);\n      if (employeeIdsSet.has(key)) employeesWithActivity.add(key);\n    });\n    trackingEmployeeIds.forEach((id: any) => {\n      const key = String(id);\n      if (employeeIdsSet.has(key)) employeesWithActivity.add(key);\n    });\n\n    const activityQueriesFailed =\n      meetingEmployeeIdsResult.status === \"rejected\" &&\n      attendanceEmployeeIdsResult.status === \"rejected\" &&\n      trackingEmployeeIdsResult.status === \"rejected\";\n\n    // Fallback: if all activity queries failed (usually DB timeout), avoid hard failure.\n    const employeesWithData = activityQueriesFailed\n      ? allEmployees\n      : allEmployees.filter((emp) =>\n          employeesWithActivity.has((emp.userId || emp.id).toString()),\n        );\n\n    if (activityQueriesFailed) {\n      console.warn(\n        \"‚ö†Ô∏è All activity queries failed, falling back to unfiltered employee list for this request.\",\n      );\n    }\n\n\n    console.log(`Filtered to ${employeesWithData.length} employees with data`);\n\n    // If no employees with data, return empty result\n    if (employeesWithData.length === 0) {\n      const endTime = Date.now();\n      console.log(`‚úÖ No employees with activity found in ${endTime - startTime}ms`);\n\n      return res.json({\n        success: true,\n        dateRange: {\n          start: start.toISOString(),\n          end: end.toISOString(),\n          label: dateRange,\n        },\n        pagination: {\n          currentPage: pageNum,\n          pageSize: limitNum,\n          totalItems: 0,\n          totalPages: 0,\n          hasNextPage: false,\n          hasPreviousPage: false,\n          nextPage: null,\n          previousPage: null,\n        },\n        search: search || null,\n        sort: {\n          by: sortBy,\n          order: sortOrder\n        },\n        employees: [],\n      });\n    }\n\n    // STEP 8: Sort employees with data\n    const sortDirection = sortOrder === 'desc' ? -1 : 1;\n    employeesWithData.sort((a, b) => {\n      switch (sortBy) {\n        case 'employeeName':\n          return sortDirection * a.name.localeCompare(b.name);\n        case 'email':\n          return sortDirection * (a.email || '').localeCompare(b.email || '');\n        case 'designation':\n          return sortDirection * (a.designation || '').localeCompare(b.designation || '');\n        case 'department':\n          return sortDirection * (a.department || '').localeCompare(b.department || '');\n        default:\n          return sortDirection * a.name.localeCompare(b.name);\n      }\n    });\n\n    // STEP 9: Apply pagination to filtered employees\n    const totalEmployees = employeesWithData.length;\n    const totalPages = Math.ceil(totalEmployees / limitNum);\n    const paginatedEmployees = employeesWithData.slice(skip, skip + limitNum);\n\n    console.log(`üìÑ Showing ${paginatedEmployees.length} employees with data (page ${pageNum} of ${totalPages})`);\n\n    // If no paginated employees, return empty\n    if (paginatedEmployees.length === 0) {\n      const endTime = Date.now();\n      console.log(`‚úÖ Process completed in ${endTime - startTime}ms`);\n\n      return res.json({\n        success: true,\n        dateRange: {\n          start: start.toISOString(),\n          end: end.toISOString(),\n          label: dateRange,\n        },\n        pagination: {\n          currentPage: pageNum,\n          pageSize: limitNum,\n          totalItems: totalEmployees,\n          totalPages: totalPages,\n          hasNextPage: pageNum < totalPages,\n          hasPreviousPage: pageNum > 1,\n          nextPage: pageNum < totalPages ? pageNum + 1 : null,\n          previousPage: pageNum > 1 ? pageNum - 1 : null,\n        },\n        search: search || null,\n        sort: {\n          by: sortBy,\n          order: sortOrder\n        },\n        employees: [],\n      });\n    }\n\n    // STEP 10: Fetch detailed records only for paginated employees\n    const paginatedEmployeeIds = paginatedEmployees.map((emp) => (emp.userId || emp.id).toString());\n    const [\n      meetingsForPaginatedEmployeesResult,\n      attendanceForPaginatedEmployeesResult,\n      trackingSessionsForPaginatedEmployeesResult,\n    ] = await Promise.allSettled([\n      Meeting.find({\n        employeeId: { $in: paginatedEmployeeIds },\n        ...(isAllRange ? {} : mixedStartTimeRangeFilter),\n      })\n        .select(\n          \"employeeId startTime endTime clientName leadId status location meetingDetails.discussion meetingDetails.customerEmployeeName approvalStatus approvalReason approvedBy\",\n        )\n        .sort({ startTime: -1 })\n        .maxTimeMS(60000)\n        .lean()\n        .exec(),\n      Attendance.find({\n        employeeId: { $in: paginatedEmployeeIds },\n        ...(isAllRange\n          ? {}\n          : {\n              date: {\n                $gte: format(start, \"yyyy-MM-dd\"),\n                $lte: format(end, \"yyyy-MM-dd\"),\n              },\n            }),\n      })\n        .select(\"employeeId date attendanceStatus attendanceReason attendenceCreated\")\n        .maxTimeMS(30000)\n        .lean()\n        .exec(),\n      TrackingSession.find({\n        employeeId: { $in: paginatedEmployeeIds },\n        ...(isAllRange ? {} : mixedStartTimeRangeFilter),\n      })\n        .select(\"employeeId startTime endTime startLocation endLocation status duration\")\n        .maxTimeMS(30000)\n        .lean()\n        .exec(),\n    ]);\n\n    const meetingsForPaginatedEmployees =\n      meetingsForPaginatedEmployeesResult.status === \"fulfilled\"\n        ? meetingsForPaginatedEmployeesResult.value\n        : [];\n    const attendanceForPaginatedEmployees =\n      attendanceForPaginatedEmployeesResult.status === \"fulfilled\"\n        ? attendanceForPaginatedEmployeesResult.value\n        : [];\n    const trackingSessionsForPaginatedEmployees =\n      trackingSessionsForPaginatedEmployeesResult.status === \"fulfilled\"\n        ? trackingSessionsForPaginatedEmployeesResult.value\n        : [];\n\n    if (meetingsForPaginatedEmployeesResult.status === \"rejected\") {\n      console.error(\n        \"‚ùå all-employees paginated meetings fetch failed:\",\n        meetingsForPaginatedEmployeesResult.reason,\n      );\n    }\n    if (attendanceForPaginatedEmployeesResult.status === \"rejected\") {\n      console.error(\n        \"‚ùå all-employees paginated attendance fetch failed:\",\n        attendanceForPaginatedEmployeesResult.reason,\n      );\n    }\n    if (trackingSessionsForPaginatedEmployeesResult.status === \"rejected\") {\n      console.error(\n        \"‚ùå all-employees paginated tracking fetch failed:\",\n        trackingSessionsForPaginatedEmployeesResult.reason,\n      );\n    }\n\n    // Group ALL meetings by employee\n    const allMeetingsByEmployee = new Map();\n    meetingsForPaginatedEmployees.forEach(meeting => {\n      if (!allMeetingsByEmployee.has(meeting.employeeId)) {\n        allMeetingsByEmployee.set(meeting.employeeId, []);\n      }\n      allMeetingsByEmployee.get(meeting.employeeId).push(meeting);\n    });\n\n    // Group attendance by employee-date\n    const attendanceByEmployee = new Map();\n    attendanceForPaginatedEmployees.forEach(att => {\n      const key = `${att.employeeId}-${att.date}`;\n      attendanceByEmployee.set(key, att);\n    });\n\n    // Group tracking sessions by employee and date\n    const sessionsByEmployeeDate = new Map();\n    trackingSessionsForPaginatedEmployees.forEach(session => {\n      try {\n        const dateStr = format(new Date(session.startTime), \"yyyy-MM-dd\");\n        const key = `${session.employeeId}-${dateStr}`;\n        if (!sessionsByEmployeeDate.has(key)) {\n          sessionsByEmployeeDate.set(key, []);\n        }\n        sessionsByEmployeeDate.get(key).push(session);\n      } catch (error) {\n        console.error('Error processing tracking session date:', error);\n      }\n    });\n\n    // Create user map for quick lookups\n    const userMap = new Map();\n    externalUsers.forEach(user => {\n      userMap.set(user._id, user);\n    });\n\n    // STEP 11: Build response with data\n    const allEmployeesData = paginatedEmployees.map((employee) => {\n      const employeeId = employee.userId || employee.id;\n      const allMeetings = allMeetingsByEmployee.get(employeeId) || [];\n\n      // Group ALL meetings by date for this employee\n      const meetingsByDate = new Map();\n      allMeetings.forEach(meeting => {\n        try {\n          if (meeting.startTime) {\n            const dateStr = format(new Date(meeting.startTime), \"yyyy-MM-dd\");\n            if (!meetingsByDate.has(dateStr)) {\n              meetingsByDate.set(dateStr, []);\n            }\n            meetingsByDate.get(dateStr).push(meeting);\n          }\n        } catch (error) {\n          // Skip invalid dates\n        }\n      });\n\n      // Get all unique dates from ALL meetings\n      const allDates = Array.from(meetingsByDate.keys())\n        .sort((a, b) => new Date(b).getTime() - new Date(a).getTime())\n        .slice(0, 10); // Limit to 10 most recent days for performance\n\n      // Generate day records from ALL meetings\n      const dayRecords = allDates.map(dateStr => {\n        const dateMeetings = meetingsByDate.get(dateStr) || [];\n        const totalMeetings = dateMeetings.length;\n\n        // Get first and last meeting\n        let firstMeeting = null;\n        let lastMeeting = null;\n        if (dateMeetings.length > 0) {\n          const sorted = [...dateMeetings].sort((a, b) => {\n            try {\n              return new Date(a.startTime).getTime() - new Date(b.startTime).getTime();\n            } catch {\n              return 0;\n            }\n          });\n          firstMeeting = sorted[0];\n          lastMeeting = sorted[sorted.length - 1];\n        }\n\n        // Calculate meeting time (sum of all meeting durations)\n        let meetingTime = 0;\n        dateMeetings.forEach(meeting => {\n          if (meeting.startTime && meeting.endTime) {\n            try {\n              const start = new Date(meeting.startTime);\n              const end = new Date(meeting.endTime);\n              const durationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n              if (durationHours > 0) {\n                meetingTime += durationHours;\n              }\n            } catch (error) {\n              // Skip invalid dates\n            }\n          }\n        });\n\n        // Calculate total duty hours from first meeting start to last meeting end\n        let totalDutyHours = 0;\n        if (firstMeeting?.startTime && lastMeeting?.endTime) {\n          try {\n            const dutyStart = new Date(firstMeeting.startTime);\n            const dutyEnd = new Date(lastMeeting.endTime);\n            totalDutyHours = Math.max(0, (dutyEnd.getTime() - dutyStart.getTime()) / (1000 * 60 * 60));\n          } catch (error) {\n            console.error(`Error calculating duty hours for ${employeeId} on ${dateStr}:`, error);\n            totalDutyHours = 0;\n          }\n        } else if (firstMeeting?.startTime) {\n          // Only start time available (ongoing meeting)\n          try {\n            const dutyStart = new Date(firstMeeting.startTime);\n            const now = new Date();\n            totalDutyHours = Math.max(0, (now.getTime() - dutyStart.getTime()) / (1000 * 60 * 60));\n          } catch (error) {\n            totalDutyHours = 0;\n          }\n        }\n\n        // Use tracking sessions data if available and if no meetings exist\n        if (totalDutyHours === 0) {\n          const sessionKey = `${employeeId}-${dateStr}`;\n          const dateSessions = sessionsByEmployeeDate.get(sessionKey) || [];\n\n          if (dateSessions.length > 0) {\n            // Calculate from tracking sessions as fallback\n            dateSessions.forEach(session => {\n              if (session.startTime && session.endTime) {\n                try {\n                  const start = new Date(session.startTime);\n                  const end = new Date(session.endTime);\n                  const durationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n                  if (durationHours > 0) {\n                    totalDutyHours += durationHours;\n                  }\n                } catch (error) {\n                  // Skip invalid dates\n                }\n              }\n            });\n          }\n        }\n\n        // Calculate travel and lunch time\n        const travelAndLunchTime = Math.max(0, totalDutyHours - meetingTime);\n\n        // Get attendance info\n        const attendanceKey = `${employeeId}-${dateStr}`;\n        const attendance = attendanceByEmployee.get(attendanceKey);\n\n        return {\n          date: dateStr,\n          totalMeetings,\n          startLocationTime: firstMeeting?.startTime ? format(new Date(firstMeeting.startTime), \"HH:mm:ss\") : \"\",\n          startLocationAddress: firstMeeting?.location?.address || \"\",\n          outLocationTime: lastMeeting?.endTime ? format(new Date(lastMeeting.endTime), \"HH:mm:ss\") : \"\",\n          outLocationAddress: lastMeeting?.location?.address || \"\",\n          totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\n          meetingTime: parseFloat(meetingTime.toFixed(2)),\n          travelAndLunchTime: parseFloat(travelAndLunchTime.toFixed(2)),\n          attendanceAddedBy: attendance?.attendenceCreated ?\n            (userMap.get(attendance.attendenceCreated)?.name || attendance.attendenceCreated) : \"Auto\"\n        };\n      });\n\n      // Generate meeting records from ALL meetings (no limit)\n      const meetingRecords = allMeetings.map(meeting => {\n        // Calculate individual meeting duration\n        let totalStayTime = 0;\n        if (meeting.startTime && meeting.endTime) {\n          try {\n            const start = new Date(meeting.startTime);\n            const end = new Date(meeting.endTime);\n            totalStayTime = (end.getTime() - start.getTime()) / (1000 * 60 * 60); // Convert to hours\n          } catch (error) {\n            totalStayTime = 0;\n          }\n        }\n\n        return {\n          employeeName: employee.name,\n          companyName: meeting.clientName || \"Unknown Company\",\n          date: meeting.startTime ? format(new Date(meeting.startTime), \"yyyy-MM-dd\") : \"\",\n          leadId: meeting.leadId || \"\",\n          meetingInTime: meeting.startTime ? format(new Date(meeting.startTime), \"HH:mm:ss\") : \"\",\n          meetingInLocation: meeting.location?.address || \"\",\n          meetingOutTime: meeting.endTime ? format(new Date(meeting.endTime), \"HH:mm:ss\") : \"In Progress\",\n          meetingOutLocation: meeting.location?.address || \"\",\n          totalStayTime: parseFloat(totalStayTime.toFixed(2)),\n          discussion: meeting.meetingDetails?.discussion || \"\",\n          meetingPerson: meeting.meetingDetails?.customerEmployeeName || \"\",\n          meetingStatus: meeting.status || \"completed\",\n          approvalStatus: meeting.approvalStatus,\n          approvalReason: meeting.approvalReason,\n          approvedBy: meeting.approvedBy,\n          approvedByName: meeting.approvedBy ?\n            (userMap.get(meeting.approvedBy)?.name || meeting.approvedBy) : undefined,\n          attachments: meeting.meetingDetails?.attachments || [],\n        };\n      });\n\n      // Calculate summary from ALL meetings\n      const totalMeetings = allMeetings.length;\n      const uniqueDates = new Set();\n      let totalMeetingHours = 0;\n\n      allMeetings.forEach(m => {\n        if (m.startTime) {\n          try {\n            uniqueDates.add(format(new Date(m.startTime), \"yyyy-MM-dd\"));\n            // Calculate meeting duration for summary\n            if (m.startTime && m.endTime) {\n              const start = new Date(m.startTime);\n              const end = new Date(m.endTime);\n              totalMeetingHours += (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n            }\n          } catch (error) {\n            // Skip invalid dates\n          }\n        }\n      });\n\n      const daysWithMeetings = uniqueDates.size;\n\n      return {\n        employeeId: employee.id,\n        employeeName: employee.name,\n        email: employee.email,\n        phone: employee.phone,\n        designation: employee.designation,\n        department: employee.department,\n        companyName: employee.companyName,\n        reportTo: employee.reportTo,\n        status: employee.status,\n        summary: {\n          totalMeetings,\n          totalMeetingHours: parseFloat(totalMeetingHours.toFixed(2)),\n          daysWithMeetings,\n          avgMeetingsPerDay: daysWithMeetings > 0 ? parseFloat((totalMeetings / daysWithMeetings).toFixed(2)) : 0,\n        },\n        dayRecords: dayRecords,\n        meetingRecords: meetingRecords,\n      };\n    });\n\n    const endTime = Date.now();\n    console.log(`‚úÖ All employees details fetched in ${endTime - startTime}ms for ${paginatedEmployees.length} employees`);\n\n    // Calculate pagination info\n    const hasNextPage = pageNum < totalPages;\n    const hasPreviousPage = pageNum > 1;\n\n    res.json({\n      success: true,\n      dateRange: {\n        start: start.toISOString(),\n        end: end.toISOString(),\n        label: dateRange,\n      },\n      pagination: {\n        currentPage: pageNum,\n        pageSize: limitNum,\n        totalItems: totalEmployees,\n        totalPages: totalPages,\n        hasNextPage,\n        hasPreviousPage,\n        nextPage: hasNextPage ? pageNum + 1 : null,\n        previousPage: hasPreviousPage ? pageNum - 1 : null,\n      },\n      search: search || null,\n      sort: {\n        by: sortBy,\n        order: sortOrder\n      },\n      employees: allEmployeesData,\n    });\n  } catch (error) {\n    console.error(\"Error fetching all employees details:\", error);\n    console.error(\"Error stack:\", error.stack);\n\n    const message = error?.message || \"Unknown error\";\n    try {\n      console.warn(\n        \"‚ö†Ô∏è all-employees-details failed; returning degraded response instead of 500.\",\n      );\n\n      const {\n        dateRange: rawDateRange = \"today\",\n        startDate,\n        endDate,\n        page = \"1\",\n        limit = \"10\",\n        search = \"\",\n        sortBy = \"employeeName\",\n        sortOrder = \"asc\",\n      } = req.query as any;\n\n      const dateRange = String(rawDateRange || \"today\").trim().toLowerCase();\n      const { start, end } = getDateRange(dateRange, startDate as string, endDate as string);\n      const pageNum = parseInt(page as string, 10) || 1;\n      const limitNum = parseInt(limit as string, 10) || 10;\n      const skip = (pageNum - 1) * limitNum;\n\n      let fallbackEmployees = (await cacheService.getExternalUsers()).map((user, index) => {\n        const employee = mapExternalUserToEmployee(user, index);\n        return {\n          ...employee,\n          userId: user._id,\n        };\n      });\n\n      if (search) {\n        const searchLower = String(search).toLowerCase();\n        fallbackEmployees = fallbackEmployees.filter(\n          (emp) =>\n            (emp.name || \"\").toLowerCase().includes(searchLower) ||\n            (emp.email || \"\").toLowerCase().includes(searchLower) ||\n            (emp.designation || \"\").toLowerCase().includes(searchLower) ||\n            (emp.department || \"\").toLowerCase().includes(searchLower),\n        );\n      }\n\n      const sortDirection = sortOrder === \"desc\" ? -1 : 1;\n      fallbackEmployees.sort((a, b) => {\n        switch (sortBy) {\n          case \"employeeName\":\n            return sortDirection * a.name.localeCompare(b.name);\n          case \"email\":\n            return sortDirection * (a.email || \"\").localeCompare(b.email || \"\");\n          case \"designation\":\n            return sortDirection * (a.designation || \"\").localeCompare(b.designation || \"\");\n          case \"department\":\n            return sortDirection * (a.department || \"\").localeCompare(b.department || \"\");\n          default:\n            return sortDirection * a.name.localeCompare(b.name);\n        }\n      });\n\n      const totalEmployees = fallbackEmployees.length;\n      const totalPages = Math.ceil(totalEmployees / limitNum);\n      const paginatedEmployees = fallbackEmployees.slice(skip, skip + limitNum);\n\n      return res.json({\n        success: true,\n        degraded: true,\n        degradedReason: \"database_unavailable\",\n        degradedMessage: message,\n        dateRange: {\n          start: start.toISOString(),\n          end: end.toISOString(),\n          label: dateRange,\n        },\n        pagination: {\n          currentPage: pageNum,\n          pageSize: limitNum,\n          totalItems: totalEmployees,\n          totalPages,\n          hasNextPage: pageNum < totalPages,\n          hasPreviousPage: pageNum > 1,\n          nextPage: pageNum < totalPages ? pageNum + 1 : null,\n          previousPage: pageNum > 1 ? pageNum - 1 : null,\n        },\n        search: search || null,\n        sort: {\n          by: sortBy,\n          order: sortOrder,\n        },\n        employees: paginatedEmployees.map((employee) => ({\n          employeeId: employee.id,\n          employeeName: employee.name,\n          email: employee.email,\n          phone: employee.phone,\n          designation: employee.designation,\n          department: employee.department,\n          companyName: employee.companyName,\n          reportTo: employee.reportTo,\n          status: employee.status,\n          summary: {\n            totalMeetings: 0,\n            totalMeetingHours: 0,\n            daysWithMeetings: 0,\n            avgMeetingsPerDay: 0,\n          },\n          dayRecords: [],\n          meetingRecords: [],\n        })),\n      });\n    } catch (fallbackError) {\n      console.error(\"‚ùå Failed to build degraded response:\", fallbackError);\n      return res.status(500).json({\n        error: \"Failed to fetch all employees details\",\n        message,\n      });\n    }\n  }\n};\n","import { RequestHandler } from \"express\";\r\nimport { Meeting, MeetingHistory, Employee, TrackingSession } from \"../models\";\r\n\r\n// Endpoint to synchronize all data sources and ensure consistency\r\nexport const syncAllData: RequestHandler = async (req, res) => {\r\n  try {\r\n    console.log(\"Starting data synchronization...\");\r\n    \r\n    const { employeeId } = req.query;\r\n    \r\n    // Get all data from MongoDB\r\n    const mongoMeetings = await Meeting.find(employeeId ? { employeeId } : {}).lean();\r\n    const mongoHistory = await MeetingHistory.find(employeeId ? { employeeId } : {}).lean();\r\n    \r\n    console.log(`Found ${mongoMeetings.length} meetings and ${mongoHistory.length} history entries in MongoDB`);\r\n    \r\n    // Get in-memory data for comparison\r\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\r\n    \r\n    console.log(`Found ${inMemoryMeetings.length} meetings in memory`);\r\n    \r\n    // Synchronize missing data\r\n    let syncedMeetings = 0;\r\n    let syncedHistory = 0;\r\n    \r\n    // Sync in-memory meetings to MongoDB\r\n    for (const meeting of inMemoryMeetings) {\r\n      if (employeeId && meeting.employeeId !== employeeId) continue;\r\n      \r\n      const exists = await Meeting.findOne({ \r\n        employeeId: meeting.employeeId,\r\n        startTime: meeting.startTime \r\n      });\r\n      \r\n      if (!exists) {\r\n        try {\r\n          const newMeeting = new Meeting({\r\n            employeeId: meeting.employeeId,\r\n            location: meeting.location,\r\n            startTime: meeting.startTime,\r\n            endTime: meeting.endTime,\r\n            clientName: meeting.clientName,\r\n            notes: meeting.notes,\r\n            status: meeting.status,\r\n            trackingSessionId: meeting.trackingSessionId,\r\n            leadId: meeting.leadId,\r\n            leadInfo: meeting.leadInfo,\r\n            meetingDetails: meeting.meetingDetails\r\n          });\r\n          \r\n          await newMeeting.save();\r\n          syncedMeetings++;\r\n          \r\n          // Also add to meeting history if completed\r\n          if (meeting.status === 'completed' && meeting.meetingDetails) {\r\n            const historyExists = await MeetingHistory.findOne({\r\n              employeeId: meeting.employeeId,\r\n              'meetingDetails.discussion': meeting.meetingDetails.discussion\r\n            });\r\n            \r\n            if (!historyExists) {\r\n              const newHistory = new MeetingHistory({\r\n                sessionId: meeting.trackingSessionId || `sync_${Date.now()}`,\r\n                employeeId: meeting.employeeId,\r\n                meetingDetails: meeting.meetingDetails,\r\n                timestamp: meeting.endTime || meeting.startTime,\r\n                leadId: meeting.leadId,\r\n                leadInfo: meeting.leadInfo\r\n              });\r\n              \r\n              await newHistory.save();\r\n              syncedHistory++;\r\n            }\r\n          }\r\n        } catch (syncError) {\r\n          console.warn(`Failed to sync meeting ${meeting.id}:`, syncError);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Get final counts\r\n    const finalMeetings = await Meeting.countDocuments(employeeId ? { employeeId } : {});\r\n    const finalHistory = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\r\n    \r\n    const result = {\r\n      success: true,\r\n      message: \"Data synchronization completed\",\r\n      stats: {\r\n        totalMeetingsInMongoDB: finalMeetings,\r\n        totalHistoryInMongoDB: finalHistory,\r\n        meetingsSynced: syncedMeetings,\r\n        historySynced: syncedHistory,\r\n        employeeId: employeeId || \"all\"\r\n      }\r\n    };\r\n    \r\n    console.log(\"Data sync result:\", result);\r\n    res.json(result);\r\n    \r\n  } catch (error) {\r\n    console.error(\"Error synchronizing data:\", error);\r\n    res.status(500).json({ \r\n      error: \"Failed to synchronize data\",\r\n      details: error.message \r\n    });\r\n  }\r\n};\r\n\r\n// Endpoint to get comprehensive data status\r\nexport const getDataStatus: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId } = req.query;\r\n    \r\n    // MongoDB counts\r\n    const mongoMeetingsCount = await Meeting.countDocuments(employeeId ? { employeeId } : {});\r\n    const mongoHistoryCount = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\r\n    const mongoEmployeesCount = await Employee.countDocuments();\r\n    const mongoTrackingCount = await TrackingSession.countDocuments(employeeId ? { employeeId } : {});\r\n    \r\n    // In-memory counts\r\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\r\n    const filteredInMemoryMeetings = employeeId \r\n      ? inMemoryMeetings.filter(m => m.employeeId === employeeId)\r\n      : inMemoryMeetings;\r\n    \r\n    // Sample data for debugging\r\n    const sampleMongoMeeting = await Meeting.findOne(employeeId ? { employeeId } : {}).lean();\r\n    const sampleMongoHistory = await MeetingHistory.findOne(employeeId ? { employeeId } : {}).lean();\r\n    \r\n    const status = {\r\n      employeeId: employeeId || \"all\",\r\n      mongoDB: {\r\n        meetings: mongoMeetingsCount,\r\n        history: mongoHistoryCount,\r\n        employees: mongoEmployeesCount,\r\n        trackingSessions: mongoTrackingCount,\r\n        sampleMeeting: sampleMongoMeeting ? {\r\n          id: sampleMongoMeeting._id,\r\n          employeeId: sampleMongoMeeting.employeeId,\r\n          status: sampleMongoMeeting.status,\r\n          hasDetails: !!sampleMongoMeeting.meetingDetails,\r\n          leadId: sampleMongoMeeting.leadId\r\n        } : null,\r\n        sampleHistory: sampleMongoHistory ? {\r\n          id: sampleMongoHistory._id,\r\n          employeeId: sampleMongoHistory.employeeId,\r\n          hasCustomers: sampleMongoHistory.meetingDetails?.customers?.length > 0,\r\n          discussion: sampleMongoHistory.meetingDetails?.discussion?.substring(0, 100)\r\n        } : null\r\n      },\r\n      inMemory: {\r\n        meetings: filteredInMemoryMeetings.length,\r\n        sampleMeeting: filteredInMemoryMeetings[0] ? {\r\n          id: filteredInMemoryMeetings[0].id,\r\n          employeeId: filteredInMemoryMeetings[0].employeeId,\r\n          status: filteredInMemoryMeetings[0].status,\r\n          hasDetails: !!filteredInMemoryMeetings[0].meetingDetails\r\n        } : null\r\n      }\r\n    };\r\n    \r\n    res.json(status);\r\n    \r\n  } catch (error) {\r\n    console.error(\"Error getting data status:\", error);\r\n    res.status(500).json({ \r\n      error: \"Failed to get data status\",\r\n      details: error.message \r\n    });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport { Meeting, MeetingHistory } from \"../models\";\r\n\r\nexport const debugEmployeeData: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId } = req.params;\r\n    \r\n    console.log(`Debugging data for employee: ${employeeId}`);\r\n    \r\n    // Get MongoDB meetings\r\n    const mongoMeetings = await Meeting.find({ employeeId }).lean();\r\n    console.log(`Found ${mongoMeetings.length} meetings in MongoDB for employee ${employeeId}`);\r\n    \r\n    // Get MongoDB meeting history\r\n    const mongoHistory = await MeetingHistory.find({ employeeId }).lean();\r\n    console.log(`Found ${mongoHistory.length} history entries in MongoDB for employee ${employeeId}`);\r\n    \r\n    // Get in-memory meetings\r\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\r\n    const filteredInMemory = inMemoryMeetings.filter(m => m.employeeId === employeeId);\r\n    console.log(`Found ${filteredInMemory.length} meetings in memory for employee ${employeeId}`);\r\n    \r\n    const debugData = {\r\n      employeeId,\r\n      mongoDB: {\r\n        meetings: {\r\n          count: mongoMeetings.length,\r\n          data: mongoMeetings.map(m => ({\r\n            id: m._id.toString(),\r\n            startTime: m.startTime,\r\n            endTime: m.endTime,\r\n            status: m.status,\r\n            clientName: m.clientName,\r\n            leadId: m.leadId,\r\n            hasDetails: !!m.meetingDetails,\r\n            detailsCustomers: m.meetingDetails?.customers?.length || 0\r\n          }))\r\n        },\r\n        history: {\r\n          count: mongoHistory.length,\r\n          data: mongoHistory.map(h => ({\r\n            id: h._id.toString(),\r\n            timestamp: h.timestamp,\r\n            sessionId: h.sessionId,\r\n            leadId: h.leadId,\r\n            hasDetails: !!h.meetingDetails,\r\n            discussion: h.meetingDetails?.discussion?.substring(0, 100),\r\n            customers: h.meetingDetails?.customers?.length || 0,\r\n            customerNames: h.meetingDetails?.customers?.map(c => c.customerEmployeeName) || []\r\n          }))\r\n        }\r\n      },\r\n      inMemory: {\r\n        meetings: {\r\n          count: filteredInMemory.length,\r\n          data: filteredInMemory.map(m => ({\r\n            id: m.id,\r\n            startTime: m.startTime,\r\n            endTime: m.endTime,\r\n            status: m.status,\r\n            clientName: m.clientName,\r\n            leadId: m.leadId,\r\n            hasDetails: !!m.meetingDetails\r\n          }))\r\n        }\r\n      },\r\n      recommendations: []\r\n    };\r\n    \r\n    // Add recommendations based on data analysis\r\n    if (mongoMeetings.length === 0 && filteredInMemory.length > 0) {\r\n      debugData.recommendations.push(\"Meetings exist in memory but not in MongoDB - run data sync\");\r\n    }\r\n    \r\n    if (mongoMeetings.length > mongoHistory.length) {\r\n      debugData.recommendations.push(\"More meetings than history entries - some meetings may not have been completed properly\");\r\n    }\r\n    \r\n    if (mongoHistory.length === 0) {\r\n      debugData.recommendations.push(\"No meeting history found - check if meetings are being ended with proper details\");\r\n    }\r\n    \r\n    console.log(\"Debug data prepared:\", JSON.stringify(debugData, null, 2));\r\n    \r\n    res.json(debugData);\r\n    \r\n  } catch (error) {\r\n    console.error(\"Error in debug endpoint:\", error);\r\n    res.status(500).json({ error: \"Debug failed\", details: error.message });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport { RouteSnapshot, IRouteSnapshot } from \"../models\";\r\n\r\n// In-memory fallback storage for route snapshots\r\nlet inMemorySnapshots: any[] = [];\r\nexport { inMemorySnapshots };\r\n\r\n// Get route snapshots with filtering\r\nexport const getRouteSnapshots: RequestHandler = async (req, res) => {\r\n  try {\r\n    const {\r\n      employeeId,\r\n      trackingSessionId,\r\n      status,\r\n      startDate,\r\n      endDate,\r\n      page = 1,\r\n      limit = 20\r\n    } = req.query;\r\n\r\n    console.log(\"Fetching route snapshots with query:\", { employeeId, trackingSessionId, status, startDate, endDate });\r\n\r\n    const pageNum = parseInt(page as string);\r\n    const limitNum = parseInt(limit as string);\r\n    const skip = (pageNum - 1) * limitNum;\r\n\r\n    try {\r\n      // Build MongoDB query\r\n      const query: any = {};\r\n\r\n      if (employeeId) {\r\n        query.employeeId = employeeId;\r\n      }\r\n\r\n      if (trackingSessionId) {\r\n        query.trackingSessionId = trackingSessionId;\r\n      }\r\n\r\n      if (status) {\r\n        query.status = status;\r\n      }\r\n\r\n      if (startDate || endDate) {\r\n        query.captureTime = {};\r\n        if (startDate) {\r\n          query.captureTime.$gte = new Date(startDate as string).toISOString();\r\n        }\r\n        if (endDate) {\r\n          query.captureTime.$lte = new Date(endDate as string).toISOString();\r\n        }\r\n      }\r\n\r\n      const snapshots = await RouteSnapshot.find(query)\r\n        .sort({ captureTime: -1 })\r\n        .skip(skip)\r\n        .limit(limitNum)\r\n        .lean();\r\n\r\n      const total = await RouteSnapshot.countDocuments(query);\r\n\r\n      const response = {\r\n        snapshots,\r\n        total,\r\n        page: pageNum,\r\n        totalPages: Math.ceil(total / limitNum),\r\n      };\r\n\r\n      console.log(`Found ${snapshots.length} route snapshots from MongoDB`);\r\n      res.json(response);\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\r\n\r\n      // Fallback to in-memory storage\r\n      let filteredSnapshots = [...inMemorySnapshots];\r\n\r\n      // Apply filters\r\n      if (employeeId) {\r\n        filteredSnapshots = filteredSnapshots.filter(s => s.employeeId === employeeId);\r\n      }\r\n\r\n      if (trackingSessionId) {\r\n        filteredSnapshots = filteredSnapshots.filter(s => s.trackingSessionId === trackingSessionId);\r\n      }\r\n\r\n      if (status) {\r\n        filteredSnapshots = filteredSnapshots.filter(s => s.status === status);\r\n      }\r\n\r\n      if (startDate || endDate) {\r\n        filteredSnapshots = filteredSnapshots.filter(s => {\r\n          const captureTime = new Date(s.captureTime);\r\n          if (startDate && captureTime < new Date(startDate as string)) return false;\r\n          if (endDate && captureTime > new Date(endDate as string)) return false;\r\n          return true;\r\n        });\r\n      }\r\n\r\n      // Sort by capture time (newest first)\r\n      filteredSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\r\n\r\n      // Apply pagination\r\n      const total = filteredSnapshots.length;\r\n      const paginatedSnapshots = filteredSnapshots.slice(skip, skip + limitNum);\r\n\r\n      const response = {\r\n        snapshots: paginatedSnapshots,\r\n        total,\r\n        page: pageNum,\r\n        totalPages: Math.ceil(total / limitNum),\r\n      };\r\n\r\n      console.log(`Found ${paginatedSnapshots.length} route snapshots from memory (${total} total)`);\r\n      res.json(response);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching route snapshots:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch route snapshots\" });\r\n  }\r\n};\r\n\r\n// Get a specific route snapshot by ID\r\nexport const getRouteSnapshot: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    try {\r\n      // Try MongoDB first\r\n      const snapshot = await RouteSnapshot.findOne({ id });\r\n\r\n      if (snapshot) {\r\n        console.log(\"Route snapshot found in MongoDB:\", snapshot.id);\r\n        return res.json(snapshot);\r\n      }\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB query failed, checking in-memory storage:\", mongoError);\r\n    }\r\n\r\n    // Check in-memory storage\r\n    const memorySnapshot = inMemorySnapshots.find(s => s.id === id);\r\n\r\n    if (memorySnapshot) {\r\n      console.log(\"Route snapshot found in memory:\", memorySnapshot.id);\r\n      return res.json(memorySnapshot);\r\n    }\r\n\r\n    return res.status(404).json({ error: \"Route snapshot not found\" });\r\n  } catch (error) {\r\n    console.error(\"Error fetching route snapshot:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch route snapshot\" });\r\n  }\r\n};\r\n\r\n// Create a new route snapshot\r\nexport const createRouteSnapshot: RequestHandler = async (req, res) => {\r\n  try {\r\n    const {\r\n      employeeId,\r\n      employeeName,\r\n      trackingSessionId,\r\n      title,\r\n      description,\r\n      startLocation,\r\n      endLocation,\r\n      route,\r\n      meetings,\r\n      totalDistance,\r\n      duration,\r\n      status,\r\n      mapBounds\r\n    } = req.body;\r\n\r\n    if (!employeeId || !employeeName || !title || !startLocation || !route || !mapBounds) {\r\n      return res.status(400).json({\r\n        error: \"Employee ID, name, title, start location, route, and map bounds are required\",\r\n      });\r\n    }\r\n\r\n    // Generate unique snapshot ID\r\n    const snapshotId = `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n    // Calculate snapshot metadata\r\n    const snapshotMetadata = {\r\n      routeColor: '#3b82f6',\r\n      mapZoom: 12,\r\n      routePointsCount: route.length,\r\n      meetingsCount: meetings ? meetings.length : 0\r\n    };\r\n\r\n    const snapshotData = {\r\n      id: snapshotId,\r\n      employeeId,\r\n      employeeName,\r\n      trackingSessionId,\r\n      captureTime: new Date().toISOString(),\r\n      title,\r\n      description,\r\n      startLocation: {\r\n        ...startLocation,\r\n        timestamp: startLocation.timestamp || new Date().toISOString(),\r\n      },\r\n      endLocation: endLocation ? {\r\n        ...endLocation,\r\n        timestamp: endLocation.timestamp || new Date().toISOString(),\r\n      } : undefined,\r\n      route: route.map((point: any) => ({\r\n        ...point,\r\n        timestamp: point.timestamp || new Date().toISOString(),\r\n      })),\r\n      meetings: meetings || [],\r\n      totalDistance: totalDistance || 0,\r\n      duration,\r\n      status: status || 'active',\r\n      mapBounds,\r\n      snapshotMetadata\r\n    };\r\n\r\n    try {\r\n      // Try to save to MongoDB first\r\n      const newSnapshot = new RouteSnapshot(snapshotData);\r\n      const savedSnapshot = await newSnapshot.save();\r\n\r\n      console.log(\"Route snapshot created in MongoDB:\", savedSnapshot.id);\r\n      res.status(201).json(savedSnapshot);\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB save failed, saving to in-memory storage:\", mongoError);\r\n\r\n      // Fallback to in-memory storage\r\n      inMemorySnapshots.push(snapshotData);\r\n\r\n      console.log(\"Route snapshot created in memory:\", snapshotData.id);\r\n      res.status(201).json(snapshotData);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error creating route snapshot:\", error);\r\n    res.status(500).json({ error: \"Failed to create route snapshot\" });\r\n  }\r\n};\r\n\r\n// Update a route snapshot\r\nexport const updateRouteSnapshot: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const updates = req.body;\r\n    let updated = false;\r\n\r\n    try {\r\n      // Try MongoDB first\r\n      const updatedSnapshot = await RouteSnapshot.findOneAndUpdate(\r\n        { id },\r\n        { $set: updates },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (updatedSnapshot) {\r\n        console.log(\"Route snapshot updated in MongoDB:\", updatedSnapshot.id);\r\n        return res.json(updatedSnapshot);\r\n      }\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB update failed, checking in-memory storage:\", mongoError);\r\n    }\r\n\r\n    // Check in-memory storage\r\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\r\n    if (memoryIndex !== -1) {\r\n      inMemorySnapshots[memoryIndex] = { ...inMemorySnapshots[memoryIndex], ...updates };\r\n      console.log(\"Route snapshot updated in memory:\", inMemorySnapshots[memoryIndex].id);\r\n      return res.json(inMemorySnapshots[memoryIndex]);\r\n    }\r\n\r\n    return res.status(404).json({ error: \"Route snapshot not found\" });\r\n  } catch (error) {\r\n    console.error(\"Error updating route snapshot:\", error);\r\n    res.status(500).json({ error: \"Failed to update route snapshot\" });\r\n  }\r\n};\r\n\r\n// Delete a route snapshot\r\nexport const deleteRouteSnapshot: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    let deleted = false;\r\n\r\n    try {\r\n      // Try MongoDB first\r\n      const deletedSnapshot = await RouteSnapshot.findOneAndDelete({ id });\r\n      if (deletedSnapshot) {\r\n        console.log(\"Route snapshot deleted from MongoDB:\", deletedSnapshot.id);\r\n        deleted = true;\r\n      }\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB delete failed, checking in-memory storage:\", mongoError);\r\n    }\r\n\r\n    // Check in-memory storage\r\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\r\n    if (memoryIndex !== -1) {\r\n      const deletedSnapshot = inMemorySnapshots.splice(memoryIndex, 1)[0];\r\n      console.log(\"Route snapshot deleted from memory:\", deletedSnapshot.id);\r\n      deleted = true;\r\n    }\r\n\r\n    if (!deleted) {\r\n      return res.status(404).json({ error: \"Route snapshot not found\" });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error(\"Error deleting route snapshot:\", error);\r\n    res.status(500).json({ error: \"Failed to delete route snapshot\" });\r\n  }\r\n};\r\n\r\n// Get snapshots by employee\r\nexport const getEmployeeSnapshots: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId } = req.params;\r\n    const { page = 1, limit = 10 } = req.query;\r\n\r\n    const pageNum = parseInt(page as string);\r\n    const limitNum = parseInt(limit as string);\r\n    const skip = (pageNum - 1) * limitNum;\r\n\r\n    try {\r\n      // Try MongoDB first\r\n      const snapshots = await RouteSnapshot.find({ employeeId })\r\n        .sort({ captureTime: -1 })\r\n        .skip(skip)\r\n        .limit(limitNum)\r\n        .lean();\r\n\r\n      const total = await RouteSnapshot.countDocuments({ employeeId });\r\n\r\n      const response = {\r\n        snapshots,\r\n        total,\r\n        page: pageNum,\r\n        totalPages: Math.ceil(total / limitNum),\r\n      };\r\n\r\n      console.log(`Found ${snapshots.length} snapshots for employee ${employeeId} from MongoDB`);\r\n      res.json(response);\r\n    } catch (mongoError) {\r\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\r\n\r\n      // Fallback to in-memory storage\r\n      const employeeSnapshots = inMemorySnapshots.filter(s => s.employeeId === employeeId);\r\n\r\n      // Sort by capture time (newest first)\r\n      employeeSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\r\n\r\n      // Apply pagination\r\n      const total = employeeSnapshots.length;\r\n      const paginatedSnapshots = employeeSnapshots.slice(skip, skip + limitNum);\r\n\r\n      const response = {\r\n        snapshots: paginatedSnapshots,\r\n        total,\r\n        page: pageNum,\r\n        totalPages: Math.ceil(total / limitNum),\r\n      };\r\n\r\n      console.log(`Found ${paginatedSnapshots.length} snapshots for employee ${employeeId} from memory (${total} total)`);\r\n      res.json(response);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching employee snapshots:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch employee snapshots\" });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport axios from 'axios';\r\n\r\n// Update follow-up meeting status\r\nexport const updateFollowUpStatus: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { status, meetingDetails } = req.body;\r\n    // Allow followUpId to be passed either as URL param or in the body\r\n    const followUpId = (req.params && (req.params as any).id) || (req.body && req.body.followUpId);\r\n\r\n    if (!followUpId || !status) {\r\n      return res.status(400).json({\r\n        error: \"Missing required fields: followUpId and status are required\",\r\n      });\r\n    }\r\n\r\n    console.log(\"Updating follow-up status:\", {\r\n      followUpId,\r\n      status,\r\n      meetingDetails,\r\n    });\r\n\r\n    // Construct the external API URL for updating follow-up status\r\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\r\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\r\n    \r\n    // Prefer external endpoint updateFollowUp/:id if available\r\n    const updateUrl = `${baseUrl}/updateFollowUp/${followUpId}`;\r\n\r\n    const updatePayload = {\r\n      meetingStatus: status,\r\n      meetingDetails: meetingDetails,\r\n      updatedAt: new Date().toISOString(),\r\n    };\r\n\r\n    console.log(\"Sending update to external API (updateFollowUp/:id):\", {\r\n      url: updateUrl,\r\n      payload: updatePayload,\r\n    });\r\n\r\n    // Try calling the updateFollowUp/:id endpoint first\r\n    let response;\r\n    try {\r\n      response = await axios.put(updateUrl, updatePayload, {\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        timeout: 10000,\r\n      });\r\n    } catch (err) {\r\n      console.warn(\"updateFollowUp/:id failed, falling back to updateFollowUpHistory\", err?.message || err);\r\n      // Fallback to older endpoint if available\r\n      const fallbackUrl = `${baseUrl}/updateFollowUpHistory`;\r\n      const fallbackPayload = {\r\n        id: followUpId,\r\n        status: status,\r\n        meetingDetails: meetingDetails,\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n      console.log(\"Sending update to external API (fallback):\", { url: fallbackUrl, payload: fallbackPayload });\r\n      response = await axios.put(fallbackUrl, fallbackPayload, {\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        timeout: 10000,\r\n      });\r\n    }\r\n\r\n    if (response.status === 200 || response.data.success) {\r\n      console.log(\"Follow-up status updated successfully:\", response.data);\r\n      return res.json({\r\n        message: \"Follow-up status updated successfully\",\r\n        data: response.data,\r\n      });\r\n    } else {\r\n      console.error(\"Failed to update follow-up status:\", response.data);\r\n      return res.status(400).json({\r\n        error: \"Failed to update follow-up status\",\r\n        details: response.data,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating follow-up status:\", error);\r\n\r\n    if (axios.isAxiosError(error)) {\r\n      const errorMessage = error.response?.data?.message || error.message;\r\n      return res.status(error.response?.status || 500).json({\r\n        error: \"Failed to update follow-up status\",\r\n        details: errorMessage,\r\n      });\r\n    }\r\n\r\n    return res.status(500).json({\r\n      error: \"Internal server error\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\",\r\n    });\r\n  }\r\n};\r\n\r\n// Get follow-up history for a user\r\nexport const getFollowUpHistory: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { userId } = req.query;\r\n\r\n    if (!userId) {\r\n      return res.status(400).json({\r\n        error: \"Missing required parameter: userId\",\r\n      });\r\n    }\r\n\r\n    console.log(\"Fetching follow-up history for user:\", userId);\r\n\r\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\r\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\r\n    const url = `${baseUrl}/getFollowUpHistory?userId=${userId}`;\r\n\r\n    console.log(\"Fetching from external API:\", url);\r\n\r\n    const response = await axios.get(url, {\r\n      timeout: 10000,\r\n    });\r\n\r\n    if (response.status === 200 && response.data) {\r\n      console.log(`Fetched ${response.data.length || 0} follow-up records`);\r\n      return res.json(response.data);\r\n    } else {\r\n      console.error(\"Failed to fetch follow-up history:\", response.data);\r\n      return res.status(400).json({\r\n        error: \"Failed to fetch follow-up history\",\r\n        details: response.data,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching follow-up history:\", error);\r\n\r\n    if (axios.isAxiosError(error)) {\r\n      const errorMessage = error.response?.data?.message || error.message;\r\n      return res.status(error.response?.status || 500).json({\r\n        error: \"Failed to fetch follow-up history\",\r\n        details: errorMessage,\r\n      });\r\n    }\r\n\r\n    return res.status(500).json({\r\n      error: \"Internal server error\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\",\r\n    });\r\n  }\r\n};\r\n","import express from \"express\";\r\nimport cors from \"cors\";\r\nimport path from \"path\";\r\nimport Database from \"./config/database\";\r\nimport { handleDemo } from \"./routes/demo\";\r\nimport {\r\n  getEmployees,\r\n  getEmployee,\r\n  updateEmployeeLocation,\r\n  updateEmployeeStatus,\r\n  createEmployee,\r\n  updateEmployee,\r\n  deleteEmployee,\r\n  refreshEmployeeLocations,\r\n  clearLocationCache,\r\n} from \"./routes/employees\";\r\nimport {\r\n  getMeetings,\r\n  createMeeting,\r\n  updateMeeting,\r\n  getMeeting,\r\n  deleteMeeting,\r\n  uploadMeetingAttachments,\r\n  getActiveMeeting,\r\n  updateMeetingApproval,\r\n  updateMeetingApprovalByDetails,\r\n  getTodaysMeetings,\r\n} from \"./routes/meetings\";\r\nimport {\r\n  getTrackingSessions,\r\n  createTrackingSession,\r\n  updateTrackingSession,\r\n  addLocationToRoute,\r\n  getTrackingSession,\r\n  deleteTrackingSession,\r\n  getMeetingHistory,\r\n  addMeetingToHistory,\r\n  saveIncompleteMeetingRemark,\r\n  getIncompleteMeetingRemark,\r\n} from \"./routes/tracking\";\r\nimport {\r\n  getEmployeeAnalytics,\r\n  getEmployeeDetails,\r\n  getLeadHistory,\r\n  saveAttendance,\r\n  getAttendance,\r\n  getMeetingTrends,\r\n  getAllEmployeesDetails,\r\n} from \"./routes/analytics\";\r\nimport {\r\n  syncAllData,\r\n  getDataStatus,\r\n} from \"./routes/data-sync\";\r\nimport {\r\n  debugEmployeeData,\r\n} from \"./routes/debug\";\r\nimport {\r\n  getRouteSnapshots,\r\n  getRouteSnapshot,\r\n  createRouteSnapshot,\r\n  updateRouteSnapshot,\r\n  deleteRouteSnapshot,\r\n  getEmployeeSnapshots,\r\n} from \"./routes/route-snapshots\";\r\nimport { updateFollowUpStatus, getFollowUpHistory } from \"./routes/follow-ups\";\r\nimport { fileURLToPath } from \"url\";\r\n\r\n// ES module equivalent of __dirname\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nexport function createServer() {\r\n  const app = express();\r\n\r\n  // Initialize database connection\r\n  const initializeDatabase = async () => {\r\n    try {\r\n      const db = Database.getInstance();\r\n      await db.connect();\r\n    } catch (error) {\r\n      console.error('Failed to initialize database:', error);\r\n      // Continue without database for development\r\n    }\r\n  };\r\n\r\n  // Start database connection (non-blocking)\r\n  initializeDatabase();\r\n\r\n  // Middleware\r\n  app.use(cors());\r\n  // Increase body size limit to handle file attachments (base64 encoded)\r\n  // 20MB limit allows for ~15MB of base64 data (which is ~11MB of original files)\r\n  app.use(express.json({ limit: '20mb' }));\r\n  app.use(express.urlencoded({ extended: true, limit: '20mb' }));\r\n\r\n  // Serve uploaded files\r\n  const uploadsPath = path.join(process.cwd(), \"uploads\");\r\n  app.use(\"/uploads\", express.static(uploadsPath));\r\n\r\n  // Request logging\r\n  app.use((req, res, next) => {\r\n    console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);\r\n    next();\r\n  });\r\n\r\n  // Example API routes\r\n  app.get(\"/api/ping\", (_req, res) => {\r\n    console.log(\"Health check ping received\");\r\n    res.json({\r\n      message: \"Hello from Express server v2!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\",\r\n    });\r\n  });\r\n\r\n  app.get(\"/api/demo\", handleDemo);\r\n  \r\n  // Test endpoint for attendance\r\n  app.get(\"/api/test-attendance\", (_req, res) => {\r\n    console.log(\"Test attendance endpoint hit\");\r\n    res.json({\r\n      message: \"Attendance route is working!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\"\r\n    });\r\n  });\r\n\r\n  // Employee routes\r\n  app.get(\"/api/employees\", getEmployees);\r\n  app.post(\"/api/employees\", createEmployee);\r\n  app.get(\"/api/employees/:id\", getEmployee);\r\n  app.put(\"/api/employees/:id\", updateEmployee);\r\n  app.delete(\"/api/employees/:id\", deleteEmployee);\r\n  app.put(\"/api/employees/:id/location\", updateEmployeeLocation);\r\n  app.put(\"/api/employees/:id/status\", updateEmployeeStatus);\r\n  app.post(\"/api/employees/refresh-locations\", refreshEmployeeLocations);\r\n  app.post(\"/api/employees/clear-cache\", clearLocationCache);\r\n\r\n  // Meeting routes\r\n  app.get(\"/api/meetings\", getMeetings);\r\n  app.post(\"/api/meetings\", createMeeting);\r\n  app.get(\"/api/meetings/active\", getActiveMeeting); // üîπ NEW: Get active meeting\r\n  app.get(\"/api/meetings/today\", getTodaysMeetings); // üîπ NEW: Get today's meetings for duty summary\r\n  app.get(\"/api/meetings/:id\", getMeeting);\r\n  app.put(\"/api/meetings/:id\", updateMeeting);\r\n  app.post(\"/api/meetings/:id/attachments\", uploadMeetingAttachments);\r\n  app.put(\"/api/meetings/:id/approval\", updateMeetingApproval); // Meeting approval by ID\r\n  app.put(\"/api/meetings/approval-by-details\", updateMeetingApprovalByDetails); // Meeting approval by composite key\r\n  app.delete(\"/api/meetings/:id\", deleteMeeting);\r\n\r\n  // Tracking session routes\r\n  app.get(\"/api/tracking-sessions\", getTrackingSessions);\r\n  app.post(\"/api/tracking-sessions\", createTrackingSession);\r\n  app.get(\"/api/tracking-sessions/:id\", getTrackingSession);\r\n  app.put(\"/api/tracking-sessions/:id\", updateTrackingSession);\r\n  app.delete(\"/api/tracking-sessions/:id\", deleteTrackingSession);\r\n  app.post(\"/api/tracking-sessions/:id/location\", addLocationToRoute);\r\n\r\n  // Meeting history routes\r\n  app.get(\"/api/meeting-history\", getMeetingHistory);\r\n  app.post(\"/api/meeting-history\", addMeetingToHistory);\r\n  app.post(\"/api/incomplete-meeting-remarks\", saveIncompleteMeetingRemark);\r\n  // Expose both paths for backward compatibility and ease-of-use from the client\r\n  app.get(\"/api/get-incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n  // Preferred/clean path the frontend should call to fetch incomplete meeting remarks by employeeId\r\n  app.get(\"/api/incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n\r\n  // Analytics routes\r\n  app.get(\"/api/analytics/employees\", getEmployeeAnalytics);\r\n  app.get(\"/api/analytics/employee-details/:employeeId\", getEmployeeDetails);\r\n  app.get(\"/api/analytics/all-employees-details\", getAllEmployeesDetails); // New endpoint for all employees\r\n  app.get(\"/api/analytics/lead-history/:leadId\", getLeadHistory);\r\n  app.post(\"/api/analytics/save-attendance\", saveAttendance);\r\n  app.get(\"/api/analytics/attendance\", (req, res, next) => {\r\n    console.log(\"üéØ Attendance route hit!\", {\r\n      query: req.query,\r\n      url: req.url,\r\n      method: req.method\r\n    });\r\n    getAttendance(req, res, next);\r\n  });\r\n  app.get(\"/api/analytics/trends\", getMeetingTrends);\r\n\r\n  // Data synchronization routes\r\n  app.post(\"/api/data-sync\", syncAllData);\r\n  app.get(\"/api/data-status\", getDataStatus);\r\n\r\n  // Debug routes\r\n  app.get(\"/api/debug/employee/:employeeId\", debugEmployeeData);\r\n\r\n  // Route snapshot routes\r\n  app.get(\"/api/route-snapshots\", getRouteSnapshots);\r\n  app.post(\"/api/route-snapshots\", createRouteSnapshot);\r\n  app.get(\"/api/route-snapshots/:id\", getRouteSnapshot);\r\n  app.put(\"/api/route-snapshots/:id\", updateRouteSnapshot);\r\n  app.delete(\"/api/route-snapshots/:id\", deleteRouteSnapshot);\r\n  app.get(\"/api/employees/:employeeId/snapshots\", getEmployeeSnapshots);\r\n\r\n  // Follow-up meeting routes\r\n  app.get(\"/api/follow-ups\", getFollowUpHistory);\r\n  app.put(\"/api/follow-ups/:id\", updateFollowUpStatus);\r\n\r\n  // Serve static files in production\r\n  if (process.env.NODE_ENV === 'production') {\r\n    const distPath = path.join(__dirname, '../spa');\r\n    \r\n    console.log('üì¶ Serving static files from:', distPath);\r\n    \r\n    // Serve static files\r\n    app.use(express.static(distPath));\r\n    \r\n    // Handle React Router - serve index.html for all non-API routes\r\n    app.get('*', (req, res) => {\r\n      // Don't serve index.html for API routes\r\n      if (req.path.startsWith('/api/')) {\r\n        return res.status(404).json({ error: 'API endpoint not found' });\r\n      }\r\n      \r\n      const indexPath = path.join(distPath, 'index.html');\r\n      console.log('üìÑ Serving index.html for:', req.path);\r\n      res.sendFile(indexPath);\r\n    });\r\n  }\r\n\r\n  return app;\r\n}\r\n","import path from \"path\";\r\nimport { createServer } from \"./index\";\r\nimport * as express from \"express\";\r\n\r\nconst app = createServer();\r\nconst port = process.env.PORT || 3000;\r\n\r\n// In production, serve the built SPA files\r\nconst __dirname = import.meta.dirname;\r\nconst distPath = path.join(__dirname, \"../spa\");\r\n\r\n// Serve static files\r\napp.use(express.static(distPath));\r\n\r\n// Handle React Router - serve index.html for all non-API routes\r\napp.get(\"*\", (req, res) => {\r\n  // Don't serve index.html for API routes\r\n  if (req.path.startsWith(\"/api/\") || req.path.startsWith(\"/health\")) {\r\n    return res.status(404).json({ error: \"API endpoint not found\" });\r\n  }\r\n\r\n  res.sendFile(path.join(distPath, \"index.html\"));\r\n});\r\n\r\napp.listen(port, () => {\r\n  console.log(`üöÄ Fusion Starter server running on port ${port}`);\r\n  console.log(`üì± Frontend: http://localhost:${port}`);\r\n  console.log(`üîß API: http://localhost:${port}/api`);\r\n});\r\n\r\n// Graceful shutdown\r\nprocess.on(\"SIGTERM\", () => {\r\n  console.log(\"üõë Received SIGTERM, shutting down gracefully\");\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on(\"SIGINT\", () => {\r\n  console.log(\"üõë Received SIGINT, shutting down gracefully\");\r\n  process.exit(0);\r\n});\r\n"],"names":["CustomerContactSchema","MeetingDetailsSchema","LocationSchema","LeadInfoSchema","LocationDataSchema","EXTERNAL_API_URL","GEOCACHE_TTL","employeeStatuses","geocodeCache","EmployeeModel","fetchExternalUsers","mapExternalUserToEmployee","employee","lastGeocodingTime","GEOCODING_DELAY","reverseGeocode","response","meeting","meetingId","meetingLog","TrackingSessionModel","newSession","session","startOfWeek","pageNum","limitNum","newHistoryEntry","incompleteMeetings","durationMs","inMemoryMeetings","meetings","trackingSessions","startDate","endDate","endTime","sortDirection","totalEmployees","totalPages","paginatedEmployees","totalMeetings","start","end","__dirname","app","express","distPath"],"mappings":"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"}