{"version":3,"file":"node-build.mjs","sources":["../../server/config/database-indexes.ts","../../server/config/database.ts","../../server/routes/demo.ts","../../server/models/Meeting.ts","../../server/models/MeetingHistory.ts","../../server/models/Attendance.ts","../../server/models/TrackingSession.ts","../../server/models/Employee.ts","../../server/models/RouteSnapshot.ts","../../server/routes/employees.ts","../../server/routes/meetings.ts","../../server/routes/tracking.ts","../../server/services/cache.service.js","../../server/routes/analytics.ts","../../server/routes/data-sync.ts","../../server/routes/debug.ts","../../server/routes/route-snapshots.ts","../../server/routes/follow-ups.ts","../../server/index.ts","../../server/node-build.ts"],"sourcesContent":["// config/database-indexes.ts\r\nimport mongoose from 'mongoose';\r\n\r\nasync function createIndexes() {\r\n  try {\r\n    console.log('üîÑ Creating database indexes...');\r\n    \r\n    // Get all collections\r\n    const db = mongoose.connection.db;\r\n    if (!db) {\r\n      console.log('‚ùå No database connection available');\r\n      return;\r\n    }\r\n\r\n    // Create indexes for meetings collection\r\n    await db.collection('meetings').createIndex({ employeeId: 1 });\r\n    await db.collection('meetings').createIndex({ startTime: -1 });\r\n    await db.collection('meetings').createIndex({ employeeId: 1, startTime: -1 });\r\n    await db.collection('meetings').createIndex({ leadId: 1 });\r\n    await db.collection('meetings').createIndex({ status: 1 });\r\n    console.log('‚úÖ Meeting indexes created');\r\n    \r\n    // Create indexes for attendance collection\r\n    await db.collection('attendances').createIndex({ employeeId: 1, date: 1 }, { unique: true });\r\n    await db.collection('attendances').createIndex({ date: 1 });\r\n    await db.collection('attendances').createIndex({ employeeId: 1 });\r\n    console.log('‚úÖ Attendance indexes created');\r\n    \r\n    // Create indexes for trackingsessions collection\r\n    await db.collection('trackingsessions').createIndex({ employeeId: 1, startTime: -1 });\r\n    await db.collection('trackingsessions').createIndex({ startTime: -1 });\r\n    await db.collection('trackingsessions').createIndex({ status: 1 });\r\n    console.log('‚úÖ TrackingSession indexes created');\r\n\r\n    // Create indexes for meetinghistory collection\r\n    await db.collection('meetinghistories').createIndex({ employeeId: 1, meetingDate: -1 });\r\n    await db.collection('meetinghistories').createIndex({ leadId: 1 });\r\n    console.log('‚úÖ MeetingHistory indexes created');\r\n\r\n    console.log('üéâ All database indexes created successfully');\r\n  } catch (error: any) {\r\n    console.error('‚ùå Error creating indexes:', error.message);\r\n    // Don't throw error - continue without indexes if they already exist\r\n  }\r\n}\r\n\r\nexport { createIndexes };","// config/database.ts\nimport mongoose from 'mongoose';\nimport dotenv from 'dotenv';\nimport { createIndexes } from './database-indexes';\n\n// Load environment variables\ndotenv.config();\n\ninterface DatabaseConfig {\n  MONGODB_URI: string;\n  DB_NAME: string;\n}\n\n// Default configuration\nexport const dbConfig: DatabaseConfig = {\n  MONGODB_URI: process.env.MONGODB_URI || 'mongodb+srv://powerjbds:powerjbds@jbds.hk6xeqm.mongodb.net/',\n  DB_NAME: process.env.DB_NAME || 'employee-tracking'\n};\n\nclass Database {\n  private static instance: Database;\n  private isConnected = false;\n\n  private constructor() {}\n\n  public static getInstance(): Database {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n\n  public async connect(): Promise<void> {\n    if (this.isConnected) {\n      console.log('üì¶ Database: Already connected to MongoDB');\n      return;\n    }\n\n    try {\n      console.log('üîÑ Database: Connecting to MongoDB...');\n      \n      await mongoose.connect(dbConfig.MONGODB_URI, {\n        dbName: dbConfig.DB_NAME,\n        maxPoolSize: 50, // Increased connection pool\n        serverSelectionTimeoutMS: 10000,\n        socketTimeoutMS: 45000,\n        retryWrites: true,\n        retryReads: true,\n      });\n\n      this.isConnected = true;\n      console.log('‚úÖ Database: Successfully connected to MongoDB');\n      \n      // üî• Create indexes after successful connection\n      await createIndexes();\n      \n      // Handle connection events\n      mongoose.connection.on('error', (error) => {\n        console.error('‚ùå Database: MongoDB connection error:', error);\n        this.isConnected = false;\n      });\n\n      mongoose.connection.on('disconnected', () => {\n        console.log('üì¶ Database: MongoDB disconnected');\n        this.isConnected = false;\n      });\n\n      mongoose.connection.on('reconnected', () => {\n        console.log('üì¶ Database: MongoDB reconnected');\n        this.isConnected = true;\n      });\n\n    } catch (error) {\n      console.error('‚ùå Database: Failed to connect to MongoDB:', error);\n      this.isConnected = false;\n      throw error;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.isConnected) {\n      return;\n    }\n\n    try {\n      await mongoose.disconnect();\n      this.isConnected = false;\n      console.log('üì¶ Database: Disconnected from MongoDB');\n    } catch (error) {\n      console.error('‚ùå Database: Error disconnecting from MongoDB:', error);\n    }\n  }\n\n  public isConnectionActive(): boolean {\n    return this.isConnected && mongoose.connection.readyState === 1;\n  }\n\n  public getConnection() {\n    return mongoose.connection;\n  }\n}\n\nexport default Database;","import { RequestHandler } from \"express\";\nimport { DemoResponse } from \"@shared/api\";\n\nexport const handleDemo: RequestHandler = (req, res) => {\n  const response: DemoResponse = {\n    message: \"Hello from Express server\",\n  };\n  res.status(200).json(response);\n};\n","import mongoose, { Schema, Document } from 'mongoose';\n\n\n// Customer contact interface\ninterface CustomerContact {\n customerName: string;\n customerEmployeeName: string;\n customerEmail?: string;\n customerMobile?: string;\n customerDesignation?: string;\n customerDepartment?: string;\n}\n\n\n// Meeting details interface\ninterface MeetingDetails {\n customers: CustomerContact[];\n discussion: string;\n attachments?: string[]; // Array of base64 encoded files or URLs\n // Legacy fields for backward compatibility\n customerName?: string;\n customerEmployeeName?: string;\n customerEmail?: string;\n customerMobile?: string;\n customerDesignation?: string;\n customerDepartment?: string;\n}\n\n\n// Location interface\ninterface Location {\n lat: number;\n lng: number;\n address: string;\n timestamp: string;\n}\n\n\n// Meeting document interface\nexport interface IMeeting extends Document {\n employeeId: string;\n location: Location;\n startTime: string;\n endTime?: string;\n clientName?: string;\n notes?: string;\n status: 'started' | 'in-progress' | 'completed';\n trackingSessionId?: string;\n leadId?: string;\n leadInfo?: {\n   id: string;\n   companyName: string;\n   contactName: string;\n };\n followUpId?: string; // Follow-up meeting ID from external API\n meetingDetails?: MeetingDetails;\n externalMeetingStatus?: string; // Status from external follow-up API\n meetingStatus?: string; // Meeting completion status (complete/incomplete)\n approvalStatus?: 'ok' | 'not_ok' | 'pending'; // Meeting approval status\n approvalReason?: string; // Reason for approval/rejection\n approvedBy?: string | null; // userId who approved the meeting\n attachments?: string[]; // Array of attachment file URLs/paths\n createdAt: Date;\n updatedAt: Date;\n}\n\n\n// Customer contact schema\nconst CustomerContactSchema = new Schema({\n customerName: { type: String, required: true },\n customerEmployeeName: { type: String, required: true },\n customerEmail: { type: String },\n customerMobile: { type: String },\n customerDesignation: { type: String },\n customerDepartment: { type: String }\n});\n\n\n// Meeting details schema\nconst MeetingDetailsSchema = new Schema({\n customers: [CustomerContactSchema],\n discussion: { type: String, required: true },\n attachments: { type: [String], default: [] }, // Array of base64 encoded files or URLs\n // Legacy fields\n customerName: { type: String },\n customerEmployeeName: { type: String },\n customerEmail: { type: String },\n customerMobile: { type: String },\n customerDesignation: { type: String },\n customerDepartment: { type: String }\n});\n\n\n// Location schema\nconst CoordinateSchema = new Schema({\n lat: { type: Number, required: true },\n lng: { type: Number, required: true },\n address: { type: String, required: true },\n timestamp: { type: String }\n}, { _id: false });\n\n\nconst LocationSchema = new Schema({\n lat: { type: Number, required: true },\n lng: { type: Number, required: true },\n address: { type: String, required: true },\n endLocation: { type: CoordinateSchema },\n timestamp: { type: String, required: true }\n});\n\n\n\n\n// Lead info schema\n// const LeadInfoSchema = new Schema({\n//  id: { type: String, required: true },\n//  companyName: { type: String, required: true },\n//  contactName: { type: String, required: true }\n// });\n\n// Lead info schema (FULLY OPTIONAL)\nconst LeadInfoSchema = new Schema(\n  {\n    id: {type: String },\n    companyName: { type: String },\n    contactName: { type: String}\n  },\n  // { _id: false } // optional but recommended\n);\n\n\n\n// Main meeting schema\nconst MeetingSchema = new Schema({\n employeeId: {\n   type: String,\n   required: true,\n   index: true\n },\n location: {\n   type: LocationSchema,\n   required: true\n },\n startTime: {\n   type: String,\n   required: true,\n   index: true\n },\n endTime: {\n   type: String\n },\n clientName: {\n   type: String\n },\n notes: {\n   type: String\n },\n status: {\n   type: String,\n   enum: ['started', 'in-progress', 'completed'],\n   default: 'in-progress',\n   index: true\n },\n trackingSessionId: {\n   type: String\n },\n leadId: {\n   type: String,\n   index: true\n },\n//  leadInfo: LeadInfoSchema,\n//  followUpId: {\n//    type: String,\n//    index: true\n//  },\nleadInfo: {\n  type: LeadInfoSchema,\n  default: null // ‚úÖ IMPORTANT\n},\n followUpId: {\n   type: String,\n   index: true\n },\n meetingDetails: MeetingDetailsSchema,\n externalMeetingStatus: {\n   type: String\n },\n meetingStatus: {\n   type: String,\n   index: true\n },\n approvalStatus: {\n   type: String,\n   enum: ['ok', 'not_ok', 'pending'],\n   index: true\n },\n approvalReason: {\n   type: String\n },\n approvedBy: {\n   type: String,\n   default: null // userId who approved the meeting\n },\n attachments: {\n   type: [String],\n   default: [] // Array of attachment file URLs/paths\n }\n}, {\n timestamps: true,\n collection: 'meetings'\n});\n\n\n// Create indexes for better query performance\nMeetingSchema.index({ employeeId: 1, startTime: -1 });\nMeetingSchema.index({ leadId: 1, startTime: -1 });\nMeetingSchema.index({ status: 1, startTime: -1 });\n\n\nexport const Meeting = mongoose.model<IMeeting>('Meeting', MeetingSchema);\n\n\n\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Meeting details interface (reused from Meeting model)\ninterface MeetingDetails {\n  customers: Array<{\n    customerName: string;\n    customerEmployeeName: string;\n    customerEmail?: string;\n    customerMobile?: string;\n    customerDesignation?: string;\n    customerDepartment?: string;\n  }>;\n  discussion: string;\n  // Incomplete meeting tracking\n  incomplete?: boolean;\n  incompleteReason?: string;\n  // Legacy fields\n  customerName?: string;\n  customerEmployeeName?: string;\n  customerEmail?: string;\n  customerMobile?: string;\n  customerDesignation?: string;\n  customerDepartment?: string;\n}\n\n// Meeting history document interface\nexport interface IMeetingHistory extends Document {\n  sessionId: string;\n  employeeId: string;\n  meetingDetails: MeetingDetails;\n  timestamp: string;\n  leadId?: string;\n  leadInfo?: {\n    id: string;\n    companyName: string;\n    contactName: string;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Customer contact schema (reused)\nconst CustomerContactSchema = new Schema({\n  customerName: { type: String, required: true },\n  customerEmployeeName: { type: String, required: true },\n  customerEmail: { type: String },\n  customerMobile: { type: String },\n  customerDesignation: { type: String },\n  customerDepartment: { type: String }\n});\n\n// Meeting details schema (reused)\nconst MeetingDetailsSchema = new Schema({\n  customers: [CustomerContactSchema],\n  discussion: { type: String, required: true },\n  // Incomplete meeting tracking\n  incomplete: { type: Boolean, default: false, index: true },\n  incompleteReason: { type: String },\n  // Legacy fields\n  customerName: { type: String },\n  customerEmployeeName: { type: String },\n  customerEmail: { type: String },\n  customerMobile: { type: String },\n  customerDesignation: { type: String },\n  customerDepartment: { type: String }\n});\n\n// Lead info schema (reused)\nconst LeadInfoSchema = new Schema({\n  id: { type: String, required: true },\n  companyName: { type: String, required: true },\n  contactName: { type: String, required: true }\n});\n\n// Meeting history schema\nconst MeetingHistorySchema = new Schema({\n  sessionId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  meetingDetails: { \n    type: MeetingDetailsSchema, \n    required: true \n  },\n  timestamp: { \n    type: String, \n    required: true,\n    index: true \n  },\n  leadId: { \n    type: String,\n    index: true \n  },\n  leadInfo: LeadInfoSchema\n}, {\n  timestamps: true,\n  collection: 'meeting_history'\n});\n\n// Create indexes for better query performance\nMeetingHistorySchema.index({ employeeId: 1, timestamp: -1 });\nMeetingHistorySchema.index({ leadId: 1, timestamp: -1 });\nMeetingHistorySchema.index({ sessionId: 1, timestamp: -1 });\n\nexport const MeetingHistory = mongoose.model<IMeetingHistory>('MeetingHistory', MeetingHistorySchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Attendance document interface\nexport interface IAttendance extends Document {\n  employeeId: string;\n  date: string; // YYYY-MM-DD format\n  attendanceStatus: 'full_day' | 'half_day' | 'off' | 'short_leave' | 'ot' | 'absent';\n  attendanceReason: string;\n  attendenceCreated: string | null; // userId who created the attendance (null for tracking employee)\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Attendance schema\nconst AttendanceSchema = new Schema({\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  date: { \n    type: String, \n    required: true,\n    index: true,\n    match: /^\\d{4}-\\d{2}-\\d{2}$/ // YYYY-MM-DD format validation\n  },\n  attendanceStatus: { \n    type: String, \n    enum: ['full_day', 'half_day', 'off', 'short_leave', 'ot', 'absent'],\n    required: true,\n    default: 'full_day'\n  },\n  attendanceReason: { \n    type: String,\n    default: ''\n  },\n  attendenceCreated: {\n    type: String,\n    default: null // null for tracking employee, userId from CRM dashboard\n  }\n}, {\n  timestamps: true,\n  collection: 'attendance'\n});\n\n// Create compound unique index to prevent duplicate attendance records for same employee-date\nAttendanceSchema.index({ employeeId: 1, date: 1 }, { unique: true });\n\n// Create indexes for better query performance\nAttendanceSchema.index({ employeeId: 1, date: -1 });\nAttendanceSchema.index({ date: -1, attendanceStatus: 1 });\n\nexport const Attendance = mongoose.model<IAttendance>('Attendance', AttendanceSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location data interface\ninterface LocationData {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Tracking session document interface\nexport interface ITrackingSession extends Document {\n  id: string;\n  employeeId: string;\n  startTime: string;\n  endTime?: string;\n  startLocation: LocationData;\n  endLocation?: LocationData;\n  route: LocationData[];\n  totalDistance: number;\n  duration?: number;\n  status: 'active' | 'completed' | 'paused';\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location data schema\nconst LocationDataSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Tracking session schema\nconst TrackingSessionSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  startTime: { \n    type: String, \n    required: true,\n    index: true \n  },\n  endTime: { \n    type: String \n  },\n  startLocation: { \n    type: LocationDataSchema, \n    required: true \n  },\n  endLocation: { \n    type: LocationDataSchema \n  },\n  route: [LocationDataSchema],\n  totalDistance: { \n    type: Number, \n    default: 0 \n  },\n  duration: { \n    type: Number // Duration in seconds\n  },\n  status: { \n    type: String, \n    enum: ['active', 'completed', 'paused'],\n    default: 'active',\n    index: true \n  }\n}, {\n  timestamps: true,\n  collection: 'tracking_sessions'\n});\n\n// Create indexes for better query performance\nTrackingSessionSchema.index({ employeeId: 1, startTime: -1 });\nTrackingSessionSchema.index({ status: 1, startTime: -1 });\nTrackingSessionSchema.index({ employeeId: 1, status: 1, startTime: -1 });\n\nexport const TrackingSession = mongoose.model<ITrackingSession>('TrackingSession', TrackingSessionSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location interface\ninterface Location {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Employee document interface\nexport interface IEmployee extends Document {\n  id: string;\n  name: string;\n  email: string;\n  phone?: string;\n  status: 'active' | 'inactive' | 'meeting';\n  location?: Location;\n  lastUpdate?: string;\n  currentTask?: string;\n  deviceId?: string;\n  designation?: string;\n  department?: string;\n  companyName?: string;\n  reportTo?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location schema\nconst LocationSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Employee schema\nconst EmployeeSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  name: { \n    type: String, \n    required: true,\n    index: true \n  },\n  email: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  phone: { \n    type: String \n  },\n  status: { \n    type: String, \n    enum: ['active', 'inactive', 'meeting'],\n    default: 'inactive',\n    index: true \n  },\n  location: LocationSchema,\n  lastUpdate: { \n    type: String \n  },\n  currentTask: { \n    type: String \n  },\n  deviceId: { \n    type: String,\n    index: true \n  },\n  designation: { \n    type: String \n  },\n  department: { \n    type: String \n  },\n  companyName: { \n    type: String \n  },\n  reportTo: { \n    type: String \n  }\n}, {\n  timestamps: true,\n  collection: 'employees'\n});\n\n// Create indexes for better query performance\nEmployeeSchema.index({ status: 1, name: 1 });\nEmployeeSchema.index({ companyName: 1, department: 1 });\nEmployeeSchema.index({ name: 'text', email: 'text' }); // Text search index\n\nexport const Employee = mongoose.model<IEmployee>('Employee', EmployeeSchema);\n","import mongoose, { Schema, Document } from 'mongoose';\n\n// Location data interface\ninterface LocationData {\n  lat: number;\n  lng: number;\n  address: string;\n  timestamp: string;\n}\n\n// Meeting snapshot data interface\ninterface MeetingSnapshot {\n  id: string;\n  location: LocationData;\n  clientName?: string;\n  startTime: string;\n  endTime?: string;\n  status: string;\n}\n\n// Route snapshot document interface\nexport interface IRouteSnapshot extends Document {\n  id: string;\n  employeeId: string;\n  employeeName: string;\n  trackingSessionId?: string;\n  captureTime: string;\n  startLocation: LocationData;\n  endLocation?: LocationData;\n  route: LocationData[];\n  meetings: MeetingSnapshot[];\n  totalDistance: number;\n  duration?: number;\n  status: 'active' | 'completed';\n  title: string;\n  description?: string;\n  mapBounds: {\n    north: number;\n    south: number;\n    east: number;\n    west: number;\n  };\n  snapshotMetadata: {\n    routeColor: string;\n    mapZoom: number;\n    routePointsCount: number;\n    meetingsCount: number;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Location data schema\nconst LocationDataSchema = new Schema({\n  lat: { type: Number, required: true },\n  lng: { type: Number, required: true },\n  address: { type: String, required: true },\n  timestamp: { type: String, required: true }\n});\n\n// Meeting snapshot schema\nconst MeetingSnapshotSchema = new Schema({\n  id: { type: String, required: true },\n  location: { type: LocationDataSchema, required: true },\n  clientName: { type: String },\n  startTime: { type: String, required: true },\n  endTime: { type: String },\n  status: { type: String, required: true }\n});\n\n// Map bounds schema\nconst MapBoundsSchema = new Schema({\n  north: { type: Number, required: true },\n  south: { type: Number, required: true },\n  east: { type: Number, required: true },\n  west: { type: Number, required: true }\n});\n\n// Snapshot metadata schema\nconst SnapshotMetadataSchema = new Schema({\n  routeColor: { type: String, default: '#3b82f6' },\n  mapZoom: { type: Number, default: 12 },\n  routePointsCount: { type: Number, default: 0 },\n  meetingsCount: { type: Number, default: 0 }\n});\n\n// Route snapshot schema\nconst RouteSnapshotSchema = new Schema({\n  id: { \n    type: String, \n    required: true,\n    unique: true,\n    index: true \n  },\n  employeeId: { \n    type: String, \n    required: true,\n    index: true \n  },\n  employeeName: {\n    type: String,\n    required: true\n  },\n  trackingSessionId: { \n    type: String,\n    index: true \n  },\n  captureTime: { \n    type: String, \n    required: true,\n    index: true \n  },\n  startLocation: { \n    type: LocationDataSchema, \n    required: true \n  },\n  endLocation: { \n    type: LocationDataSchema \n  },\n  route: [LocationDataSchema],\n  meetings: [MeetingSnapshotSchema],\n  totalDistance: { \n    type: Number, \n    default: 0 \n  },\n  duration: { \n    type: Number // Duration in seconds\n  },\n  status: { \n    type: String, \n    enum: ['active', 'completed'],\n    default: 'active',\n    index: true \n  },\n  title: {\n    type: String,\n    required: true\n  },\n  description: {\n    type: String\n  },\n  mapBounds: {\n    type: MapBoundsSchema,\n    required: true\n  },\n  snapshotMetadata: {\n    type: SnapshotMetadataSchema,\n    required: true\n  }\n}, {\n  timestamps: true,\n  collection: 'route_snapshots'\n});\n\n// Create indexes for better query performance\nRouteSnapshotSchema.index({ employeeId: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ trackingSessionId: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ status: 1, captureTime: -1 });\nRouteSnapshotSchema.index({ employeeId: 1, status: 1, captureTime: -1 });\n\nexport const RouteSnapshot = mongoose.model<IRouteSnapshot>('RouteSnapshot', RouteSnapshotSchema);\n","import { RequestHandler } from \"express\";\nimport axios from \"axios\";\nimport {\n  Employee,\n  ExternalUser,\n  EmployeesResponse,\n  LocationUpdate,\n  LocationUpdateResponse,\n} from \"@shared/api\";\nimport {\n  Employee as EmployeeModel,\n  IEmployee,\n  TrackingSession,\n} from \"../models\";\n\n// Configuration\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\nconst NOMINATIM_URL = \"https://nominatim.openstreetmap.org/reverse\";\nconst GEOCACHE_TTL = 60 * 60 * 1000; // 1 hour cache TTL\n\n// Types\ninterface EmployeeStatus {\n  status: \"active\" | \"inactive\" | \"meeting\";\n  location: {\n    lat: number;\n    lng: number;\n    address: string;\n    timestamp: string;\n  };\n  lastUpdate: string;\n  currentTask?: string;\n}\n\ninterface GeocodeCacheItem {\n  address: string;\n  expires: number;\n}\n\n// State\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\n\n// Utility Functions\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n\n  if (cached && cached.expires > Date.now()) {\n    return cached.address;\n  }\n\n  try {\n    const response = await axios.get(NOMINATIM_URL, {\n      params: {\n        format: \"json\",\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1,\n      },\n      headers: {\n        \"User-Agent\": \"FieldTracker/1.0 (contact@yourdomain.com)\",\n      },\n      timeout: 5000,\n    });\n\n    const address =\n      response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n\n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL,\n    });\n\n    return address;\n  } catch (error) {\n    console.error(\"Geocoding failed:\", error);\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  }\n}\n\n// Replace your getAddressFromCoordinates function with this:\nasync function getAddressFromCoordinates(\n  lat: number,\n  lng: number,\n): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n\n  const fallbackAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n\n  // Return cached address if available and not expired\n  if (cached && cached.expires > Date.now()) {\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\n    return cached.address;\n  }\n\n  // üîπ FIX: Wait for geocoding instead of returning fallback immediately\n  try {\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\n    const response = await axios.get(NOMINATIM_URL, {\n      params: {\n        format: \"json\",\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1,\n      },\n      headers: {\n        \"User-Agent\": \"EmployeeTrackingApp/1.0\",\n      },\n      timeout: 5000, // 5 second timeout\n    });\n\n    const address = response.data?.display_name || fallbackAddress;\n    console.log(`‚úÖ Address resolved: ${address}`);\n\n    // Cache the result for future use\n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL,\n    });\n\n    return address;\n  } catch (error) {\n    console.warn(`‚ö†Ô∏è Geocoding failed for ${lat}, ${lng}, using coordinates:`, error.message);\n    // Return fallback if geocoding fails\n    return fallbackAddress;\n  }\n}\n\nasync function getEmployeeLatestLocation(employeeId: string) {\n  try {\n    // First try Employee model with timeout\n    const employee = (await Promise.race([\n      EmployeeModel.findOne({ id: employeeId }).lean(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\n      ),\n    ])) as any;\n\n    if (employee?.location?.lat && employee.location.lng !== 0) {\n      const address =\n        employee.location.address ||\n        `${employee.location.lat.toFixed(6)}, ${employee.location.lng.toFixed(6)}`;\n\n      return {\n        lat: employee.location.lat,\n        lng: employee.location.lng,\n        address,\n        timestamp: employee.location.timestamp,\n        lastUpdate: employee.lastUpdate || \"Recently updated\",\n      };\n    }\n\n    // Quick fallback to tracking sessions\n    const latestSession = (await Promise.race([\n      TrackingSession.findOne({\n        employeeId,\n        $or: [{ status: \"active\" }, { status: \"completed\" }],\n      })\n        .sort({ startTime: -1 })\n        .lean(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"db timeout\")), 500),\n      ),\n    ])) as any;\n\n    if (latestSession) {\n      const latestLocation = latestSession.route?.length\n        ? latestSession.route[latestSession.route.length - 1]\n        : latestSession.startLocation;\n\n      if (latestLocation?.lat !== 0 && latestLocation?.lng !== 0) {\n        const address =\n          latestLocation.address ||\n          `${latestLocation.lat.toFixed(6)}, ${latestLocation.lng.toFixed(6)}`;\n\n        return {\n          lat: latestLocation.lat,\n          lng: latestLocation.lng,\n          address,\n          timestamp: latestLocation.timestamp,\n          lastUpdate:\n            latestSession.status === \"active\"\n              ? \"Currently tracking\"\n              : \"From last session\",\n        };\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.warn(`Location lookup failed for ${employeeId}:`, error.message);\n    return null;\n  }\n}\n\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\n  try {\n    geocodeCache.clear();\n    res.json({ success: true, message: \"Geocode cache cleared\" });\n  } catch (error) {\n    console.error(\"Error clearing cache:\", error);\n    res.status(500).json({ error: \"Failed to clear cache\" });\n  }\n};\n\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 15000);\n\n    const response = await fetch(EXTERNAL_API_URL, {\n      signal: controller.signal,\n      headers: { Accept: \"application/json\" },\n    });\n\n    clearTimeout(timeout);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const data = await response.json();\n    return Array.isArray(data) ? data : [];\n  } catch (error) {\n    console.error(\"External API fetch failed:\", error);\n    return [];\n  }\n}\n\nasync function mapExternalUserToEmployee(\n  user: ExternalUser,\n  index: number,\n): Promise<Employee> {\n  const userId = user._id;\n\n  // Try to get location but don't block on it\n  let realLocation = null;\n  try {\n    realLocation = (await Promise.race([\n      getEmployeeLatestLocation(userId),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"timeout\")), 1000),\n      ),\n    ])) as any;\n  } catch (error) {\n    // Use default location if lookup fails/times out\n    realLocation = null;\n  }\n\n  // Initialize or update status\n  if (!employeeStatuses[userId]) {\n    employeeStatuses[userId] = {\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\n      location: realLocation || {\n        lat: 28.6139 + (Math.random() - 0.5) * 0.1, // Delhi area with variation\n        lng: 77.209 + (Math.random() - 0.5) * 0.1,\n        address: `Employee ${index + 1} Location`,\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: realLocation?.lastUpdate || \"Recently\",\n      currentTask:\n        index === 0\n          ? \"Client meeting\"\n          : index === 1\n            ? \"Equipment installation\"\n            : undefined,\n    };\n  } else if (realLocation) {\n    employeeStatuses[userId].location = {\n      lat: realLocation.lat,\n      lng: realLocation.lng,\n      address: realLocation.address,\n      timestamp: realLocation.timestamp,\n    };\n    employeeStatuses[userId].lastUpdate = realLocation.lastUpdate;\n  }\n\n  const status = employeeStatuses[userId];\n\n  return {\n    id: userId,\n    name: user.name,\n    email: user.email,\n    phone: user.mobileNumber,\n    status: status.status,\n    location: status.location,\n    lastUpdate: status.lastUpdate,\n    currentTask: status.currentTask,\n    deviceId: `device_${userId.slice(-6)}`,\n    designation: user.designation,\n    department: user.department,\n    companyName: user.companyName[0]?.companyName,\n    reportTo: user.report?.name,\n  };\n}\n\n// API Handlers\nexport const getEmployees: RequestHandler = async (req, res) => {\n  try {\n    if (req.query.clearCache === \"true\") {\n      employeeStatuses = {};\n      geocodeCache.clear();\n    }\n\n    const externalUsers = await fetchExternalUsers();\n    if (externalUsers.length > 0) {\n      const employees = await Promise.all(\n        externalUsers.map((user, index) =>\n          mapExternalUserToEmployee(user, index),\n        ),\n      );\n\n      // Sync to MongoDB\n      try {\n        await Promise.all(\n          employees.map((employee) =>\n            EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\n              upsert: true,\n              new: true,\n            }),\n          ),\n        );\n      } catch (dbError) {\n        console.warn(\"MongoDB sync failed:\", dbError);\n      }\n\n      return res.json({ employees, total: employees.length });\n    }\n\n    // Fallback to MongoDB\n    try {\n      const mongoEmployees = await EmployeeModel.find({}).lean();\n      return res.json({\n        employees: mongoEmployees,\n        total: mongoEmployees.length,\n      });\n    } catch (dbError) {\n      console.warn(\"MongoDB fallback failed:\", dbError);\n      return res.json({ employees: [], total: 0 });\n    }\n  } catch (error) {\n    console.error(\"Employee fetch failed:\", error);\n    res.status(500).json({ error: \"Failed to fetch employees\" });\n  }\n};\n\nexport const getEmployee: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const externalUsers = await fetchExternalUsers();\n\n    if (externalUsers.length > 0) {\n      const user = externalUsers.find((u) => u._id === id);\n      if (user) {\n        const employee = await mapExternalUserToEmployee(\n          user,\n          externalUsers.indexOf(user),\n        );\n\n        try {\n          await EmployeeModel.findOneAndUpdate({ id }, employee, {\n            upsert: true,\n            new: true,\n          });\n        } catch (dbError) {\n          console.warn(\"MongoDB update failed:\", dbError);\n        }\n\n        return res.json(employee);\n      }\n    }\n\n    // Fallback to MongoDB\n    try {\n      const employee = await EmployeeModel.findOne({ id }).lean();\n      if (employee) return res.json(employee);\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed:\", dbError);\n    }\n\n    return res.status(404).json({ error: \"Employee not found\" });\n  } catch (error) {\n    console.error(\"Employee fetch failed:\", error);\n    res.status(500).json({ error: \"Failed to fetch employee\" });\n  }\n};\n\nexport const updateEmployeeLocation: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { lat, lng } = req.body;\n\n    // Get human-readable address\n    const address = await getAddressFromCoordinates(lat, lng);\n\n    const locationUpdate = {\n      location: {\n        lat,\n        lng,\n        address, // Now contains human-readable address\n        timestamp: new Date().toISOString(),\n      },\n      lastUpdate: \"Just now\",\n      status: \"active\",\n    };\n\n    // Rest of your existing implementation...\n    try {\n      const updatedEmployee = await EmployeeModel.findOneAndUpdate(\n        { id },\n        { $set: locationUpdate },\n        { new: true },\n      );\n\n      if (updatedEmployee) {\n        return res.json({ success: true, employee: updatedEmployee });\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed:\", dbError);\n    }\n\n    // Fallback to in-memory\n    const externalUsers = await fetchExternalUsers();\n    const userIndex = externalUsers.findIndex((user) => user._id === id);\n\n    if (userIndex === -1) {\n      return res.status(404).json({ error: \"Employee not found\" });\n    }\n\n    employeeStatuses[id] = employeeStatuses[id]\n      ? { ...employeeStatuses[id], ...locationUpdate }\n      : { ...locationUpdate, status: \"active\", currentTask: undefined };\n\n    const employee = await mapExternalUserToEmployee(\n      externalUsers[userIndex],\n      userIndex,\n    );\n    res.json({ success: true, employee });\n  } catch (error) {\n    console.error(\"Error updating location:\", error);\n    res.status(500).json({ error: \"Failed to update location\" });\n  }\n};\n\nexport const updateEmployeeStatus: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { status, currentTask } = req.body;\n    const update = { status, currentTask, lastUpdate: \"Just now\" };\n\n    try {\n      const employee = await EmployeeModel.findOneAndUpdate(\n        { id },\n        { $set: update },\n        { new: true },\n      );\n\n      if (employee) return res.json(employee);\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed:\", dbError);\n    }\n\n    // Fallback to in-memory\n    const externalUsers = await fetchExternalUsers();\n    const user = externalUsers.find((u) => u._id === id);\n\n    if (!user) return res.status(404).json({ error: \"Employee not found\" });\n\n    if (!employeeStatuses[id]) {\n      const location = await getEmployeeLatestLocation(id);\n      employeeStatuses[id] = {\n        status: \"active\",\n        location: location || {\n          lat: 0,\n          lng: 0,\n          address: \"Location not available\",\n          timestamp: new Date().toISOString(),\n        },\n        lastUpdate: location?.lastUpdate || \"Location not tracked\",\n      };\n    }\n\n    employeeStatuses[id] = { ...employeeStatuses[id], ...update };\n    const employee = await mapExternalUserToEmployee(\n      user,\n      externalUsers.indexOf(user),\n    );\n    res.json(employee);\n  } catch (error) {\n    console.error(\"Status update failed:\", error);\n    res.status(500).json({ error: \"Failed to update status\" });\n  }\n};\n\nexport const clearLocationCache: RequestHandler = async (req, res) => {\n  try {\n    employeeStatuses = {};\n    geocodeCache.clear();\n    res.json({ success: true, message: \"Cache cleared successfully\" });\n  } catch (error) {\n    console.error(\"Cache clear failed:\", error);\n    res.status(500).json({ error: \"Failed to clear cache\" });\n  }\n};\n\nexport const refreshEmployeeLocations: RequestHandler = async (req, res) => {\n  try {\n    employeeStatuses = {};\n    const externalUsers = await fetchExternalUsers();\n    const employees = await Promise.all(\n      externalUsers.map((user, index) =>\n        mapExternalUserToEmployee(user, index),\n      ),\n    );\n\n    try {\n      await Promise.all(\n        employees.map((employee) =>\n          EmployeeModel.findOneAndUpdate({ id: employee.id }, employee, {\n            upsert: true,\n            new: true,\n          }),\n        ),\n      );\n    } catch (dbError) {\n      console.warn(\"MongoDB sync failed:\", dbError);\n    }\n\n    res.json({\n      success: true,\n      message: `Refreshed ${employees.length} employees`,\n      employees,\n    });\n  } catch (error) {\n    console.error(\"Refresh failed:\", error);\n    res.status(500).json({ error: \"Failed to refresh locations\" });\n  }\n};\n\n// Placeholder handlers\nexport const createEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for creation\" });\n\nexport const updateEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for updates\" });\n\nexport const deleteEmployee: RequestHandler = (req, res) =>\n  res.status(501).json({ error: \"Use external API for deletion\" });\n","import { RequestHandler } from \"express\";\nimport axios from 'axios';\nimport NodeCache from 'node-cache';\nimport {\n  MeetingLog,\n  MeetingLogsResponse,\n  CreateMeetingRequest,\n} from \"@shared/api\";\nimport { Meeting, IMeeting } from \"../models\";\nimport CacheService from \"../services/cache\";\n\n// Initialize cache with 1 hour TTL\nconst geocodeCache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });\n\n// üîπ Helper function to format time for IST display\nfunction formatTimeForIST(utcTime: string): string {\n  const date = new Date(utcTime);\n  // Return IST formatted time\n  return date.toLocaleString('en-IN', {\n    timeZone: 'Asia/Kolkata',\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false\n  });\n}\n\n// üîπ Helper function to get current time in IST\nfunction getCurrentTimeIST(): string {\n  const now = new Date();\n  return now.toISOString(); // Keep UTC in database, format on display\n}\n\n// Helper function for reverse geocoding\n// Rate limiting for Nominatim API (max 1 request per second)\nlet lastGeocodingTime = 0;\nconst GEOCODING_DELAY = 1000; // 1 second\n\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n\n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cachedAddress = geocodeCache.get<string>(cacheKey);\n  if (cachedAddress) {\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cachedAddress}`);\n    return cachedAddress;\n  }\n\n  try {\n    // Rate limiting: wait if needed\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastGeocodingTime;\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    lastGeocodingTime = Date.now();\n\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\n      params: {\n        format: 'json',\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1\n      },\n      headers: {\n        'User-Agent': 'EmployeeTrackingApp/1.0'\n      },\n      timeout: 5000\n    });\n\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n    console.log(`‚úÖ Address resolved: ${address}`);\n    geocodeCache.set(cacheKey, address);\n    return address;\n  } catch (error) {\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  }\n}\n\n// Enhanced meeting conversion with address handling\nasync function convertMeetingToMeetingLog(meeting: IMeeting): Promise<MeetingLog> {\n  const location = meeting.location;\n  const address = await reverseGeocode(location.lat, location.lng);\n\n  return {\n    id: meeting._id.toString(),\n    employeeId: meeting.employeeId,\n    location: {\n      ...location,\n      address // Use the geocoded address\n    },\n    startTime: meeting.startTime,\n    endTime: meeting.endTime,\n    clientName: meeting.clientName,\n    notes: meeting.notes,\n    status: meeting.status as \"started\" | \"in-progress\" | \"completed\",\n    trackingSessionId: meeting.trackingSessionId,\n    leadId: meeting.leadId,\n    leadInfo: meeting.leadInfo,\n    followUpId: meeting.followUpId, // üîπ Include follow-up ID\n    meetingDetails: meeting.meetingDetails,\n    approvalStatus: meeting.approvalStatus, // Meeting approval status\n    approvalReason: meeting.approvalReason, // Meeting approval reason\n    approvedBy: meeting.approvedBy, // User ID who approved the meeting\n  };\n}\n\n// In-memory fallback storage\nlet inMemoryMeetings: MeetingLog[] = [];\n\n// Export for analytics fallback\nexport { inMemoryMeetings };\n\nexport const getMeetings: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\n\n    // Build query\n    const query: any = {};\n    if (employeeId) query.employeeId = employeeId;\n    if (status) query.status = status;\n\n    if (startDate || endDate) {\n      query.startTime = {};\n      if (startDate) query.startTime.$gte = new Date(startDate as string);\n      if (endDate) query.startTime.$lte = new Date(endDate as string);\n    }\n\n    console.log(\"üì• Fetching meetings with query:\", JSON.stringify(query, null, 2));\n\n    // Try MongoDB first\n    try {\n      // üîπ DEBUG: Count total meetings for this employee\n      if (employeeId) {\n        const totalCount = await Meeting.countDocuments({ employeeId });\n        console.log(`üìä Total meetings in DB for employee ${employeeId}:`, totalCount);\n      }\n\n      const mongoMeetings = await Meeting.find(query)\n        .sort({ startTime: -1 })\n        .limit(parseInt(limit as string))\n        .lean();\n\n      // Convert all meetings with proper addresses\n      const meetingLogs = await Promise.all(\n        mongoMeetings.map(meeting => convertMeetingToMeetingLog(meeting))\n      );\n\n      const response: MeetingLogsResponse = {\n        meetings: meetingLogs,\n        total: meetingLogs.length,\n      };\n\n      console.log(`‚úÖ Found ${meetingLogs.length} meetings matching query:`,\n        meetingLogs.map(m => ({ id: m.id, status: m.status, followUpId: m.followUpId, client: m.clientName }))\n      );\n\n      // üîπ DEBUG: If no meetings found but we expected some\n      if (meetingLogs.length === 0 && employeeId) {\n        console.warn(\"‚ö†Ô∏è No meetings found for query, checking all statuses...\");\n        const allMeetings = await Meeting.find({ employeeId }).lean();\n        console.log(\"üìã All meetings for this employee:\",\n          allMeetings.map(m => ({ id: m._id, status: m.status, followUpId: m.followUpId }))\n        );\n      }\n\n      res.json(response);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    let filteredMeetings = inMemoryMeetings;\n\n    if (employeeId) {\n      filteredMeetings = filteredMeetings.filter(\n        (meeting) => meeting.employeeId === employeeId,\n      );\n    }\n\n    if (status) {\n      filteredMeetings = filteredMeetings.filter(\n        (meeting) => meeting.status === status,\n      );\n    }\n\n    if (startDate) {\n      filteredMeetings = filteredMeetings.filter(\n        (meeting) => new Date(meeting.startTime) >= new Date(startDate as string),\n      );\n    }\n\n    if (endDate) {\n      filteredMeetings = filteredMeetings.filter(\n        (meeting) => new Date(meeting.startTime) <= new Date(endDate as string),\n      );\n    }\n\n    filteredMeetings.sort(\n      (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\n    );\n\n    if (limit) {\n      filteredMeetings = filteredMeetings.slice(0, parseInt(limit as string));\n    }\n\n    const response: MeetingLogsResponse = {\n      meetings: filteredMeetings,\n      total: filteredMeetings.length,\n    };\n\n    console.log(`Found ${filteredMeetings.length} meetings in memory`);\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error fetching meetings:\", error);\n    res.status(500).json({ error: \"Failed to fetch meetings\" });\n  }\n};\n\nexport const getMeeting: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Try MongoDB first\n    try {\n      const meeting = await Meeting.findById(id).lean();\n      if (!meeting) {\n        return res.status(404).json({ error: \"Meeting not found in database\" });\n      }\n\n      const meetingLog = await convertMeetingToMeetingLog(meeting);\n      console.log(\"Meeting found in MongoDB:\", meeting._id);\n      res.json(meetingLog);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const meeting = inMemoryMeetings.find((meeting) => meeting.id === id);\n\n    if (!meeting) {\n      return res.status(404).json({ error: \"Meeting not found\" });\n    }\n\n    console.log(\"Meeting found in memory:\", meeting.id);\n    res.json(meeting);\n  } catch (error) {\n    console.error(\"Error fetching meeting:\", error);\n    res.status(500).json({ error: \"Failed to fetch meeting\" });\n  }\n};\n\n// export const createMeeting: RequestHandler = async (req, res) => {\n//   try {\n//     const { employeeId, location, clientName, notes, leadId, leadInfo, followUpId, externalMeetingStatus, startTime } = req.body;\n\n//     if (!employeeId || !location) {\n//       return res.status(400).json({ error: \"Employee ID and location are required\" });\n//     }\n\n//     // Get human-readable address\n//     const address = await reverseGeocode(location.lat, location.lng);\n\n//     // üîπ CRITICAL FIX: Store times in UTC, don't convert to IST on server\n//     const meetingStartTime = startTime || new Date().toISOString();\n\n//     console.log(\"üìÖ Meeting start time (UTC):\", {\n//       clientProvided: !!startTime,\n//       utcTime: meetingStartTime,\n//       istDisplay: formatTimeForIST(meetingStartTime),\n//       currentUTC: new Date().toISOString(),\n//       currentISTDisplay: formatTimeForIST(new Date().toISOString())\n//     });\n\n//     const meetingData = {\n//       employeeId,\n//       location: {\n//         ...location,\n//         address,\n//         timestamp: new Date().toISOString()\n//       },\n//       startTime: meetingStartTime, // üîπ Use the exact time when user clicked start\n//       clientName,\n//       notes,\n//       status: \"in-progress\" as const,\n//       leadId: leadId || undefined,\n//       leadInfo: leadInfo || undefined,\n//       followUpId: followUpId || undefined, // üîπ Store follow-up meeting ID\n//       externalMeetingStatus: externalMeetingStatus || undefined, // üîπ NEW: Store external meeting status\n//     };\n\n//     // Try MongoDB first\n//     try {\n//       const newMeeting = new Meeting(meetingData);\n//       const savedMeeting = await newMeeting.save();\n//       const meetingLog = await convertMeetingToMeetingLog(savedMeeting);\n\n//       console.log(\"‚úÖ Meeting saved to MongoDB:\", {\n//         id: savedMeeting._id,\n//         employeeId: savedMeeting.employeeId,\n//         followUpId: savedMeeting.followUpId,\n//         status: savedMeeting.status,\n//         clientName: savedMeeting.clientName\n//       });\n\n//       // üîπ VERIFICATION: Immediately query to confirm it was saved\n//       try {\n//         const verification = await Meeting.findById(savedMeeting._id);\n//         if (verification) {\n//           console.log(\"‚úÖ VERIFIED: Meeting exists in database\");\n//           console.log(\"‚úÖ VERIFIED followUpId:\", verification.followUpId);\n//           console.log(\"‚úÖ VERIFIED status:\", verification.status);\n\n//           // Also verify we can find it by followUpId\n//           if (verification.followUpId) {\n//             const byFollowUpId = await Meeting.findOne({ \n//               followUpId: verification.followUpId,\n//               status: { $in: [\"in-progress\", \"started\"] }\n//             });\n//             if (byFollowUpId) {\n//               console.log(\"‚úÖ VERIFIED: Can find meeting by followUpId\");\n//             } else {\n//               console.error(\"‚ùå VERIFICATION FAILED: Cannot find meeting by followUpId!\");\n//             }\n//           }\n//         } else {\n//           console.error(\"‚ùå VERIFICATION FAILED: Meeting not found after save!\");\n//         }\n//       } catch (verifyError) {\n//         console.error(\"‚ùå VERIFICATION ERROR:\", verifyError);\n//       }\n\n//       res.status(201).json(meetingLog);\n//       return;\n//     } catch (dbError) {\n//       console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\n//     }\n\n//     // Fallback to in-memory storage\n//     const meetingId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n//     const meetingLog: MeetingLog = {\n//       id: meetingId,\n//       employeeId: meetingData.employeeId,\n//       location: meetingData.location,\n//       startTime: meetingData.startTime,\n//       clientName: meetingData.clientName,\n//       notes: meetingData.notes,\n//       status: meetingData.status,\n//       leadId: meetingData.leadId,\n//       leadInfo: meetingData.leadInfo,\n//     };\n\n//     inMemoryMeetings.push(meetingLog);\n\n//     console.log(\"Meeting saved to memory:\", meetingId);\n//     res.status(201).json(meetingLog);\n//   } catch (error) {\n//     console.error(\"Error creating meeting:\", error);\n//     res.status(500).json({ error: \"Failed to create meeting\" });\n//   }\n// };\n\nexport const createMeeting: RequestHandler = async (req, res) => {\n\n  console.log(\"bodyy before try of start:\", req.body);\n\n  try {\n    const {\n      employeeId,\n      location,\n      clientName,\n      notes,\n      leadId,\n      leadInfo,\n      followUpId,\n      externalMeetingStatus,\n      startTime,\n    } = req.body;\n    console.log(\"bodyy of start:\", req.body);\n\n    if (!employeeId || !location) {\n      return res.status(400).json({ error: \"Employee ID and location are required\" });\n    }\n\n    const address = await reverseGeocode(location.lat, location.lng);\n\n    // üîí START TIME ‚Äî SET ONCE\n    const meetingStartTime = startTime ?? new Date().toISOString();\n    const sanitizedLeadInfo =\n      leadInfo && Object.keys(leadInfo).length > 0 ? leadInfo : undefined;\n\n\n    const meeting = await Meeting.create({\n      employeeId,\n      location: {\n        ...location,\n        address,\n        timestamp: new Date().toISOString(),\n      },\n      startTime: meetingStartTime,\n      clientName,\n      notes,\n      status: \"in-progress\",\n      meetingStatus: \"in-progress\", // Initialize meetingStatus\n      leadId,\n      leadInfo: sanitizedLeadInfo || undefined,\n      followUpId,\n      externalMeetingStatus,\n    });\n\n    console.log(\"‚úÖ START MEETING:\", {\n      id: meeting._id,\n      startTime: meeting.startTime,\n    });\n\n    const meetingLog = await convertMeetingToMeetingLog(meeting);\n    res.status(201).json(meetingLog);\n  } catch (error) {\n    console.error(\"‚ùå Error starting meeting:\", error);\n    res.status(500).json({ error: \"Failed to start meeting\" });\n  }\n};\n\nexport const updateMeeting: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n\n    let meeting = null;\n\n    // 1Ô∏è‚É£ Try by ID (normal flow)\n    if (id && id !== \"undefined\" && id !== \"null\") {\n      try {\n        meeting = await Meeting.findById(id);\n        console.log(`üîç Found meeting by ID: ${id}`, meeting ? \"‚úÖ\" : \"‚ùå\");\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Invalid meeting ID format: ${id}`);\n      }\n    }\n\n    // 2Ô∏è‚É£ FALLBACK ‚Äî tab was closed, find active meeting by employeeId\n    if (!meeting) {\n      const { employeeId, followUpId } = req.body;\n\n      if (!employeeId) {\n        return res.status(400).json({ error: \"employeeId required to end meeting\" });\n      }\n\n      console.log(`üîç Searching for active meeting - employeeId: ${employeeId}, followUpId: ${followUpId}`);\n\n      const startOfToday = new Date();\n      startOfToday.setHours(0, 0, 0, 0);\n\n      // Build query to find active meeting\n      const query: any = {\n        employeeId,\n        status: { $in: [\"in-progress\", \"started\"] },\n        startTime: { $gte: startOfToday.toISOString() },\n      };\n\n      // Add followUpId to query if provided for more specific matching\n      if (followUpId) {\n        query.followUpId = followUpId;\n      }\n\n      // Exclude already completed meetings\n      query.$or = [\n        { meetingStatus: { $exists: false } },\n        { meetingStatus: { $ne: \"complete\" } }\n      ];\n\n      console.log(\"üîç Active meeting query:\", JSON.stringify(query, null, 2));\n\n      meeting = await Meeting.findOne(query).sort({ startTime: -1 });\n      \n      if (meeting) {\n        console.log(`‚úÖ Found active meeting by fallback search: ${meeting._id}`);\n      } else {\n        console.log(\"‚ùå No active meeting found with fallback search\");\n        \n        // Debug: Check what meetings exist for this employee today\n        const allTodayMeetings = await Meeting.find({\n          employeeId,\n          startTime: { $gte: startOfToday.toISOString() }\n        }).lean();\n        \n        console.log(\"üìã All meetings for employee today:\", allTodayMeetings.map(m => ({\n          id: m._id,\n          status: m.status,\n          meetingStatus: m.meetingStatus,\n          followUpId: m.followUpId,\n          startTime: m.startTime\n        })));\n      }\n    }\n\n    if (!meeting) {\n      return res.status(404).json({ error: \"No active meeting found to end\" });\n    }\n\n    console.log(`üìù Ending meeting: ${meeting._id}`);\n\n    // üîí ABSOLUTE PROTECTION - never allow these to be overwritten\n    delete updates.startTime;\n    delete updates.status;\n\n    // ‚úÖ Set completion status deterministically\n    meeting.status = \"completed\";\n    meeting.meetingStatus = \"complete\";\n    meeting.endTime = updates.endTime || new Date().toISOString();\n\n    // Optional fields (only if provided)\n    if (updates.meetingDetails) {\n      meeting.meetingDetails = updates.meetingDetails;\n    }\n\n    if (updates.externalMeetingStatus) {\n      meeting.externalMeetingStatus = updates.externalMeetingStatus;\n    }\n\n    // üìç End location (matches your current logic)\n    if (updates.endLocation) {\n      meeting.location.endLocation = {\n        lat: updates.endLocation.lat,\n        lng: updates.endLocation.lng,\n        address:\n          updates.endLocation.address ||\n          `${updates.endLocation.lat}, ${updates.endLocation.lng}`,\n        timestamp: updates.endLocation.timestamp || new Date().toISOString(),\n      };\n    }\n\n    // üîí FINAL CONSISTENCY GUARANTEE\n    if (meeting.status === \"completed\") {\n      meeting.meetingStatus = \"complete\";\n    }\n\n    if (meeting.meetingStatus === \"complete\") {\n      meeting.status = \"completed\";\n    }\n\n    await meeting.save();\n\n    console.log(\"‚úÖ END MEETING SAVED:\", {\n      id: meeting._id,\n      status: meeting.status,\n      meetingStatus: meeting.meetingStatus,\n      startTime: meeting.startTime,\n      endTime: meeting.endTime,\n    });\n\n    const meetingLog = await convertMeetingToMeetingLog(meeting);\n    res.status(200).json(meetingLog);\n  } catch (error) {\n    console.error(\"‚ùå Error ending meeting:\", error);\n    res.status(500).json({ error: \"Failed to end meeting\" });\n  }\n};\n\n\n// export const updateMeeting: RequestHandler = async (req, res) => {\n//   try {\n//     const { id } = req.params;\n//     const updates = req.body;\n\n//     console.log(`üìù Updating meeting ${id} with status: ${updates.status}`);\n//     console.log(`üìç End location in request:`, updates.endLocation);\n\n//     // üîπ CRITICAL FIX: Never allow startTime to be overwritten\n//     if (updates.startTime) {\n//       console.warn(\"‚ö†Ô∏è Attempt to update startTime blocked - preserving original startTime\");\n//       delete updates.startTime;\n//     }\n\n//     // üîπ ADDITIONAL PROTECTION: Ensure endTime is never set to startTime for today's meetings\n//     if (updates.endTime && updates.status === \"completed\") {\n//       console.log(`üìã Meeting completion - endTime: ${updates.endTime}`);\n\n//       // Validate that endTime is different from startTime (if we can access it)\n//       try {\n//         const currentMeeting = await Meeting.findById(id).lean();\n//         if (currentMeeting && currentMeeting.startTime) {\n//           const startTime = new Date(currentMeeting.startTime).getTime();\n//           const endTime = new Date(updates.endTime).getTime();\n//           const timeDifference = endTime - startTime;\n\n//           console.log(`‚è∞ Time validation:`, {\n//             startTime: currentMeeting.startTime,\n//             endTime: updates.endTime,\n//             differenceMs: timeDifference,\n//             differenceMinutes: Math.round(timeDifference / (1000 * 60))\n//           });\n\n//           // For Today's Meetings specifically: ensure endTime is at least 1 minute after startTime\n//           if (timeDifference <= 0) {\n//             console.error(\"‚ùå CRITICAL: End time must be after start time!\");\n//             updates.endTime = new Date(startTime + 60000).toISOString(); // Add 1 minute minimum\n//             console.log(`üîß FIXED: Adjusted endTime to be 1 minute after startTime: ${updates.endTime}`);\n//           } else if (timeDifference < 30000) {\n//             // Warn if times are suspiciously close (less than 30 seconds apart)\n//             console.warn(\"‚ö†Ô∏è WARNING: Start and end times are very close together!\");\n//             console.warn(\"This might indicate a timing issue in the client or server.\");\n//           }\n//         }\n//       } catch (validationError) {\n//         console.warn(\"Could not validate meeting times:\", validationError);\n//       }\n//     }\n\n//     // Log attachments info\n//     if (updates.meetingDetails?.attachments) {\n//       console.log(`üìé Attachments received: ${updates.meetingDetails.attachments.length} files`);\n//       updates.meetingDetails.attachments.forEach((att: string, idx: number) => {\n//         const size = att.length;\n//         const type = att.match(/data:([^;]+);/)?.[1] || 'unknown';\n//         console.log(`   File ${idx + 1}: ${type}, ${(size / 1024).toFixed(2)} KB`);\n//       });\n//     } else {\n//       console.log(`üìé No attachments in request`);\n//     }\n\n//     // Handle meeting completion\n//     if (updates.status === \"completed\") {\n//       if (!updates.endTime) {\n//         // Only set endTime if not provided by client - store in UTC\n//         updates.endTime = new Date().toISOString();\n//         console.log(`‚è∞ Setting endTime to current server time (UTC): ${updates.endTime}`);\n//         console.log(`‚è∞ IST display: ${formatTimeForIST(updates.endTime)}`);\n//         console.warn(`‚ö†Ô∏è WARNING: Client did not provide endTime, using server time instead`);\n//       } else {\n//         // Keep client-provided endTime as UTC\n//         console.log(`‚è∞ Using client-provided endTime (UTC): ${updates.endTime}`);\n//         console.log(`‚è∞ IST display: ${formatTimeForIST(updates.endTime)}`);\n\n//         // üîπ CRITICAL VALIDATION: Ensure endTime is not the same as startTime\n//         try {\n//           const currentMeeting = await Meeting.findById(id).lean();\n//           if (currentMeeting && currentMeeting.startTime) {\n//             if (updates.endTime === currentMeeting.startTime) {\n//               console.error(`‚ùå CRITICAL ERROR: Client provided endTime is identical to startTime!`);\n//               console.error(`   StartTime: ${currentMeeting.startTime}`);\n//               console.error(`   EndTime: ${updates.endTime}`);\n//               console.error(`   This will cause the timing issue! Using server time instead.`);\n\n//               // Use server time to prevent the timing issue\n//               updates.endTime = new Date().toISOString();\n//               console.log(`üîß FIXED: Using server time instead: ${updates.endTime}`);\n//             } else {\n//               const startTime = new Date(currentMeeting.startTime).getTime();\n//               const endTime = new Date(updates.endTime).getTime();\n//               const duration = endTime - startTime;\n\n//               console.log(`‚úÖ VALIDATION PASSED: Times are different`);\n//               console.log(`   Duration: ${Math.round(duration / (1000 * 60))} minutes`);\n//             }\n//           }\n//         } catch (validationError) {\n//           console.warn(\"Could not validate meeting times:\", validationError);\n//         }\n//       }\n//     }\n\n//     // Validate meeting details\n//     if (updates.meetingDetails && !updates.meetingDetails.discussion?.trim()) {\n//       return res.status(400).json({ error: \"Discussion details are required\" });\n//     }\n\n//     // üîπ CRITICAL FIX: Capture end location when meeting is completed\n//     if (updates.status === \"completed\" && updates.endLocation) {\n//       console.log(\"üìç Capturing end location for meeting:\", JSON.stringify(updates.endLocation, null, 2));\n//       // Store end location in the location.endLocation field\n//       updates[\"location.endLocation\"] = {\n//         lat: updates.endLocation.lat,\n//         lng: updates.endLocation.lng,\n//         address: updates.endLocation.address || `${updates.endLocation.lat.toFixed(6)}, ${updates.endLocation.lng.toFixed(6)}`,\n//         timestamp: updates.endLocation.timestamp || new Date().toISOString(),\n//       };\n//       console.log(\"‚úÖ End location formatted:\", JSON.stringify(updates[\"location.endLocation\"], null, 2));\n//       // Remove the top-level endLocation field as it's now nested\n//       delete updates.endLocation;\n//     } else if (updates.status === \"completed\") {\n//       console.warn(\"‚ö†Ô∏è Meeting completed but no endLocation provided in request!\");\n//     }\n\n//     // Try MongoDB first\n//     try {\n//       // üîπ VERIFICATION: Get the current meeting data before update\n//       const currentMeeting = await Meeting.findById(id);\n//       if (!currentMeeting) {\n//         return res.status(404).json({ error: \"Meeting not found in database\" });\n//       }\n\n//       console.log(\"üìã Current meeting before update:\", {\n//         id: currentMeeting._id,\n//         startTime: currentMeeting.startTime,\n//         endTime: currentMeeting.endTime,\n//         status: currentMeeting.status,\n//         clientName: currentMeeting.clientName\n//       });\n\n//       const updatedMeeting = await Meeting.findByIdAndUpdate(\n//         id,\n//         { $set: updates },\n//         { new: true, runValidators: true }\n//       );\n\n//       if (!updatedMeeting) {\n//         return res.status(404).json({ error: \"Meeting not found in database\" });\n//       }\n\n//       console.log(\"üìã Meeting after update:\", {\n//         id: updatedMeeting._id,\n//         startTime: updatedMeeting.startTime,\n//         endTime: updatedMeeting.endTime,\n//         status: updatedMeeting.status,\n//         clientName: updatedMeeting.clientName\n//       });\n\n//       // üîπ VERIFICATION: Ensure startTime was not changed\n//       if (currentMeeting.startTime !== updatedMeeting.startTime) {\n//         console.error(\"‚ùå CRITICAL ERROR: startTime was changed during update!\");\n//         console.error(\"Original startTime:\", currentMeeting.startTime);\n//         console.error(\"New startTime:\", updatedMeeting.startTime);\n//       } else {\n//         console.log(\"‚úÖ VERIFIED: startTime preserved correctly\");\n//       }\n\n//       console.log(\"Meeting updated in MongoDB:\", updatedMeeting._id);\n//       if (updatedMeeting.location?.endLocation) {\n//         console.log(\"‚úÖ End location saved:\", updatedMeeting.location.endLocation);\n//       }\n\n//       // Log attachments storage\n//       if (updatedMeeting.meetingDetails?.attachments) {\n//         console.log(`‚úÖ Attachments stored: ${updatedMeeting.meetingDetails.attachments.length} files`);\n//       } else {\n//         console.log(`‚ö†Ô∏è No attachments in stored meeting`);\n//       }\n\n//       const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\n\n//       // Verify attachments in response\n//       if (meetingLog.meetingDetails?.attachments) {\n//         console.log(`‚úÖ Attachments in response: ${meetingLog.meetingDetails.attachments.length} files`);\n//       } else {\n//         console.log(`‚ö†Ô∏è No attachments in response`);\n//       }\n\n//       res.json(meetingLog);\n//       return;\n//     } catch (dbError) {\n//       console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\n//     }\n\n//     // Fallback to in-memory storage\n//     const meetingIndex = inMemoryMeetings.findIndex((meeting) => meeting.id === id);\n//     if (meetingIndex === -1) {\n//       return res.status(404).json({ error: \"Meeting not found\" });\n//     }\n\n//     inMemoryMeetings[meetingIndex] = {\n//       ...inMemoryMeetings[meetingIndex],\n//       ...updates,\n//     };\n\n//     console.log(\"Meeting updated in memory:\", id);\n//     res.json(inMemoryMeetings[meetingIndex]);\n//   } catch (error) {\n//     console.error(\"Error updating meeting:\", error);\n//     res.status(500).json({ error: \"Failed to update meeting\" });\n//   }\n// };\n\nexport const deleteMeeting: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Try MongoDB first\n    try {\n      const deletedMeeting = await Meeting.findByIdAndDelete(id);\n      if (!deletedMeeting) {\n        return res.status(404).json({ error: \"Meeting not found\" });\n      }\n\n      res.status(204).send();\n      return;\n    } catch (dbError) {\n      console.error(\"MongoDB delete failed:\", dbError);\n      throw dbError;\n    }\n  } catch (error) {\n    console.error(\"Error deleting meeting:\", error);\n    res.status(500).json({ error: \"Failed to delete meeting\" });\n  }\n};\n\n// üîπ NEW ENDPOINT: Get active meeting for employee (by employeeId or followUpId)\nexport const getActiveMeeting: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, followUpId } = req.query;\n\n    if (!employeeId && !followUpId) {\n      return res.status(400).json({\n        error: \"Either employeeId or followUpId is required\"\n      });\n    }\n\n    console.log(\"üîç Searching for active meeting:\", { employeeId, followUpId });\n\n    // Try MongoDB first\n    try {\n      // Build query to find active meetings\n      const query: any = {\n        status: { $in: [\"in-progress\", \"started\"] },\n        $or: [\n          { meetingStatus: { $exists: false } },\n          { meetingStatus: { $ne: \"complete\" } }\n        ]\n      };\n\n      if (followUpId) {\n        // If followUpId is provided, search by it (most specific)\n        query.followUpId = followUpId;\n      } else if (employeeId) {\n        // Otherwise search by employeeId\n        query.employeeId = employeeId;\n      }\n\n      console.log(\"üì• Query:\", JSON.stringify(query, null, 2));\n\n      const activeMeeting = await Meeting.findOne(query)\n        .sort({ startTime: -1 }) // Get the most recent one\n        .lean();\n\n      if (!activeMeeting) {\n        console.log(\"‚ö†Ô∏è No active meeting found with query:\", JSON.stringify(query, null, 2));\n\n        // üîπ DEBUG: Check what meetings exist for this employee\n        let allMeetings: any[] = [];\n        if (employeeId) {\n          allMeetings = await Meeting.find({ employeeId }).lean();\n          console.log(\"üìã All meetings for employee:\", allMeetings.map(m => ({\n            id: m._id,\n            status: m.status,\n            followUpId: m.followUpId,\n            startTime: m.startTime\n          })));\n        }\n\n        // üîπ DEBUG: Check if there are ANY active meetings\n        const anyActiveMeetings = await Meeting.find({\n          status: { $in: [\"in-progress\", \"started\"] },\n          $or: [\n            { meetingStatus: { $exists: false } },\n            { meetingStatus: { $ne: \"complete\" } }\n          ]\n        }).lean();\n        console.log(\"üìã All active meetings in database:\", anyActiveMeetings.map(m => ({\n          id: m._id,\n          employeeId: m.employeeId,\n          followUpId: m.followUpId,\n          status: m.status\n        })));\n\n        return res.status(404).json({\n          error: \"No active meeting found\",\n          employeeId,\n          followUpId,\n          debug: {\n            totalMeetingsForEmployee: allMeetings?.length || 0,\n            totalActiveMeetings: anyActiveMeetings?.length || 0\n          }\n        });\n      }\n\n      const meetingLog = await convertMeetingToMeetingLog(activeMeeting);\n      console.log(\"‚úÖ Active meeting found:\", {\n        id: meetingLog.id,\n        followUpId: meetingLog.followUpId,\n        status: meetingLog.status,\n        client: meetingLog.clientName\n      });\n\n      res.json(meetingLog);\n      return;\n    } catch (dbError) {\n      console.error(\"MongoDB query failed:\", dbError);\n      return res.status(500).json({ error: \"Database query failed\" });\n    }\n  } catch (error) {\n    console.error(\"Error getting active meeting:\", error);\n    res.status(500).json({ error: \"Failed to get active meeting\" });\n  }\n};\n\n// Add this endpoint to clear geocoding cache\nexport const clearGeocodeCache: RequestHandler = async (req, res) => {\n  try {\n    geocodeCache.flushAll();\n    res.json({ success: true, message: \"Geocode cache cleared\" });\n  } catch (error) {\n    console.error(\"Error clearing cache:\", error);\n    res.status(500).json({ error: \"Failed to clear cache\" });\n  }\n};\n\n// Update meeting approval status\nexport const updateMeetingApproval: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { approvalStatus, approvalReason, approvedBy } = req.body;\n\n    // Validate inputs\n    if (!approvalStatus || !['ok', 'not_ok', 'pending'].includes(approvalStatus)) {\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok or pending) is required\" });\n    }\n\n    if (!approvalReason || !approvalReason.trim()) {\n      return res.status(400).json({ error: \"Approval reason is required\" });\n    }\n\n    console.log(`üìù Updating meeting approval ${id}:`, { approvalStatus, approvalReason, approvedBy });\n    console.log(`üìù approvedBy value type:`, typeof approvedBy, `value:`, approvedBy);\n\n    try {\n      const updateData = {\n        approvalStatus,\n        approvalReason: approvalReason.trim(),\n        approvedBy: approvedBy !== undefined ? approvedBy : null\n      };\n\n      console.log(`üìù Update data being sent to MongoDB:`, updateData);\n\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\n        id,\n        { $set: updateData },\n        { new: true, runValidators: true }\n      );\n\n      if (!updatedMeeting) {\n        return res.status(404).json({ error: \"Meeting not found\" });\n      }\n\n      console.log(\"‚úÖ Meeting approval updated:\", updatedMeeting._id);\n      console.log(\"‚úÖ Approved by user ID stored in DB:\", updatedMeeting.approvedBy);\n      console.log(\"‚úÖ Full updated meeting:\", JSON.stringify({\n        id: updatedMeeting._id,\n        approvalStatus: updatedMeeting.approvalStatus,\n        approvalReason: updatedMeeting.approvalReason,\n        approvedBy: updatedMeeting.approvedBy\n      }));\n\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\n      res.json({\n        success: true,\n        meeting: meetingLog,\n        approvalStatus: updatedMeeting.approvalStatus,\n        approvalReason: updatedMeeting.approvalReason,\n        approvedBy: updatedMeeting.approvedBy\n      });\n    } catch (dbError) {\n      console.error(\"MongoDB update failed:\", dbError);\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\n    }\n  } catch (error) {\n    console.error(\"Error updating meeting approval:\", error);\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\n  }\n};\n\n// Update meeting approval by composite details (when meetingId is not available)\nexport const updateMeetingApprovalByDetails: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, date, companyName, meetingInTime, approvalStatus, approvalReason, approvedBy } = req.body;\n\n    // Validate inputs\n    if (!employeeId || !date || !companyName || !meetingInTime) {\n      return res.status(400).json({ error: \"Employee ID, date, company name, and meeting time are required\" });\n    }\n\n    if (!approvalStatus || !['ok', 'not_ok', 'pending'].includes(approvalStatus)) {\n      return res.status(400).json({ error: \"Valid approval status (ok/not_ok or pending) is required\" });\n    }\n\n    if (!approvalReason || !approvalReason.trim()) {\n      return res.status(400).json({ error: \"Approval reason is required\" });\n    }\n\n    console.log(`üìù Updating meeting approval by details:`, {\n      employeeId,\n      date,\n      companyName,\n      meetingInTime,\n      approvalStatus,\n      approvalReason,\n      approvedBy\n    });\n\n    try {\n      // Parse the date and time to create a date range for the query\n      const startOfDayDate = new Date(date);\n      startOfDayDate.setHours(0, 0, 0, 0);\n\n      const endOfDayDate = new Date(date);\n      endOfDayDate.setHours(23, 59, 59, 999);\n\n      // Find the meeting by composite details\n      const meeting = await Meeting.findOne({\n        employeeId: employeeId,\n        clientName: companyName,\n        startTime: {\n          $gte: startOfDayDate.toISOString(),\n          $lte: endOfDayDate.toISOString(),\n        },\n        meetingStatus: { $ne: \"complete\" }\n      }).lean();\n\n      if (!meeting) {\n        console.error(\"‚ùå Meeting not found with details:\", { employeeId, date, companyName });\n        return res.status(404).json({\n          error: \"Meeting not found\",\n          details: { employeeId, date, companyName, meetingInTime }\n        });\n      }\n\n      console.log(`‚úÖ Found meeting by details: ${meeting._id}`);\n      console.log(`üìù approvedBy value type:`, typeof approvedBy, `value:`, approvedBy);\n\n      const updateData = {\n        approvalStatus,\n        approvalReason: approvalReason.trim(),\n        approvedBy: approvedBy !== undefined ? approvedBy : null\n      };\n\n      console.log(`üìù Update data being sent to MongoDB:`, updateData);\n\n      // Update the meeting\n      const updatedMeeting = await Meeting.findByIdAndUpdate(\n        meeting._id,\n        { $set: updateData },\n        { new: true, runValidators: true }\n      );\n\n      if (!updatedMeeting) {\n        return res.status(404).json({ error: \"Failed to update meeting\" });\n      }\n\n      console.log(\"‚úÖ Meeting approval updated by details:\", updatedMeeting._id);\n      console.log(\"‚úÖ Approved by user ID stored in DB:\", updatedMeeting.approvedBy);\n      console.log(\"‚úÖ Full updated meeting:\", JSON.stringify({\n        id: updatedMeeting._id,\n        approvalStatus: updatedMeeting.approvalStatus,\n        approvalReason: updatedMeeting.approvalReason,\n        approvedBy: updatedMeeting.approvedBy\n      }));\n\n      const meetingLog = await convertMeetingToMeetingLog(updatedMeeting);\n      res.json({\n        success: true,\n        meeting: meetingLog,\n        approvalStatus: updatedMeeting.approvalStatus,\n        approvalReason: updatedMeeting.approvalReason,\n        approvedBy: updatedMeeting.approvedBy\n      });\n    } catch (dbError) {\n      console.error(\"MongoDB update failed:\", dbError);\n      res.status(500).json({ error: \"Failed to update meeting approval\" });\n    }\n  } catch (error) {\n    console.error(\"Error updating meeting approval by details:\", error);\n    res.status(500).json({ error: \"Failed to update meeting approval\" });\n  }\n};\n\n// Get today's meetings for duty completion summary\nexport const getTodaysMeetings: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.query;\n\n    if (!employeeId) {\n      return res.status(400).json({ error: \"Employee ID is required\" });\n    }\n\n    console.log(\"üìÖ Fetching today's meetings for employee:\", employeeId);\n\n    // Get today's date range in UTC\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    console.log(\"üìÖ Date range:\", {\n      start: today.toISOString(),\n      end: tomorrow.toISOString()\n    });\n\n    try {\n      // Query for today's meetings\n      const todaysMeetings = await Meeting.find({\n        employeeId: employeeId,\n        startTime: {\n          $gte: today.toISOString(),\n          $lt: tomorrow.toISOString()\n        }\n      })\n      .sort({ startTime: -1 })\n      .lean();\n\n      console.log(`üìä Found ${todaysMeetings.length} meetings for today`);\n\n      // Convert to meeting logs with proper addresses\n      const meetingLogs = await Promise.all(\n        todaysMeetings.map(meeting => convertMeetingToMeetingLog(meeting))\n      );\n\n      // Calculate total duty hours for completed meetings\n      const completedMeetings = meetingLogs.filter(m => m.status === 'completed' && m.endTime);\n      const totalDutyHours = completedMeetings.reduce((total, meeting) => {\n        if (meeting.startTime && meeting.endTime) {\n          const duration = new Date(meeting.endTime).getTime() - new Date(meeting.startTime).getTime();\n          const hours = duration / (1000 * 60 * 60);\n          return total + hours;\n        }\n        return total;\n      }, 0);\n\n      // Determine attendance status based on total hours\n      let attendanceStatus = \"Pending Verification\";\n      let badgeClass = \"bg-gray-500\";\n      \n      if (totalDutyHours >= 8) {\n        attendanceStatus = \"Full Day (Pending Verification)\";\n        badgeClass = \"bg-green-500\";\n      } else if (totalDutyHours >= 4) {\n        attendanceStatus = \"Half Day (Pending Verification)\";\n        badgeClass = \"bg-yellow-500\";\n      } else if (totalDutyHours > 0) {\n        attendanceStatus = \"Short Duration (Pending Verification)\";\n        badgeClass = \"bg-blue-500\";\n      }\n\n      const response = {\n        meetings: meetingLogs,\n        summary: {\n          totalMeetings: meetingLogs.length,\n          completedMeetings: completedMeetings.length,\n          totalDutyHours: Math.round(totalDutyHours * 10) / 10, // Round to 1 decimal\n          attendanceStatus,\n          badgeClass\n        }\n      };\n\n      console.log(\"‚úÖ Today's meetings summary:\", response.summary);\n      res.json(response);\n    } catch (dbError) {\n      console.error(\"MongoDB query failed:\", dbError);\n      res.status(500).json({ error: \"Failed to fetch today's meetings\" });\n    }\n  } catch (error) {\n    console.error(\"Error fetching today's meetings:\", error);\n    res.status(500).json({ error: \"Failed to fetch today's meetings\" });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport axios from \"axios\";\nimport {\n  TrackingSession as TrackingSessionType,\n  TrackingSessionResponse,\n  LocationData,\n  MeetingDetails,\n  MeetingHistoryResponse,\n} from \"@shared/api\";\nimport { MeetingHistory, TrackingSession as TrackingSessionModel } from \"../models\";\nimport type { IMeetingHistory, ITrackingSession } from \"../models\";\n\n// Rate limiting for Nominatim API (max 1 request per second)\nlet lastGeocodingTime = 0;\nconst GEOCODING_DELAY = 1000; // 1 second\nconst geocodeCache = new Map<string, { address: string; expires: number }>();\nconst GEOCACHE_TTL = 3600000; // 1 hour\n\nasync function reverseGeocode(lat: number, lng: number): Promise<string> {\n  if (lat === 0 && lng === 0) return \"Location not available\";\n  \n  const cacheKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;\n  const cached = geocodeCache.get(cacheKey);\n  if (cached && cached.expires > Date.now()) {\n    console.log(`‚úÖ Using cached address for ${lat}, ${lng}: ${cached.address}`);\n    return cached.address;\n  }\n\n  try {\n    // Rate limiting: wait if needed\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastGeocodingTime;\n    if (timeSinceLastRequest < GEOCODING_DELAY) {\n      const waitTime = GEOCODING_DELAY - timeSinceLastRequest;\n      console.log(`‚è≥ Rate limiting: waiting ${waitTime}ms before geocoding`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    lastGeocodingTime = Date.now();\n\n    console.log(`üó∫Ô∏è Fetching address for coordinates: ${lat}, ${lng}`);\n    const response = await axios.get('https://nominatim.openstreetmap.org/reverse', {\n      params: {\n        format: 'json',\n        lat,\n        lon: lng,\n        zoom: 18,\n        addressdetails: 1\n      },\n      headers: {\n        'User-Agent': 'EmployeeTrackingApp/1.0'\n      },\n      timeout: 5000\n    });\n\n    const address = response.data?.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n    console.log(`‚úÖ Address resolved: ${address}`);\n    \n    geocodeCache.set(cacheKey, {\n      address,\n      expires: Date.now() + GEOCACHE_TTL\n    });\n    \n    return address;\n  } catch (error) {\n    console.error(`‚ö†Ô∏è Reverse geocoding failed for ${lat}, ${lng}:`, error.message);\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  }\n}\n\n// In-memory storage for demo purposes\nlet trackingSessions: TrackingSessionType[] = [];\nlet sessionIdCounter = 1;\n\n// In-memory storage for meeting history with customer details\nlet meetingHistory: Array<{\n  id: string;\n  sessionId: string;\n  employeeId: string;\n  meetingDetails: MeetingDetails;\n  timestamp: string;\n  leadId?: string;\n  leadInfo?: any;\n}> = [];\nlet historyIdCounter = 1;\n\nexport const getTrackingSessions: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, status, startDate, endDate, limit = 50 } = req.query;\n\n    // Build MongoDB query\n    const query: any = {};\n\n    if (employeeId) {\n      query.employeeId = employeeId;\n    }\n\n    if (status) {\n      query.status = status;\n    }\n\n    if (startDate || endDate) {\n      query.startTime = {};\n      if (startDate) {\n        query.startTime.$gte = new Date(startDate as string).toISOString();\n      }\n      if (endDate) {\n        query.startTime.$lte = new Date(endDate as string).toISOString();\n      }\n    }\n\n    console.log(\"Fetching tracking sessions with query:\", query);\n\n    // Try to fetch from MongoDB first\n    try {\n      const mongoSessions = await TrackingSessionModel.find(query)\n        .sort({ startTime: -1 })\n        .limit(parseInt(limit as string))\n        .lean();\n\n      const response: TrackingSessionResponse = {\n        sessions: mongoSessions as any as TrackingSessionType[],\n        total: mongoSessions.length,\n      };\n\n      console.log(`Found ${mongoSessions.length} tracking sessions in MongoDB`);\n      res.json(response);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    let filteredSessions = trackingSessions;\n\n    if (employeeId) {\n      filteredSessions = filteredSessions.filter(\n        (session) => session.employeeId === employeeId,\n      );\n    }\n\n    if (status) {\n      filteredSessions = filteredSessions.filter(\n        (session) => session.status === status,\n      );\n    }\n\n    if (startDate) {\n      filteredSessions = filteredSessions.filter(\n        (session) =>\n          new Date(session.startTime) >= new Date(startDate as string),\n      );\n    }\n\n    if (endDate) {\n      filteredSessions = filteredSessions.filter(\n        (session) => new Date(session.startTime) <= new Date(endDate as string),\n      );\n    }\n\n    filteredSessions.sort(\n      (a, b) =>\n        new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\n    );\n\n    if (limit) {\n      filteredSessions = filteredSessions.slice(0, parseInt(limit as string));\n    }\n\n    const response: TrackingSessionResponse = {\n      sessions: filteredSessions,\n      total: filteredSessions.length,\n    };\n\n    console.log(`Found ${filteredSessions.length} tracking sessions in memory`);\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error fetching tracking sessions:\", error);\n    res.status(500).json({ error: \"Failed to fetch tracking sessions\" });\n  }\n};\n\nexport const createTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id, employeeId, startTime, startLocation, route, totalDistance, status } = req.body;\n\n    if (!employeeId || !startLocation) {\n      return res.status(400).json({\n        error: \"Employee ID and start location are required\",\n      });\n    }\n\n    console.log(\"üìç Creating tracking session:\", { id, employeeId, startTime });\n\n    // üîπ Resolve start location address if not already resolved\n    let resolvedStartLocation = { ...startLocation };\n    if (startLocation.lat && startLocation.lng) {\n      try {\n        console.log(\"üó∫Ô∏è Resolving start location address...\");\n        const address = await reverseGeocode(startLocation.lat, startLocation.lng);\n        resolvedStartLocation.address = address;\n        console.log(\"‚úÖ Start location address resolved:\", address);\n      } catch (error) {\n        console.warn(\"‚ö†Ô∏è Failed to resolve start location address:\", error);\n        // Keep the address as-is\n      }\n    }\n\n    const sessionData = {\n      id: id || `session_${String(sessionIdCounter++).padStart(3, \"0\")}`,\n      employeeId,\n      startTime: startTime || new Date().toISOString(),\n      startLocation: {\n        ...resolvedStartLocation,\n        timestamp: resolvedStartLocation.timestamp || new Date().toISOString(),\n      },\n      route: route || [resolvedStartLocation],\n      totalDistance: totalDistance || 0,\n      status: status || \"active\" as const,\n    };\n\n    // Try to save to MongoDB first\n    try {\n      const newSession = new TrackingSessionModel(sessionData);\n      const savedSession = await newSession.save();\n\n      console.log(\"Tracking session saved to MongoDB:\", savedSession.id);\n      res.status(201).json(savedSession);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const newSession = sessionData;\n    trackingSessions.push(newSession);\n\n    console.log(\"Tracking session saved to memory:\", newSession.id);\n    res.status(201).json(newSession);\n  } catch (error) {\n    console.error(\"Error creating tracking session:\", error);\n    res.status(500).json({ error: \"Failed to create tracking session\" });\n  }\n};\n\nexport const updateTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n\n    console.log(\"üìç Updating tracking session:\", id);\n    console.log(\"üìç Updates:\", JSON.stringify(updates, null, 2));\n\n    // If ending the session, set end time and calculate duration\n    if (updates.status === \"completed\" && !updates.endTime) {\n      updates.endTime = new Date().toISOString();\n      // Duration calculation will be done in the database or after fetch\n    }\n\n    // üîπ CRITICAL FIX: Resolve end location address if coordinates provided\n    if (updates.endLocation && updates.endLocation.lat && updates.endLocation.lng) {\n      try {\n        console.log(\"üó∫Ô∏è Resolving end location address...\");\n        const address = await reverseGeocode(updates.endLocation.lat, updates.endLocation.lng);\n        updates.endLocation.address = address;\n        console.log(\"‚úÖ End location address resolved:\", address);\n      } catch (error) {\n        console.warn(\"‚ö†Ô∏è Failed to resolve end location address:\", error);\n        // Keep the address as-is (might be coordinates)\n      }\n    }\n\n    // Try to update in MongoDB first\n    try {\n      const updatedSession = await TrackingSessionModel.findOneAndUpdate(\n        { id },\n        { $set: updates },\n        { new: true, runValidators: true }\n      );\n\n      if (!updatedSession) {\n        console.warn(\"‚ö†Ô∏è Tracking session not found in database:\", id);\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\n      }\n\n      // Calculate duration if completing session\n      if (updates.status === \"completed\" && updatedSession.startTime && updatedSession.endTime) {\n        const startTime = new Date(updatedSession.startTime).getTime();\n        const endTime = new Date(updatedSession.endTime).getTime();\n        const duration = Math.floor((endTime - startTime) / 1000);\n\n        await TrackingSessionModel.findOneAndUpdate(\n          { id },\n          { $set: { duration } },\n          { new: true }\n        );\n        updatedSession.duration = duration;\n        console.log(\"‚úÖ Duration calculated:\", duration, \"seconds\");\n      }\n\n      console.log(\"‚úÖ Tracking session updated in MongoDB:\", updatedSession.id);\n      if (updatedSession.endLocation) {\n        console.log(\"‚úÖ End location saved:\", updatedSession.endLocation);\n      }\n      res.json(updatedSession);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    // Calculate duration for in-memory sessions\n    if (updates.status === \"completed\" && !trackingSessions[sessionIndex].endTime) {\n      const startTime = new Date(trackingSessions[sessionIndex].startTime).getTime();\n      const endTime = new Date(updates.endTime).getTime();\n      updates.duration = Math.floor((endTime - startTime) / 1000);\n    }\n\n    trackingSessions[sessionIndex] = {\n      ...trackingSessions[sessionIndex],\n      ...updates,\n    };\n\n    console.log(\"Tracking session updated in memory:\", trackingSessions[sessionIndex].id);\n    res.json(trackingSessions[sessionIndex]);\n  } catch (error) {\n    console.error(\"Error updating tracking session:\", error);\n    res.status(500).json({ error: \"Failed to update tracking session\" });\n  }\n};\n\nexport const addLocationToRoute: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { location } = req.body;\n\n    if (!location) {\n      return res.status(400).json({ error: \"Location is required\" });\n    }\n\n    // Add timestamp to location if not provided\n    const locationWithTimestamp: LocationData = {\n      ...location,\n      timestamp: location.timestamp || new Date().toISOString(),\n    };\n\n    // Try to update in MongoDB first\n    try {\n      const session = await TrackingSessionModel.findOne({ id });\n      if (!session) {\n        return res.status(404).json({ error: \"Tracking session not found in database\" });\n      }\n\n      // Add to route\n      session.route.push(locationWithTimestamp);\n\n      // Calculate distance if this isn't the first location\n      if (session.route.length > 1) {\n        const prevLocation = session.route[session.route.length - 2];\n        const distance = calculateDistance(\n          prevLocation.lat,\n          prevLocation.lng,\n          location.lat,\n          location.lng,\n        );\n        session.totalDistance += distance;\n      }\n\n      await session.save();\n\n      console.log(\"Location added to route in MongoDB:\", session.id);\n      res.json(session);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB update failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    const session = trackingSessions[sessionIndex];\n\n    // Add to route\n    session.route.push(locationWithTimestamp);\n\n    // Calculate distance if this isn't the first location\n    if (session.route.length > 1) {\n      const prevLocation = session.route[session.route.length - 2];\n      const distance = calculateDistance(\n        prevLocation.lat,\n        prevLocation.lng,\n        location.lat,\n        location.lng,\n      );\n      session.totalDistance += distance;\n    }\n\n    console.log(\"Location added to route in memory:\", session.id);\n    res.json(session);\n  } catch (error) {\n    console.error(\"Error adding location to route:\", error);\n    res.status(500).json({ error: \"Failed to add location to route\" });\n  }\n};\n\nexport const getTrackingSession: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Try to fetch from MongoDB first\n    try {\n      const session = await TrackingSessionModel.findOne({ id });\n      if (session) {\n        console.log(\"Tracking session found in MongoDB:\", session.id);\n        res.json(session);\n        return;\n      }\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const session = trackingSessions.find((session) => session.id === id);\n\n    if (!session) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    console.log(\"Tracking session found in memory:\", session.id);\n    res.json(session);\n  } catch (error) {\n    console.error(\"Error fetching tracking session:\", error);\n    res.status(500).json({ error: \"Failed to fetch tracking session\" });\n  }\n};\n\nexport const deleteTrackingSession: RequestHandler = (req, res) => {\n  try {\n    const { id } = req.params;\n    const sessionIndex = trackingSessions.findIndex(\n      (session) => session.id === id,\n    );\n\n    if (sessionIndex === -1) {\n      return res.status(404).json({ error: \"Tracking session not found\" });\n    }\n\n    trackingSessions.splice(sessionIndex, 1);\n    res.status(204).send();\n  } catch (error) {\n    console.error(\"Error deleting tracking session:\", error);\n    res.status(500).json({ error: \"Failed to delete tracking session\" });\n  }\n};\n\n// Meeting History endpoints\nexport const getMeetingHistory: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, page = 1, limit = 50, dateRange, startDate, endDate, leadId } = req.query;\n\n    // Build MongoDB query\n    const query: any = {};\n    if (employeeId) {\n      query.employeeId = employeeId;\n    }\n    if (leadId) {\n      query.leadId = leadId;\n    }\n\n    // Add date filtering\n    if (dateRange || startDate || endDate) {\n      const now = new Date();\n      let start: Date, end: Date;\n\n      if (dateRange && dateRange !== \"custom\") {\n        switch (dateRange) {\n          case \"all\":\n            // Don't set start/end to include all meetings\n            break;\n          case \"today\":\n            start = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\n            break;\n          case \"yesterday\":\n            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n            start = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());\n            end = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);\n            break;\n          case \"week\":\n            const startOfWeek = new Date(now.getTime() - (now.getDay() || 7) * 24 * 60 * 60 * 1000);\n            start = new Date(startOfWeek.getFullYear(), startOfWeek.getMonth(), startOfWeek.getDate());\n            end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);\n            break;\n          case \"month\":\n            start = new Date(now.getFullYear(), now.getMonth(), 1);\n            end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);\n            break;\n        }\n      } else if (startDate && endDate) {\n        start = new Date(startDate as string);\n        end = new Date(endDate as string);\n        end.setHours(23, 59, 59, 999);\n      }\n\n      if (start && end) {\n        query.timestamp = {\n          $gte: start.toISOString(),\n          $lte: end.toISOString()\n        };\n        console.log(`Meeting history date filter: ${start.toISOString()} to ${end.toISOString()}`);\n      }\n    }\n\n    console.log(\"=== MEETING HISTORY REQUEST ===\");\n    console.log(\"Meeting history params:\", { employeeId, leadId, dateRange, startDate, endDate });\n    console.log(\"Built MongoDB query:\", JSON.stringify(query, null, 2));\n\n    // Debug: Check what data exists in the database\n    if (!employeeId && dateRange === \"all\") {\n      try {\n        const totalMeetings = await MeetingHistory.countDocuments();\n        const uniqueEmployeeIds = await MeetingHistory.distinct('employeeId');\n        const uniqueLeadIds = await MeetingHistory.distinct('leadId');\n        console.log(\"=== DATABASE DEBUG INFO ===\");\n        console.log(`Total meetings in database: ${totalMeetings}`);\n        console.log(`Unique employee IDs (${uniqueEmployeeIds.length}):`, uniqueEmployeeIds);\n        console.log(`Unique lead IDs (${uniqueLeadIds.filter(id => id).length}):`, uniqueLeadIds.filter(id => id));\n\n        // Check for the specific lead IDs mentioned by user\n        const specificLeads = await MeetingHistory.find({\n          leadId: { $in: ['JBDSL-0044', 'JBDSL-0001'] }\n        }).lean();\n        console.log(`Meetings with JBDSL-0044 or JBDSL-0001: ${specificLeads.length}`);\n        specificLeads.forEach((meeting) => {\n          console.log(`  - Lead: ${meeting.leadId}, Employee: ${meeting.employeeId}, Customer: ${meeting.meetingDetails?.customerName || meeting.meetingDetails?.customers?.[0]?.customerName}`);\n        });\n      } catch (debugError) {\n        console.log(\"Debug info failed:\", debugError.message);\n      }\n    }\n\n    // Try to fetch from MongoDB first\n    try {\n      const pageNum = parseInt(page as string);\n      const limitNum = parseInt(limit as string);\n      const skip = (pageNum - 1) * limitNum;\n\n      const mongoHistory = await MeetingHistory.find(query)\n        .sort({ timestamp: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await MeetingHistory.countDocuments(query);\n\n      const response = {\n        meetings: mongoHistory,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${mongoHistory.length} meeting history entries in MongoDB for employeeId: ${employeeId}`);\n      if (mongoHistory.length > 0) {\n        console.log(\"Sample meeting data:\", {\n          firstMeeting: {\n            employeeId: mongoHistory[0].employeeId,\n            leadId: mongoHistory[0].leadId,\n            customerName: mongoHistory[0].meetingDetails?.customerName,\n            timestamp: mongoHistory[0].timestamp\n          }\n        });\n        // Show all unique employee IDs in the results\n        const uniqueEmployeeIds = [...new Set(mongoHistory.map(m => m.employeeId))];\n        console.log(\"All employee IDs in results:\", uniqueEmployeeIds);\n      }\n      res.json(response);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    let filteredHistory = meetingHistory;\n\n    if (employeeId) {\n      filteredHistory = filteredHistory.filter(\n        (history) => history.employeeId === employeeId,\n      );\n    }\n\n    if (leadId) {\n      filteredHistory = filteredHistory.filter(\n        (history) => history.leadId === leadId,\n      );\n    }\n\n    filteredHistory.sort(\n      (a, b) =>\n        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\n    );\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const startIndex = (pageNum - 1) * limitNum;\n    const endIndex = startIndex + limitNum;\n    const paginatedHistory = filteredHistory.slice(startIndex, endIndex);\n\n    const response = {\n      meetings: paginatedHistory,\n      total: filteredHistory.length,\n      page: pageNum,\n      totalPages: Math.ceil(filteredHistory.length / limitNum),\n    };\n\n    console.log(`Found ${paginatedHistory.length} meeting history entries in memory`);\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error fetching meeting history:\", error);\n    res.status(500).json({ error: \"Failed to fetch meeting history\" });\n  }\n};\n\nexport const addMeetingToHistory: RequestHandler = async (req, res) => {\n  try {\n    const { sessionId, employeeId, meetingDetails, leadId, leadInfo } = req.body;\n\n    console.log(\"Adding meeting to history:\", {\n      sessionId,\n      employeeId,\n      meetingDetails,\n      leadId,\n      leadInfo,\n    });\n\n    if (!sessionId || !employeeId || !meetingDetails) {\n      return res.status(400).json({\n        error: \"Session ID, employee ID, and meeting details are required\",\n      });\n    }\n\n    // Validate that discussion is provided (mandatory field)\n    if (!meetingDetails.discussion || !meetingDetails.discussion.trim()) {\n      return res.status(400).json({\n        error: \"Discussion details are required\",\n      });\n    }\n\n    // Validate customers array or legacy customer fields\n    if (!meetingDetails.customers || meetingDetails.customers.length === 0) {\n      // Check if legacy fields are provided for backward compatibility\n      if (!meetingDetails.customerName || !meetingDetails.customerEmployeeName) {\n        return res.status(400).json({\n          error: \"At least one customer contact is required\",\n        });\n      }\n\n      // Convert legacy fields to new format\n      meetingDetails.customers = [{\n        customerName: meetingDetails.customerName,\n        customerEmployeeName: meetingDetails.customerEmployeeName,\n        customerEmail: meetingDetails.customerEmail || \"\",\n        customerMobile: meetingDetails.customerMobile || \"\",\n        customerDesignation: meetingDetails.customerDesignation || \"\",\n        customerDepartment: meetingDetails.customerDepartment || \"\",\n      }];\n    }\n\n    const historyData = {\n      sessionId,\n      employeeId,\n      meetingDetails,\n      timestamp: new Date().toISOString(),\n      leadId: leadId || undefined,\n      leadInfo: leadInfo || undefined,\n    };\n\n    // Try to save to MongoDB first\n    try {\n      const newHistoryEntry = new MeetingHistory(historyData);\n      const savedHistory = await newHistoryEntry.save();\n\n      console.log(\"Meeting history saved to MongoDB:\", savedHistory._id);\n\n      // Format the response to match the expected structure\n      const formattedResponse = {\n        id: savedHistory._id.toString(),\n        sessionId: savedHistory.sessionId,\n        employeeId: savedHistory.employeeId,\n        meetingDetails: savedHistory.meetingDetails,\n        timestamp: savedHistory.timestamp,\n        leadId: savedHistory.leadId,\n        leadInfo: savedHistory.leadInfo,\n        _id: savedHistory._id,\n        createdAt: savedHistory.createdAt,\n        updatedAt: savedHistory.updatedAt\n      };\n\n      res.status(201).json(formattedResponse);\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB save failed, falling back to in-memory storage:\", dbError);\n      // Log the exact error for debugging\n      console.error(\"MongoDB error details:\", {\n        message: dbError.message,\n        stack: dbError.stack,\n        data: historyData\n      });\n    }\n\n    // Fallback to in-memory storage\n    const newHistoryEntry = {\n      id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\n      ...historyData,\n    };\n\n    meetingHistory.push(newHistoryEntry);\n\n    console.log(\"Meeting history entry added to memory:\", newHistoryEntry);\n    console.log(\"Total meeting history entries:\", meetingHistory.length);\n\n    res.status(201).json(newHistoryEntry);\n  } catch (error) {\n    console.error(\"Error adding meeting to history:\", error);\n    res.status(500).json({ error: \"Failed to add meeting to history\" });\n  }\n};\n\n// Save incomplete meeting remarks (called on logout with pending meetings)\nexport const saveIncompleteMeetingRemark: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId, reason, pendingMeetings } = req.body;\n\n    if (!employeeId || !pendingMeetings || pendingMeetings.length === 0) {\n      return res.status(400).json({\n        error: \"Employee ID and at least one pending meeting are required\",\n      });\n    }\n\n    console.log(\"=== SAVING INCOMPLETE MEETING REMARKS ===\");\n    console.log(\"Employee ID:\", employeeId, \"Type:\", typeof employeeId);\n    console.log(\"General reason:\", reason);\n    console.log(\"Pending meetings count:\", pendingMeetings.length);\n\n    // Save a history entry for each incomplete meeting with its individual reason\n    const savedEntries = await Promise.all(\n      pendingMeetings.map(async (meeting: any, idx: number) => {\n        // Use individual meeting reason if provided, otherwise fall back to general reason\n        const meetingReason = meeting.incompleteReason || reason || \"Meeting not completed\";\n        \n        const meetingDetails = {\n          discussion: meetingReason,\n          incomplete: true,\n          incompleteReason: meetingReason,\n          customers: [\n            {\n              customerName: meeting.customerName || \"\",\n              customerEmployeeName: meeting.customerName || \"\",\n              customerEmail: meeting.customerEmail || \"\",\n              customerMobile: meeting.customerMobile || \"\",\n              customerDesignation: meeting.customerDesignation || \"\",\n              customerDepartment: \"\",\n            },\n          ],\n        };\n\n        const historyData = {\n          sessionId: `logout_incomplete_${Date.now()}_${idx}`,\n          employeeId: String(employeeId), // Ensure it's a string\n          meetingDetails,\n          timestamp: new Date().toISOString(),\n          leadId: meeting.leadId,\n          leadInfo: {\n            id: meeting.leadId,\n            companyName: meeting.companyName,\n          },\n        };\n\n        console.log(`Processing meeting ${idx + 1}:`, {\n          employeeId: historyData.employeeId,\n          companyName: meeting.companyName,\n          customerName: meeting.customerName,\n          leadId: meeting.leadId,\n          reason: meetingReason,\n        });\n\n        // Try to save to MongoDB first\n        try {\n          const newEntry = new MeetingHistory(historyData);\n          const saved = await newEntry.save();\n          console.log(\"‚úì Incomplete meeting remark saved to MongoDB:\", saved._id);\n          console.log(\"  - Company:\", meeting.companyName);\n          console.log(\"  - Saved employeeId:\", saved.employeeId);\n          console.log(\"  - Saved incomplete flag:\", saved.meetingDetails?.incomplete);\n          console.log(\"  - Reason:\", meetingReason);\n          return {\n            success: true,\n            meetingId: meeting._id,\n            historyId: saved._id,\n            companyName: meeting.companyName,\n            reason: meetingReason,\n          };\n        } catch (dbError) {\n          console.warn(\"MongoDB save failed for incomplete meeting remark:\", dbError);\n          // Fallback: save to in-memory\n          meetingHistory.push({\n            id: `history_${String(historyIdCounter++).padStart(3, \"0\")}`,\n            ...historyData,\n          });\n          console.log(\"‚úì Incomplete meeting remark saved to in-memory storage\");\n          return { \n            success: true, \n            meetingId: meeting._id,\n            companyName: meeting.companyName,\n            reason: meetingReason,\n          };\n        }\n      }),\n    );\n\n    console.log(\"=== SAVED INCOMPLETE MEETING REMARKS ===\");\n    console.log(\"Total entries saved:\", savedEntries.length);\n    savedEntries.forEach((entry, idx) => {\n      console.log(`  ${idx + 1}. ${entry.companyName}: ${entry.reason}`);\n    });\n\n    res.status(201).json({\n      success: true,\n      reason,\n      meetingsProcessed: savedEntries.length,\n      entries: savedEntries,\n    });\n  } catch (error) {\n    console.error(\"Error saving incomplete meeting remarks:\", error);\n    res.status(500).json({ error: \"Failed to save incomplete meeting remarks\" });\n  }\n};\n\n\nexport const getIncompleteMeetingRemark: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.query;\n\n    if (!employeeId) {\n      return res.status(400).json({\n        error: \"Employee ID is required\",\n      });\n    }\n\n    console.log(\"Fetching incomplete meeting remarks for employee:\", employeeId);\n    console.log(\"Query filter - employeeId type:\", typeof employeeId, \"value:\", employeeId);\n\n    // Try to fetch from MongoDB first\n    try {\n      // Build query - ensure employeeId is a string for comparison\n      const query = {\n        employeeId: String(employeeId),\n        \"meetingDetails.incomplete\": true,\n      };\n      \n      console.log(\"MongoDB query:\", JSON.stringify(query, null, 2));\n\n      const incompleteMeetings = await MeetingHistory.find(query).lean();\n\n      console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in MongoDB`);\n      \n      // Debug: Show all incomplete meetings regardless of employeeId\n      const allIncomplete = await MeetingHistory.find({\n        \"meetingDetails.incomplete\": true,\n      }).lean();\n      console.log(`Total incomplete meetings in DB (all employees): ${allIncomplete.length}`);\n      \n      res.json({ meetings: incompleteMeetings });\n      return;\n    } catch (dbError) {\n      console.warn(\"MongoDB query failed, falling back to in-memory storage:\", dbError);\n    }\n\n    // Fallback to in-memory storage\n    const incompleteMeetings = meetingHistory.filter(\n      (history) =>\n        String(history.employeeId) === String(employeeId) &&\n        history.meetingDetails.incomplete,\n    );\n\n    console.log(`Found ${incompleteMeetings.length} incomplete meeting remarks in memory`);\n    res.json({ meetings: incompleteMeetings });\n  } catch (error) {\n    console.error(\"Error fetching incomplete meeting remarks:\", error);\n    res.status(500).json({ error: \"Failed to fetch incomplete meeting remarks\" });\n  }\n};\n\n// Helper function to calculate distance between two points using Haversine formula\nfunction calculateDistance(\n  lat1: number,\n  lng1: number,\n  lat2: number,\n  lng2: number,\n): number {\n  const R = 6371e3; // Earth's radius in meters\n  const œÜ1 = (lat1 * Math.PI) / 180;\n  const œÜ2 = (lat2 * Math.PI) / 180;\n  const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;\n  const ŒîŒª = ((lng1 - lng2) * Math.PI) / 180;\n\n  const a =\n    Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +\n    Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return R * c; // Distance in meters\n}\n","// services/cache.service.js\r\nimport NodeCache from 'node-cache';\r\n\r\nclass CacheService {\r\n  constructor() {\r\n    this.cache = new NodeCache({ \r\n      stdTTL: 300, // 5 minutes default TTL\r\n      checkperiod: 60 \r\n    });\r\n    this.externalApiUrl = \"https://jbdspower.in/LeafNetServer/api/user\";\r\n  }\r\n\r\n  get(key) {\r\n    return this.cache.get(key);\r\n  }\r\n\r\n  set(key, value, ttl = 300) {\r\n    return this.cache.set(key, value, ttl);\r\n  }\r\n\r\n  del(keys) {\r\n    return this.cache.del(keys);\r\n  }\r\n\r\n  flush() {\r\n    return this.cache.flushAll();\r\n  }\r\n\r\n  // External API fetch function\r\n  async fetchExternalUsers() {\r\n    try {\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), 10000);\r\n\r\n      const response = await fetch(this.externalApiUrl, {\r\n        signal: controller.signal,\r\n        headers: {\r\n          Accept: \"application/json\",\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const users = await response.json();\r\n      console.log(`External API: ${users.length} users fetched`);\r\n      return users;\r\n    } catch (error) {\r\n      console.error(\"Error fetching external users:\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Cache external users for 10 minutes\r\n  async getExternalUsers() {\r\n    const cacheKey = 'external_users';\r\n    let users = this.get(cacheKey);\r\n    \r\n    if (!users) {\r\n      console.log('Cache miss: fetching external users');\r\n      users = await this.fetchExternalUsers();\r\n      this.set(cacheKey, users, 600); // 10 minutes\r\n    } else {\r\n      console.log('Cache hit: using cached external users');\r\n    }\r\n    \r\n    return users;\r\n  }\r\n}\r\n\r\nexport const cacheService = new CacheService();","import { RequestHandler } from \"express\";\r\nimport {\r\n  format,\r\n  startOfDay,\r\n  endOfDay,\r\n  subDays,\r\n  startOfWeek,\r\n  endOfWeek,\r\n  startOfMonth,\r\n  endOfMonth,\r\n  isToday,\r\n  parseISO,\r\n} from \"date-fns\";\r\n// We'll create our own functions here since the employees module doesn't export what we need\r\nimport { ExternalUser, Employee } from \"@shared/api\";\r\nimport { Meeting, Attendance, TrackingSession } from \"../models/index.js\";\r\nimport { cacheService } from \"../services/cache.service.js\";\r\n\r\n// Replicate the external API fetch function\r\nconst EXTERNAL_API_URL = \"https://jbdspower.in/LeafNetServer/api/user\";\r\n\r\nasync function fetchExternalUsers(): Promise<ExternalUser[]> {\r\n  try {\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 30000);\r\n\r\n    const response = await fetch(EXTERNAL_API_URL, {\r\n      signal: controller.signal,\r\n      headers: {\r\n        Accept: \"application/json\",\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    });\r\n\r\n    clearTimeout(timeoutId);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    const users: ExternalUser[] = await response.json();\r\n    console.log(\r\n      `External API response: { count: ${users.length}, sample: ${JSON.stringify(users[0] || {}, null, 2)} }`,\r\n    );\r\n\r\n    return users;\r\n  } catch (error) {\r\n    console.error(\"Error fetching external users:\", error);\r\n    if (error.name === \"AbortError\") {\r\n      console.error(\"External API request timed out after 30 seconds\");\r\n    } else if (error.message.includes(\"fetch\")) {\r\n      console.error(\"Network error connecting to external API\");\r\n    }\r\n    return [];\r\n  }\r\n}\r\n\r\n// Replicate the mapping function\r\ninterface EmployeeStatus {\r\n  status: \"active\" | \"inactive\" | \"meeting\";\r\n  location: {\r\n    lat: number;\r\n    lng: number;\r\n    address: string;\r\n    timestamp: string;\r\n  };\r\n  lastUpdate: string;\r\n  currentTask?: string;\r\n}\r\n\r\nlet employeeStatuses: Record<string, EmployeeStatus> = {};\r\n\r\nfunction getRealisticIndianLocation(index: number) {\r\n  const locations = [\r\n    { lat: 28.6139, lng: 77.209, address: \"New Delhi, India\" },\r\n    { lat: 19.076, lng: 72.8777, address: \"Mumbai, Maharashtra\" },\r\n    { lat: 12.9716, lng: 77.5946, address: \"Bangalore, Karnataka\" },\r\n    { lat: 13.0827, lng: 80.2707, address: \"Chennai, Tamil Nadu\" },\r\n    { lat: 22.5726, lng: 88.3639, address: \"Kolkata, West Bengal\" },\r\n    { lat: 26.9124, lng: 75.7873, address: \"Jaipur, Rajasthan\" },\r\n    { lat: 21.1458, lng: 79.0882, address: \"Nagpur, Maharashtra\" },\r\n    { lat: 23.0225, lng: 72.5714, address: \"Ahmedabad, Gujarat\" },\r\n    { lat: 17.385, lng: 78.4867, address: \"Hyderabad, Telangana\" },\r\n    { lat: 18.5204, lng: 73.8567, address: \"Pune, Maharashtra\" },\r\n  ];\r\n  return locations[index % locations.length];\r\n}\r\n\r\nfunction mapExternalUserToEmployee(\r\n  user: ExternalUser,\r\n  index: number,\r\n): Employee {\r\n  const userId = user._id;\r\n\r\n  if (!employeeStatuses[userId]) {\r\n    const realisticLocation = getRealisticIndianLocation(index);\r\n    employeeStatuses[userId] = {\r\n      status: index === 1 ? \"meeting\" : index === 3 ? \"inactive\" : \"active\",\r\n      location: {\r\n        ...realisticLocation,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n      lastUpdate: `${Math.floor(Math.random() * 15) + 1} minutes ago`,\r\n      currentTask:\r\n        index === 0\r\n          ? \"Client meeting\"\r\n          : index === 1\r\n            ? \"Equipment installation\"\r\n            : undefined,\r\n    };\r\n  }\r\n\r\n  const status = employeeStatuses[userId];\r\n\r\n  return {\r\n    id: userId,\r\n    name: user.name,\r\n    email: user.email,\r\n    phone: user.mobileNumber,\r\n    status: status.status,\r\n    location: status.location,\r\n    lastUpdate: status.lastUpdate,\r\n    currentTask: status.currentTask,\r\n    deviceId: `device_${userId.slice(-6)}`,\r\n    designation: user.designation,\r\n    department: user.department,\r\n    companyName: user.companyName[0]?.companyName,\r\n    reportTo: user.report?.name,\r\n  };\r\n}\r\n\r\n// Function to get date range based on filter\r\nfunction getDateRange(dateRange: string, startDate?: string, endDate?: string) {\r\n  const now = new Date();\r\n\r\n  switch (dateRange) {\r\n    case \"all\":\r\n      // Return a very wide date range to include all meetings\r\n      return {\r\n        start: new Date(\"2020-01-01\"), // Far past date\r\n        end: new Date(\"2030-12-31\"), // Far future date\r\n      };\r\n    case \"today\":\r\n      return {\r\n        start: startOfDay(now),\r\n        end: endOfDay(now),\r\n      };\r\n    case \"yesterday\":\r\n      const yesterday = subDays(now, 1);\r\n      return {\r\n        start: startOfDay(yesterday),\r\n        end: endOfDay(yesterday),\r\n      };\r\n    case \"week\":\r\n      return {\r\n        start: startOfWeek(now, { weekStartsOn: 1 }), // Monday\r\n        end: endOfWeek(now, { weekStartsOn: 1 }),\r\n      };\r\n    case \"month\":\r\n      return {\r\n        start: startOfMonth(now),\r\n        end: endOfMonth(now),\r\n      };\r\n    case \"custom\":\r\n      if (startDate && endDate) {\r\n        return {\r\n          start: startOfDay(parseISO(startDate)),\r\n          end: endOfDay(parseISO(endDate)),\r\n        };\r\n      }\r\n      // Fallback to today\r\n      return {\r\n        start: startOfDay(now),\r\n        end: endOfDay(now),\r\n      };\r\n    default:\r\n      return {\r\n        start: startOfDay(now),\r\n        end: endOfDay(now),\r\n      };\r\n  }\r\n}\r\n\r\n// Function to calculate meeting duration in hours\r\nfunction calculateMeetingDuration(startTime: string, endTime?: string): number {\r\n  if (!startTime) return 0;\r\n\r\n  try {\r\n    const start = new Date(startTime);\r\n    const end = endTime ? new Date(endTime) : new Date();\r\n\r\n    // Validate dates\r\n    if (isNaN(start.getTime())) return 0;\r\n    if (endTime && isNaN(end.getTime())) {\r\n      // If end time is invalid, use current time\r\n      const durationMs = new Date().getTime() - start.getTime();\r\n      return Math.max(0, durationMs / (1000 * 60 * 60));\r\n    }\r\n\r\n    const durationMs = end.getTime() - start.getTime();\r\n    if (durationMs < 0) return 0; // Invalid if end is before start\r\n\r\n    return Math.max(0, durationMs / (1000 * 60 * 60)); // Convert to hours\r\n  } catch (error) {\r\n    console.error(\"Error calculating meeting duration:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n// Function to calculate duty hours (placeholder - would need tracking data)\r\nfunction calculateDutyHours(\r\n  employeeId: string,\r\n  dateRange: { start: Date; end: Date },\r\n): number {\r\n  // This is a placeholder calculation\r\n  // In a real app, this would calculate based on tracking sessions, check-ins, etc.\r\n  // For now, we'll assume 8 hours per working day in the date range\r\n  const daysInRange = Math.ceil(\r\n    (dateRange.end.getTime() - dateRange.start.getTime()) /\r\n    (1000 * 60 * 60 * 24),\r\n  );\r\n  return Math.min(daysInRange * 8, 40); // Max 40 hours per week\r\n}\r\n\r\nexport const getEmployeeAnalytics: RequestHandler = async (req, res) => {\r\n  try {\r\n    const {\r\n      employeeId,\r\n      dateRange = \"today\",\r\n      startDate,\r\n      endDate,\r\n      search,\r\n    } = req.query;\r\n\r\n    // Get date range\r\n    const { start, end } = getDateRange(\r\n      dateRange as string,\r\n      startDate as string,\r\n      endDate as string,\r\n    );\r\n\r\n    console.log(`Analytics date filter - Range: ${dateRange}, Start: ${startDate}, End: ${endDate}`);\r\n    console.log(`Calculated date range: ${start.toISOString()} to ${end.toISOString()}`);\r\n\r\n    // Fetch all employees\r\n    const externalUsers = await fetchExternalUsers();\r\n    let employees = externalUsers.map((user, index) =>\r\n      mapExternalUserToEmployee(user, index),\r\n    );\r\n\r\n    // Filter by employee if specified\r\n    if (employeeId && employeeId !== \"all\") {\r\n      employees = employees.filter((emp) => emp.id === employeeId);\r\n    }\r\n\r\n    // Filter by search term if specified\r\n    if (search) {\r\n      const searchTerm = (search as string).toLowerCase();\r\n      employees = employees.filter(\r\n        (emp) =>\r\n          emp.name.toLowerCase().includes(searchTerm) ||\r\n          emp.email.toLowerCase().includes(searchTerm),\r\n      );\r\n    }\r\n\r\n    // Get actual meeting data from MongoDB\r\n    let actualMeetings: any[] = [];\r\n\r\n    try {\r\n      // Try to get meetings from MongoDB first\r\n      // Get ALL meetings for total counts, but we'll filter them properly later\r\n      const mongoMeetings = await Meeting.find({}).lean();\r\n\r\n      actualMeetings = mongoMeetings.map(meeting => ({\r\n        id: meeting._id.toString(),\r\n        employeeId: meeting.employeeId,\r\n        startTime: meeting.startTime,\r\n        endTime: meeting.endTime,\r\n        clientName: meeting.clientName,\r\n        leadId: meeting.leadId,\r\n        status: meeting.status,\r\n        meetingDetails: meeting.meetingDetails,\r\n        location: meeting.location\r\n      }));\r\n\r\n      console.log(`Found ${actualMeetings.length} total meetings in MongoDB`);\r\n      console.log(`Date range filter: ${start.toISOString()} to ${end.toISOString()}`);\r\n\r\n      // If no MongoDB data, fallback to in-memory\r\n      if (actualMeetings.length === 0) {\r\n        const { inMemoryMeetings } = await import(\"./meetings\");\r\n        actualMeetings = inMemoryMeetings || [];\r\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory`);\r\n      }\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\r\n      const { inMemoryMeetings } = await import(\"./meetings\");\r\n      actualMeetings = inMemoryMeetings || [];\r\n    }\r\n\r\n    console.log(\"Using meetings data:\", actualMeetings.length, \"meetings\");\r\n    console.log(\"Available employees:\", employees.map(e => ({ id: e.id, name: e.name })));\r\n    console.log(\"Meeting employee IDs:\", actualMeetings.map(m => m.employeeId));\r\n\r\n    // Calculate analytics for each employee\r\n    const analytics = employees.map((employee) => {\r\n      // Get meetings for this employee\r\n      const employeeMeetings = actualMeetings.filter(\r\n        (meeting) => meeting.employeeId === employee.id,\r\n      );\r\n\r\n      console.log(`Employee ${employee.name} (${employee.id}): found ${employeeMeetings.length} meetings`);\r\n\r\n      // Filter meetings by date range for the specific metrics\r\n      const meetingsInRange = employeeMeetings.filter((meeting) => {\r\n        const meetingDate = new Date(meeting.startTime);\r\n        const meetingTime = meetingDate.getTime();\r\n        const startTime = start.getTime();\r\n        const endTime = end.getTime();\r\n        const inRange = meetingTime >= startTime && meetingTime <= endTime;\r\n\r\n        if (inRange) {\r\n          console.log(`‚úÖ Meeting ${meeting.id} IN range: ${meeting.startTime} (${meeting.clientName || 'No client'})`);\r\n        } else {\r\n          console.log(`‚ùå Meeting ${meeting.id} OUT of range: ${meeting.startTime} (not between ${start.toISOString()} and ${end.toISOString()})`);\r\n        }\r\n        return inRange;\r\n      });\r\n\r\n      // Calculate today's meetings\r\n      const todayMeetings = employeeMeetings.filter((meeting) =>\r\n        isToday(new Date(meeting.startTime)),\r\n      ).length;\r\n\r\n      // Calculate total meeting hours for the filtered range\r\n      // For \"all\" filter, this will be total hours across all meetings\r\n      const totalMeetingHours = meetingsInRange.reduce((total, meeting) => {\r\n        return (\r\n          total + calculateMeetingDuration(meeting.startTime, meeting.endTime)\r\n        );\r\n      }, 0);\r\n\r\n      console.log(`Employee ${employee.name} (${employee.id}): ${employeeMeetings.length} total meetings, ${meetingsInRange.length} in date range (${dateRange}), ${totalMeetingHours.toFixed(1)}h meeting time`);\r\n\r\n      // Calculate duty hours\r\n      const totalDutyHours = calculateDutyHours(employee.id, { start, end });\r\n\r\n      return {\r\n        employeeId: employee.id,\r\n        employeeName: employee.name,\r\n        totalMeetings: employeeMeetings.length, // Total meetings for this employee (all time, never filtered)\r\n        todayMeetings,\r\n        totalMeetingHours, // This uses filtered range which is correct\r\n        totalDutyHours,\r\n        status: employee.status,\r\n      };\r\n    });\r\n\r\n    // Calculate summary statistics\r\n    const summary = {\r\n      totalEmployees: employees.length,\r\n      activeMeetings: employees.filter((emp) => emp.status === \"meeting\")\r\n        .length,\r\n      totalMeetingsToday: analytics.reduce(\r\n        (sum, emp) => sum + emp.todayMeetings,\r\n        0,\r\n      ),\r\n      avgMeetingDuration:\r\n        analytics.length > 0\r\n          ? analytics.reduce((sum, emp) => sum + emp.totalMeetingHours, 0) /\r\n          Math.max(\r\n            analytics.reduce((sum, emp) => sum + emp.totalMeetings, 0),\r\n            1,\r\n          )\r\n          : 0,\r\n    };\r\n\r\n    res.json({\r\n      analytics,\r\n      summary,\r\n      dateRange: {\r\n        start: start.toISOString(),\r\n        end: end.toISOString(),\r\n        label: dateRange,\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error fetching employee analytics:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch analytics\" });\r\n  }\r\n};\r\n\r\n// Mock meeting data generator for demonstration\r\nfunction generateMockMeetings(\r\n  employees: any[],\r\n  startDate: Date,\r\n  endDate: Date,\r\n) {\r\n  const meetings: any[] = [];\r\n  const customers = [\r\n    \"Tech Corp\",\r\n    \"ABC Industries\",\r\n    \"XYZ Solutions\",\r\n    \"Global Systems\",\r\n    \"Innovation Ltd\",\r\n  ];\r\n  const leadIds = [\"LEAD-001\", \"LEAD-002\", \"LEAD-003\", \"LEAD-004\", \"LEAD-005\"];\r\n\r\n  employees.forEach((employee, empIndex) => {\r\n    // Generate 1-5 meetings per employee in the date range\r\n    const meetingCount = Math.floor(Math.random() * 5) + 1;\r\n\r\n    for (let i = 0; i < meetingCount; i++) {\r\n      // Random date within range\r\n      const randomTime = new Date(\r\n        startDate.getTime() +\r\n        Math.random() * (endDate.getTime() - startDate.getTime()),\r\n      );\r\n\r\n      // Random meeting duration (30 minutes to 3 hours)\r\n      const durationHours = Math.random() * 2.5 + 0.5;\r\n      const endTime = new Date(\r\n        randomTime.getTime() + durationHours * 60 * 60 * 1000,\r\n      );\r\n\r\n      meetings.push({\r\n        id: `meeting_${empIndex}_${i}`,\r\n        employeeId: employee.id,\r\n        startTime: randomTime.toISOString(),\r\n        endTime: endTime.toISOString(),\r\n        clientName: customers[Math.floor(Math.random() * customers.length)],\r\n        leadId: leadIds[Math.floor(Math.random() * leadIds.length)],\r\n        status: \"completed\",\r\n        location: employee.location,\r\n      });\r\n    }\r\n  });\r\n\r\n  return meetings;\r\n}\r\n\r\nexport const getEmployeeDetails: RequestHandler = async (req, res) => {\r\n\r\n  const resolveLocationAddress = (location: any): string => {\r\n    if (!location) return \"\";\r\n\r\n    // If location has an endLocation, use that first\r\n    if (location.endLocation?.address) {\r\n      const endAddr = location.endLocation.address;\r\n      \r\n      // Check if it's just coordinates (lat,lng format) like \"28.277276, 76.885777\"\r\n      const isCoordinates = /^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$/.test(endAddr);\r\n      \r\n      if (isCoordinates) {\r\n        // If end location is coordinates, try to use the start address instead\r\n        return location.address || \"Location coordinates\";\r\n      }\r\n      return endAddr;\r\n    }\r\n\r\n    // Fallback to main address\r\n    if (typeof location.address === \"string\" && location.address.trim()) {\r\n      return location.address;\r\n    }\r\n\r\n    // fallback: return empty string\r\n    return \"\";\r\n  };\r\n\r\n  try {\r\n    const { employeeId } = req.params;\r\n    const {\r\n      dateRange = \"today\",\r\n      startDate,\r\n      endDate,\r\n      page = \"1\",\r\n      limit = \"20\",\r\n      type = \"meetings\" // \"meetings\" or \"days\"\r\n    } = req.query;\r\n\r\n    // Start timing\r\n    const startTime = Date.now();\r\n\r\n    // Parse pagination parameters\r\n    const pageNum = parseInt(page as string, 10) || 1;\r\n    const limitNum = parseInt(limit as string, 10) || 20;\r\n    const skip = (pageNum - 1) * limitNum;\r\n\r\n    // Get date range\r\n    const { start, end } = getDateRange(\r\n      dateRange as string,\r\n      startDate as string,\r\n      endDate as string,\r\n    );\r\n\r\n    console.log(`üìä Employee details for ${employeeId} - Date range: ${dateRange}, Page: ${pageNum}, Limit: ${limitNum}`);\r\n\r\n    // PARALLELIZE DATA FETCHING\r\n    const [\r\n      externalUsers,\r\n      meetingsData,\r\n      meetingsCount,\r\n      trackingSessionsData,\r\n      attendanceRecords,\r\n      allMeetingsForEmployee\r\n    ] = await Promise.allSettled([\r\n      // Get external users from cache\r\n      cacheService.getExternalUsers(),\r\n\r\n      // Fetch meetings with date range filter and pagination\r\n      Meeting.find({\r\n        employeeId,\r\n        startTime: {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        }\r\n      })\r\n        .select('startTime endTime clientName leadId status meetingDetails location approvalStatus approvalReason approvedBy')\r\n        .sort({ startTime: -1 }) // Sort by latest first\r\n        .skip(skip)\r\n        .limit(limitNum)\r\n        .lean()\r\n        .exec(),\r\n\r\n      // Get total count of meetings for pagination\r\n      Meeting.countDocuments({\r\n        employeeId,\r\n        startTime: {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        }\r\n      }),\r\n\r\n      // Fetch tracking sessions with date range filter\r\n      TrackingSession.find({\r\n        employeeId,\r\n        startTime: {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        }\r\n      })\r\n        .select('startTime endTime startLocation endLocation status duration')\r\n        .lean()\r\n        .exec(),\r\n\r\n      // Fetch attendance records\r\n      Attendance.find({\r\n        employeeId,\r\n        date: {\r\n          $gte: format(start, \"yyyy-MM-dd\"),\r\n          $lte: format(end, \"yyyy-MM-dd\")\r\n        }\r\n      })\r\n        .select('date attendanceStatus attendanceReason attendenceCreated')\r\n        .lean()\r\n        .exec(),\r\n\r\n      // Get ALL meetings for this employee in the date range (not paginated)\r\n      Meeting.find({\r\n        employeeId,\r\n        startTime: {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        }\r\n      })\r\n        .select('startTime endTime clientName leadId status meetingDetails location')\r\n        .sort({ startTime: -1 })\r\n        .lean()\r\n        .exec()\r\n    ]);\r\n\r\n    // Handle Promise results\r\n    const externalUsersResult = externalUsers.status === 'fulfilled' ? externalUsers.value : [];\r\n    const meetingsDataResult = meetingsData.status === 'fulfilled' ? meetingsData.value : [];\r\n    const meetingsCountResult = meetingsCount.status === 'fulfilled' ? meetingsCount.value : 0;\r\n    const trackingSessionsResult = trackingSessionsData.status === 'fulfilled' ? trackingSessionsData.value : [];\r\n    const attendanceRecordsResult = attendanceRecords.status === 'fulfilled' ? attendanceRecords.value : [];\r\n    const allMeetingsResult = allMeetingsForEmployee.status === 'fulfilled' ? allMeetingsForEmployee.value : [];\r\n\r\n    // Log any errors\r\n    if (externalUsers.status === 'rejected') console.error('Error fetching external users:', externalUsers.reason);\r\n    if (meetingsData.status === 'rejected') console.error('Error fetching meetings:', meetingsData.reason);\r\n    if (meetingsCount.status === 'rejected') console.error('Error counting meetings:', meetingsCount.reason);\r\n    if (trackingSessionsData.status === 'rejected') console.error('Error fetching tracking sessions:', trackingSessionsData.reason);\r\n    if (attendanceRecords.status === 'rejected') console.error('Error fetching attendance:', attendanceRecords.reason);\r\n    if (allMeetingsForEmployee.status === 'rejected') console.error('Error fetching all meetings:', allMeetingsForEmployee.reason);\r\n\r\n    const meetings = meetingsDataResult;\r\n    const trackingSessions = trackingSessionsResult;\r\n    const allMeetings = allMeetingsResult;\r\n\r\n    console.log(`üìà Fetched data: ${meetings.length} paginated meetings, ${allMeetings.length} total meetings (total count: ${meetingsCountResult}), ${trackingSessions.length} sessions, ${attendanceRecordsResult.length} attendance records`);\r\n\r\n    // Create user map for quick lookups\r\n    const userMap = new Map(externalUsersResult.map(user => [user._id, user.name]));\r\n\r\n    // Get ALL dates in the range (not just paginated meetings)\r\n    const allDatesInRange = [];\r\n    let currentDate = new Date(start);\r\n    const today = new Date();\r\n    today.setHours(23, 59, 59, 999); // End of today\r\n\r\n    // Only include dates up to today to avoid future empty dates\r\n    while (currentDate <= end && currentDate <= today) {\r\n      allDatesInRange.push(format(currentDate, \"yyyy-MM-dd\"));\r\n      currentDate.setDate(currentDate.getDate() + 1);\r\n    }\r\n\r\n    console.log(`üìÖ Date range includes ${allDatesInRange.length} total days (excluding future dates)`);\r\n\r\n    // Group ALL meetings by date\r\n    const allMeetingsByDate = new Map();\r\n    allMeetings.forEach(meeting => {\r\n      try {\r\n        const date = format(new Date(meeting.startTime), \"yyyy-MM-dd\");\r\n        if (!allMeetingsByDate.has(date)) {\r\n          allMeetingsByDate.set(date, []);\r\n        }\r\n        allMeetingsByDate.get(date).push(meeting);\r\n      } catch (error) {\r\n        console.error('Error processing meeting date:', error);\r\n      }\r\n    });\r\n\r\n    // Group tracking sessions by date\r\n    const sessionDateGroups = new Map();\r\n    trackingSessions.forEach(session => {\r\n      try {\r\n        const date = format(new Date(session.startTime), \"yyyy-MM-dd\");\r\n        if (!sessionDateGroups.has(date)) {\r\n          sessionDateGroups.set(date, []);\r\n        }\r\n        sessionDateGroups.get(date).push(session);\r\n      } catch (error) {\r\n        console.error('Error processing session date:', error);\r\n      }\r\n    });\r\n\r\n    // Generate day records for ALL dates in range\r\n    const dayRecords = allDatesInRange.map((date) => {\r\n      const meetings = allMeetingsByDate.get(date) || [];\r\n      const sessions = sessionDateGroups.get(date) || [];\r\n\r\n      const totalMeetings = meetings.length;\r\n      const totalMeetingHours = meetings.reduce((total, meeting) => {\r\n        return total + calculateMeetingDuration(meeting.startTime, meeting.endTime);\r\n      }, 0);\r\n\r\n      // Sort meetings by start time\r\n      const sortedMeetings = [...meetings].sort((a, b) =>\r\n        new Date(a.startTime).getTime() - new Date(b.startTime).getTime()\r\n      );\r\n\r\n      const firstMeeting = sortedMeetings[0];\r\n      const lastMeeting = sortedMeetings[sortedMeetings.length - 1];\r\n\r\n      // Calculate times\r\n      const startLocationTime = firstMeeting?.startTime ? format(new Date(firstMeeting.startTime), \"HH:mm:ss\") : \"\";\r\n      const startLocationAddress = firstMeeting?.location?.address || \"\";\r\n\r\n      const outLocationTime = lastMeeting?.endTime ? format(new Date(lastMeeting.endTime), \"HH:mm:ss\") : \"\";\r\n      \r\n      // üîπ FIX: Use resolveLocationAddress for outLocationAddress\r\n      const outLocationAddress = lastMeeting?.endTime \r\n        ? resolveLocationAddress(lastMeeting.location) || (lastMeeting?.location?.address || \"\")\r\n        : \"\";\r\n\r\n      // Calculate duty hours from first meeting start to last meeting end\r\n      let totalDutyHours = 0;\r\n      if (firstMeeting?.startTime && lastMeeting?.endTime) {\r\n        try {\r\n          const start = new Date(firstMeeting.startTime);\r\n          const end = new Date(lastMeeting.endTime);\r\n          const dutyDuration = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\r\n          totalDutyHours = Math.max(0, dutyDuration);\r\n        } catch (error) {\r\n          console.error(\"Error calculating duty hours:\", error);\r\n          totalDutyHours = 0;\r\n        }\r\n      } else if (firstMeeting?.startTime) {\r\n        // Only start time available (ongoing meeting)\r\n        try {\r\n          const start = new Date(firstMeeting.startTime);\r\n          const now = new Date();\r\n          const dutyDuration = (now.getTime() - start.getTime()) / (1000 * 60 * 60);\r\n          totalDutyHours = Math.max(0, dutyDuration);\r\n        } catch (error) {\r\n          totalDutyHours = 0;\r\n        }\r\n      }\r\n\r\n      // Get attendance info\r\n      const attendance = attendanceRecordsResult.find(att => att.date === date);\r\n      const attendanceAddedBy = attendance?.attendenceCreated\r\n        ? userMap.get(attendance.attendenceCreated) || attendance.attendenceCreated\r\n        : null;\r\n\r\n      return {\r\n        date,\r\n        totalMeetings,\r\n        startLocationTime,\r\n        startLocationAddress,\r\n        outLocationTime,\r\n        outLocationAddress,\r\n        totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\r\n        meetingTime: parseFloat(totalMeetingHours.toFixed(2)),\r\n        travelAndLunchTime: Math.max(0, parseFloat((totalDutyHours - totalMeetingHours).toFixed(2))),\r\n        attendanceAddedBy\r\n      };\r\n    });\r\n\r\n    // Generate meeting records from PAGINATED meetings only\r\n    const meetingRecords = meetings.map((meeting) => {\r\n      const meetingInTime = meeting.startTime ? format(new Date(meeting.startTime), \"HH:mm:ss\") : \"\";\r\n      const meetingOutTime = meeting.endTime\r\n        ? format(new Date(meeting.endTime), \"HH:mm:ss\")\r\n        : \"In Progress\";\r\n\r\n      // üîπ FIX: Smart logic for meetingOutLocation\r\n      let meetingOutLocation = \"Meeting in progress\";\r\n      \r\n      if (meeting.endTime) {\r\n        if (meeting.location?.endLocation?.address) {\r\n          const endAddr = meeting.location.endLocation.address;\r\n          \r\n          // Check if it's just coordinates (e.g., \"28.277276, 76.885777\")\r\n          const isCoordinates = /^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$/.test(endAddr);\r\n          \r\n          if (isCoordinates) {\r\n            // If end location is coordinates, try to use the start address\r\n            meetingOutLocation = meeting.location?.address || \"Location coordinates\";\r\n          } else {\r\n            // Use the proper end address\r\n            meetingOutLocation = endAddr;\r\n          }\r\n        } else if (meeting.status === \"completed\") {\r\n          // No endLocation but meeting is completed - use start address\r\n          console.log(\"meeting.location?.address\",meeting.location?.address);\r\n          meetingOutLocation = meeting.location?.address || \"Meeting completed\";\r\n        }\r\n      }\r\n\r\n      // üîπ FIX: Smart logic for meetingPerson\r\n      let meetingPerson = \"TBD\";\r\n      if (meeting.status === \"completed\") {\r\n        if (meeting.meetingDetails?.customers?.length > 0) {\r\n          meetingPerson = meeting.meetingDetails.customers\r\n            .map((customer) => customer.customerEmployeeName)\r\n            .join(\", \");\r\n        } else if (meeting.meetingDetails?.customerEmployeeName) {\r\n          meetingPerson = meeting.meetingDetails.customerEmployeeName;\r\n        } else {\r\n          meetingPerson = \"Unknown\";\r\n        }\r\n      }\r\n\r\n      // üîπ FIX: Smart logic for discussion\r\n      let discussion = \"\";\r\n      if (meeting.status === \"completed\") {\r\n        discussion = meeting.meetingDetails?.discussion || meeting.notes || \"\";\r\n      } else {\r\n        discussion = \"Meeting in progress\";\r\n      }\r\n\r\n      return {\r\n        meetingId: meeting._id?.toString() || meeting.id,\r\n        employeeName: \"\", // Will be filled by client\r\n        companyName: meeting.clientName || \"Unknown Company\",\r\n        date: meeting.startTime ? format(new Date(meeting.startTime), \"yyyy-MM-dd\") : \"\",\r\n        leadId: meeting.leadId || \"\",\r\n        meetingInTime,\r\n        meetingInLocation: meeting.location?.address || \"Location not available\",\r\n        meetingOutTime,\r\n        meetingOutLocation, // Use the fixed value\r\n        totalStayTime: calculateMeetingDuration(meeting.startTime, meeting.endTime),\r\n        discussion,\r\n        meetingPerson,\r\n        meetingStatus: meeting.status || \"completed\",\r\n        externalMeetingStatus: meeting.externalMeetingStatus || \"\",\r\n        incomplete: meeting.meetingDetails?.incomplete || false,\r\n        incompleteReason: meeting.meetingDetails?.incompleteReason || \"\",\r\n        approvalStatus: meeting.approvalStatus || undefined,\r\n        approvalReason: meeting.approvalReason || undefined,\r\n        approvedBy: meeting.approvedBy || undefined,\r\n        approvedByName: meeting.approvedBy ? userMap.get(meeting.approvedBy) || meeting.approvedBy : undefined,\r\n        attachments: meeting.meetingDetails?.attachments || meeting.attachments || [],\r\n      };\r\n    });\r\n\r\n    // Apply pagination to dayRecords\r\n    // First filter out future dates and sort in DESCENDING order (newest first)\r\n    const todayDate = new Date();\r\n    const todayStr = format(todayDate, \"yyyy-MM-dd\");\r\n    const validDayRecords = dayRecords.filter(record => {\r\n      try {\r\n        const recordDate = new Date(record.date);\r\n        return recordDate <= todayDate;\r\n      } catch {\r\n        return true;\r\n      }\r\n    });\r\n\r\n    const dayRecordsSorted = validDayRecords.sort((a, b) => {\r\n      try {\r\n        return new Date(b.date).getTime() - new Date(a.date).getTime();\r\n      } catch {\r\n        return 0;\r\n      }\r\n    });\r\n\r\n    const totalDayRecords = dayRecordsSorted.length;\r\n    const dayRecordsTotalPages = Math.ceil(totalDayRecords / limitNum);\r\n    const dayRecordsStartIndex = (pageNum - 1) * limitNum;\r\n    const dayRecordsEndIndex = dayRecordsStartIndex + limitNum;\r\n    const paginatedDayRecords = dayRecordsSorted.slice(dayRecordsStartIndex, dayRecordsEndIndex);\r\n\r\n    console.log(`üìÖ Day records: ${totalDayRecords} valid dates (filtered future dates), showing ${paginatedDayRecords.length} on page ${pageNum}`);\r\n\r\n    // Calculate pagination info\r\n    const totalPages = Math.ceil(meetingsCountResult / limitNum);\r\n    const hasNextPage = pageNum < totalPages;\r\n    const hasPreviousPage = pageNum > 1;\r\n\r\n    const result = {\r\n      pagination: {\r\n        currentPage: pageNum,\r\n        pageSize: limitNum,\r\n        totalItems: meetingsCountResult,\r\n        totalPages: totalPages,\r\n        hasNextPage,\r\n        hasPreviousPage,\r\n        nextPage: hasNextPage ? pageNum + 1 : null,\r\n        previousPage: hasPreviousPage ? pageNum - 1 : null,\r\n      },\r\n      dayRecordsPagination: {\r\n        currentPage: pageNum,\r\n        pageSize: limitNum,\r\n        totalItems: totalDayRecords,\r\n        totalPages: dayRecordsTotalPages,\r\n        hasNextDayRecordsPage: pageNum < dayRecordsTotalPages,\r\n        hasPreviousDayRecordsPage: pageNum > 1,\r\n      },\r\n      dayRecords: paginatedDayRecords,\r\n      meetingRecords: meetingRecords.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()),\r\n    };\r\n\r\n    const endTime = Date.now();\r\n    console.log(`‚úÖ Employee details fetched in ${endTime - startTime}ms`);\r\n\r\n    res.json(result);\r\n  } catch (error) {\r\n    console.error(\"Error fetching employee details:\", error);\r\n    console.error(\"Error details:\", error.message);\r\n    console.error(\"Error stack:\", error.stack);\r\n    res.status(500).json({\r\n      error: \"Failed to fetch employee details\",\r\n      message: error.message\r\n    });\r\n  }\r\n};\r\n\r\nexport const getLeadHistory: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { leadId } = req.params;\r\n\r\n    console.log(`Fetching history for lead: ${leadId}`);\r\n\r\n    // Get actual meeting data from MongoDB\r\n    let actualMeetings: any[] = [];\r\n\r\n    try {\r\n      // Try to get meetings from MongoDB first\r\n      const mongoMeetings = await Meeting.find({ leadId }).lean();\r\n\r\n      actualMeetings = mongoMeetings.map(meeting => ({\r\n        id: meeting._id.toString(),\r\n        employeeId: meeting.employeeId,\r\n        startTime: meeting.startTime,\r\n        endTime: meeting.endTime,\r\n        clientName: meeting.clientName,\r\n        leadId: meeting.leadId,\r\n        status: meeting.status,\r\n        meetingDetails: meeting.meetingDetails,\r\n        location: meeting.location,\r\n        leadInfo: meeting.leadInfo\r\n      }));\r\n\r\n      console.log(`Found ${actualMeetings.length} meetings in MongoDB for lead ${leadId}`);\r\n\r\n      // If no MongoDB data, fallback to in-memory\r\n      if (actualMeetings.length === 0) {\r\n        const { inMemoryMeetings } = await import('./meetings');\r\n        actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\r\n        console.log(`Fallback: Using ${actualMeetings.length} meetings from memory for lead ${leadId}`);\r\n      }\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed, falling back to in-memory meetings:\", dbError);\r\n      const { inMemoryMeetings } = await import('./meetings');\r\n      actualMeetings = (inMemoryMeetings || []).filter(meeting => meeting.leadId === leadId);\r\n    }\r\n\r\n    // Filter meetings by lead ID\r\n    const leadMeetings = actualMeetings.filter(meeting => meeting.leadId === leadId);\r\n\r\n    console.log(`Found ${leadMeetings.length} meetings for lead ${leadId}`);\r\n\r\n    // Get employee data for names\r\n    const externalUsers = await fetchExternalUsers();\r\n    const employees = externalUsers.map((user, index) => mapExternalUserToEmployee(user, index));\r\n\r\n    // Generate history records\r\n    const history = leadMeetings.map(meeting => {\r\n      const employee = employees.find(emp => emp.id === meeting.employeeId);\r\n      const duration = calculateMeetingDuration(meeting.startTime, meeting.endTime);\r\n\r\n      return {\r\n        date: meeting.startTime,\r\n        employeeName: employee?.name || \"Unknown Employee\",\r\n        companyName: meeting.clientName || \"Unknown Company\",\r\n        duration,\r\n        meetingPerson: meeting.meetingDetails?.customers?.length > 0\r\n          ? meeting.meetingDetails.customers.map(customer => customer.customerEmployeeName).join(\", \")\r\n          : meeting.meetingDetails?.customerEmployeeName || \"Unknown\",\r\n        discussion: meeting.meetingDetails?.discussion || meeting.notes || \"\",\r\n        status: meeting.status || \"completed\",\r\n        location: meeting.location?.address || \"\",\r\n        leadInfo: meeting.leadInfo,\r\n      };\r\n    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\r\n\r\n    res.json({\r\n      leadId,\r\n      history,\r\n      totalMeetings: history.length,\r\n      totalDuration: history.reduce((sum, record) => sum + record.duration, 0),\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error(\"Error fetching lead history:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch lead history\" });\r\n  }\r\n};\r\n\r\nexport const saveAttendance: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, date, attendanceStatus, attendanceReason, attendenceCreated } = req.body;\r\n\r\n    console.log(`Saving attendance for employee ${employeeId} on ${date}:`, {\r\n      attendanceStatus,\r\n      attendanceReason,\r\n      attendenceCreated\r\n    });\r\n\r\n    // Validate required fields\r\n    if (!employeeId || !date || !attendanceStatus) {\r\n      return res.status(400).json({\r\n        error: \"Employee ID, date, and attendance status are required\"\r\n      });\r\n    }\r\n\r\n    // Validate attendance status\r\n    const validStatuses = [\"full_day\", \"half_day\", \"off\", \"short_leave\", \"ot\", \"absent\"];\r\n    if (!validStatuses.includes(attendanceStatus)) {\r\n      return res.status(400).json({\r\n        error: \"Invalid attendance status\"\r\n      });\r\n    }\r\n\r\n    // Validate date format (YYYY-MM-DD)\r\n    if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\r\n      return res.status(400).json({\r\n        error: \"Date must be in YYYY-MM-DD format\"\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Try to save to MongoDB using upsert (update if exists, create if not)\r\n      const savedAttendance = await Attendance.findOneAndUpdate(\r\n        { employeeId, date },\r\n        {\r\n          employeeId,\r\n          date,\r\n          attendanceStatus,\r\n          attendanceReason: attendanceReason || \"\",\r\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null // Default to null if not provided\r\n        },\r\n        {\r\n          new: true,\r\n          upsert: true,\r\n          runValidators: true\r\n        }\r\n      );\r\n\r\n      console.log(\"Attendance saved to MongoDB:\", savedAttendance._id);\r\n      console.log(\"Attendance attendenceCreated value:\", savedAttendance.attendenceCreated);\r\n\r\n      res.json({\r\n        success: true,\r\n        message: \"Attendance saved successfully\",\r\n        data: {\r\n          id: savedAttendance._id,\r\n          employeeId: savedAttendance.employeeId,\r\n          date: savedAttendance.date,\r\n          attendanceStatus: savedAttendance.attendanceStatus,\r\n          attendanceReason: savedAttendance.attendanceReason,\r\n          attendenceCreated: savedAttendance.attendenceCreated,\r\n          savedAt: savedAttendance.updatedAt\r\n        }\r\n      });\r\n\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB save failed, using fallback:\", dbError);\r\n\r\n      // Fallback response (in real app, might save to alternative storage)\r\n      res.json({\r\n        success: true,\r\n        message: \"Attendance saved successfully (fallback mode)\",\r\n        data: {\r\n          employeeId,\r\n          date,\r\n          attendanceStatus,\r\n          attendanceReason,\r\n          attendenceCreated: attendenceCreated !== undefined ? attendenceCreated : null,\r\n          savedAt: new Date().toISOString()\r\n        }\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(\"Error saving attendance:\", error);\r\n    res.status(500).json({ error: \"Failed to save attendance\" });\r\n  }\r\n};\r\n\r\nexport const getMeetingTrends: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, period = \"week\" } = req.query;\r\n\r\n    // This would calculate meeting trends over time\r\n    // For now, return mock data\r\n    const trends = {\r\n      labels: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\r\n      datasets: [\r\n        {\r\n          label: \"Meetings\",\r\n          data: [2, 4, 3, 5, 2, 1, 0],\r\n        },\r\n        {\r\n          label: \"Hours\",\r\n          data: [4, 8, 6, 10, 4, 2, 0],\r\n        },\r\n      ],\r\n    };\r\n\r\n    res.json(trends);\r\n  } catch (error) {\r\n    console.error(\"Error fetching meeting trends:\", error);\r\n    res.status(500).json({ error: \"Failed to fetch trends\" });\r\n  }\r\n};\r\n\r\nexport const getAttendance: RequestHandler = async (req, res) => {\r\n  try {\r\n    const { employeeId, startDate, endDate, date } = req.query;\r\n\r\n    console.log(`Fetching attendance records:`, {\r\n      employeeId,\r\n      startDate,\r\n      endDate,\r\n      date\r\n    });\r\n\r\n    // Build query filter\r\n    const filter: any = {};\r\n\r\n    if (employeeId) {\r\n      filter.employeeId = employeeId;\r\n    }\r\n\r\n    if (date) {\r\n      // Single date query\r\n      filter.date = date;\r\n    } else if (startDate && endDate) {\r\n      // Date range query\r\n      filter.date = {\r\n        $gte: startDate,\r\n        $lte: endDate\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Fetch from MongoDB\r\n      const attendanceRecords = await Attendance.find(filter)\r\n        .sort({ date: -1 })\r\n        .lean();\r\n\r\n      console.log(`Found ${attendanceRecords.length} attendance records`);\r\n\r\n      // Fetch external users to map attendenceCreated IDs to names\r\n      const externalUsers = await fetchExternalUsers();\r\n      const userMap = new Map(externalUsers.map(user => [user._id, user.name]));\r\n\r\n      // Format the response\r\n      const formattedRecords = attendanceRecords.map(record => ({\r\n        id: record._id.toString(),\r\n        employeeId: record.employeeId,\r\n        date: record.date,\r\n        attendanceStatus: record.attendanceStatus,\r\n        attendanceReason: record.attendanceReason || \"\",\r\n        attendenceCreated: record.attendenceCreated,\r\n        attendenceCreatedName: record.attendenceCreated\r\n          ? userMap.get(record.attendenceCreated) || record.attendenceCreated\r\n          : null,\r\n        savedAt: record.updatedAt || record.createdAt\r\n      }));\r\n\r\n      res.json({\r\n        success: true,\r\n        count: formattedRecords.length,\r\n        data: formattedRecords\r\n      });\r\n\r\n    } catch (dbError) {\r\n      console.warn(\"MongoDB query failed:\", dbError);\r\n\r\n      // Fallback response\r\n      res.json({\r\n        success: true,\r\n        count: 0,\r\n        data: [],\r\n        message: \"No attendance records found (database unavailable)\"\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(\"Error fetching attendance:\", error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: \"Failed to fetch attendance records\"\r\n    });\r\n  }\r\n};\r\n\r\nexport const getAllEmployeesDetails: RequestHandler = async (req, res) => {\r\n  try {\r\n    const {\r\n      dateRange = \"today\",\r\n      startDate,\r\n      endDate,\r\n      page = \"1\",\r\n      limit = \"10\",\r\n      search = \"\",\r\n      sortBy = \"employeeName\",\r\n      sortOrder = \"asc\"\r\n    } = req.query;\r\n\r\n    // Start timing\r\n    const startTime = Date.now();\r\n\r\n    // Parse pagination parameters\r\n    const pageNum = parseInt(page as string, 10) || 1;\r\n    const limitNum = parseInt(limit as string, 10) || 10;\r\n    const skip = (pageNum - 1) * limitNum;\r\n\r\n    // Get date range\r\n    const { start, end } = getDateRange(\r\n      dateRange as string,\r\n      startDate as string,\r\n      endDate as string,\r\n    );\r\n\r\n    console.log(`üìä All employees details - Date range: ${dateRange}, Page: ${pageNum}, Limit: ${limitNum}, Search: \"${search}\"`);\r\n\r\n    // STEP 1: Get ALL employees from external API\r\n    const externalUsers = await cacheService.getExternalUsers();\r\n    console.log(`Found ${externalUsers.length} total employees from cache`);\r\n\r\n    // STEP 2: Map all employees\r\n    let allEmployees = externalUsers.map((user, index) => {\r\n      const employee = mapExternalUserToEmployee(user, index);\r\n      return {\r\n        ...employee,\r\n        userId: user._id\r\n      };\r\n    });\r\n\r\n    console.log(`Mapped ${allEmployees.length} total employees`);\r\n\r\n    // STEP 3: Apply search filter if provided\r\n    if (search) {\r\n      const searchLower = (search as string).toLowerCase();\r\n      allEmployees = allEmployees.filter(emp =>\r\n        emp.name.toLowerCase().includes(searchLower) ||\r\n        emp.email.toLowerCase().includes(searchLower) ||\r\n        emp.designation?.toLowerCase().includes(searchLower) ||\r\n        emp.department?.toLowerCase().includes(searchLower)\r\n      );\r\n      console.log(`Filtered to ${allEmployees.length} employees after search`);\r\n    }\r\n\r\n    // If no employees after search, return empty result\r\n    if (allEmployees.length === 0) {\r\n      const endTime = Date.now();\r\n      console.log(`‚úÖ No employees found after search in ${endTime - startTime}ms`);\r\n\r\n      return res.json({\r\n        success: true,\r\n        dateRange: {\r\n          start: start.toISOString(),\r\n          end: end.toISOString(),\r\n          label: dateRange,\r\n        },\r\n        pagination: {\r\n          currentPage: pageNum,\r\n          pageSize: limitNum,\r\n          totalItems: 0,\r\n          totalPages: 0,\r\n          hasNextPage: false,\r\n          hasPreviousPage: false,\r\n          nextPage: null,\r\n          previousPage: null,\r\n        },\r\n        search: search || null,\r\n        sort: {\r\n          by: sortBy,\r\n          order: sortOrder\r\n        },\r\n        employees: [],\r\n      });\r\n    }\r\n\r\n    // STEP 4: Get employee IDs for all employees\r\n    const employeeIds = allEmployees.map(emp => emp.userId || emp.id);\r\n\r\n    // STEP 5: Fetch data to check which employees have activity\r\n    const [\r\n      allEmployeeMeetings,\r\n      attendanceForEmployees,\r\n      trackingSessionsForEmployees\r\n    ] = await Promise.all([\r\n      // Fetch meetings for all employees in date range\r\n      Meeting.find({\r\n        employeeId: { $in: employeeIds },\r\n        $or: [\r\n          { startTime: { $gte: start, $lte: end } },\r\n          { startTime: { $gte: start.toISOString(), $lte: end.toISOString() } }\r\n        ]\r\n      })\r\n        .select('employeeId startTime endTime clientName leadId status meetingDetails location')\r\n        .sort({ startTime: -1 })\r\n        .lean()\r\n        .exec(),\r\n\r\n      // Fetch attendance records\r\n      Attendance.find({\r\n        employeeId: { $in: employeeIds },\r\n        date: {\r\n          $gte: format(start, \"yyyy-MM-dd\"),\r\n          $lte: format(end, \"yyyy-MM-dd\")\r\n        }\r\n      })\r\n        .select('employeeId date attendanceStatus attendanceReason attendenceCreated')\r\n        .lean()\r\n        .exec(),\r\n\r\n      // Fetch tracking sessions for duty hour calculations\r\n      TrackingSession.find({\r\n        employeeId: { $in: employeeIds },\r\n        startTime: {\r\n          $gte: start.toISOString(),\r\n          $lte: end.toISOString()\r\n        }\r\n      })\r\n        .select('employeeId startTime endTime startLocation endLocation status duration')\r\n        .lean()\r\n        .exec()\r\n    ]);\r\n\r\n    console.log(`üìÖ Found ${allEmployeeMeetings.length} meetings, ${attendanceForEmployees.length} attendance records, and ${trackingSessionsForEmployees.length} tracking sessions`);\r\n\r\n    // STEP 6: Identify which employees have activity data\r\n    const employeesWithActivity = new Set();\r\n    \r\n    // Add employees with meetings\r\n    allEmployeeMeetings.forEach(meeting => {\r\n      employeesWithActivity.add(meeting.employeeId);\r\n    });\r\n    \r\n    // Add employees with attendance\r\n    attendanceForEmployees.forEach(attendance => {\r\n      employeesWithActivity.add(attendance.employeeId);\r\n    });\r\n    \r\n    // Add employees with tracking sessions\r\n    trackingSessionsForEmployees.forEach(session => {\r\n      employeesWithActivity.add(session.employeeId);\r\n    });\r\n\r\n    console.log(`üë• ${employeesWithActivity.size} employees have activity data in the selected date range`);\r\n\r\n    // STEP 7: Filter employees to only those with activity\r\n    const employeesWithData = allEmployees.filter(emp => \r\n      employeesWithActivity.has(emp.userId || emp.id)\r\n    );\r\n\r\n    console.log(`Filtered to ${employeesWithData.length} employees with data`);\r\n\r\n    // If no employees with data, return empty result\r\n    if (employeesWithData.length === 0) {\r\n      const endTime = Date.now();\r\n      console.log(`‚úÖ No employees with activity found in ${endTime - startTime}ms`);\r\n\r\n      return res.json({\r\n        success: true,\r\n        dateRange: {\r\n          start: start.toISOString(),\r\n          end: end.toISOString(),\r\n          label: dateRange,\r\n        },\r\n        pagination: {\r\n          currentPage: pageNum,\r\n          pageSize: limitNum,\r\n          totalItems: 0,\r\n          totalPages: 0,\r\n          hasNextPage: false,\r\n          hasPreviousPage: false,\r\n          nextPage: null,\r\n          previousPage: null,\r\n        },\r\n        search: search || null,\r\n        sort: {\r\n          by: sortBy,\r\n          order: sortOrder\r\n        },\r\n        employees: [],\r\n      });\r\n    }\r\n\r\n    // STEP 8: Sort employees with data\r\n    const sortDirection = sortOrder === 'desc' ? -1 : 1;\r\n    employeesWithData.sort((a, b) => {\r\n      switch (sortBy) {\r\n        case 'employeeName':\r\n          return sortDirection * a.name.localeCompare(b.name);\r\n        case 'email':\r\n          return sortDirection * (a.email || '').localeCompare(b.email || '');\r\n        case 'designation':\r\n          return sortDirection * (a.designation || '').localeCompare(b.designation || '');\r\n        case 'department':\r\n          return sortDirection * (a.department || '').localeCompare(b.department || '');\r\n        default:\r\n          return sortDirection * a.name.localeCompare(b.name);\r\n      }\r\n    });\r\n\r\n    // STEP 9: Apply pagination to filtered employees\r\n    const totalEmployees = employeesWithData.length;\r\n    const totalPages = Math.ceil(totalEmployees / limitNum);\r\n    const paginatedEmployees = employeesWithData.slice(skip, skip + limitNum);\r\n\r\n    console.log(`üìÑ Showing ${paginatedEmployees.length} employees with data (page ${pageNum} of ${totalPages})`);\r\n\r\n    // If no paginated employees, return empty\r\n    if (paginatedEmployees.length === 0) {\r\n      const endTime = Date.now();\r\n      console.log(`‚úÖ Process completed in ${endTime - startTime}ms`);\r\n\r\n      return res.json({\r\n        success: true,\r\n        dateRange: {\r\n          start: start.toISOString(),\r\n          end: end.toISOString(),\r\n          label: dateRange,\r\n        },\r\n        pagination: {\r\n          currentPage: pageNum,\r\n          pageSize: limitNum,\r\n          totalItems: totalEmployees,\r\n          totalPages: totalPages,\r\n          hasNextPage: pageNum < totalPages,\r\n          hasPreviousPage: pageNum > 1,\r\n          nextPage: pageNum < totalPages ? pageNum + 1 : null,\r\n          previousPage: pageNum > 1 ? pageNum - 1 : null,\r\n        },\r\n        search: search || null,\r\n        sort: {\r\n          by: sortBy,\r\n          order: sortOrder\r\n        },\r\n        employees: [],\r\n      });\r\n    }\r\n\r\n    // STEP 10: Group data for quick access (for paginated employees only)\r\n    const paginatedEmployeeIds = paginatedEmployees.map(emp => emp.userId || emp.id);\r\n    \r\n    // Filter meetings for paginated employees only\r\n    const meetingsForPaginatedEmployees = allEmployeeMeetings.filter(meeting => \r\n      paginatedEmployeeIds.includes(meeting.employeeId)\r\n    );\r\n    \r\n    // Filter attendance for paginated employees only\r\n    const attendanceForPaginatedEmployees = attendanceForEmployees.filter(att => \r\n      paginatedEmployeeIds.includes(att.employeeId)\r\n    );\r\n    \r\n    // Filter tracking sessions for paginated employees only\r\n    const trackingSessionsForPaginatedEmployees = trackingSessionsForEmployees.filter(session => \r\n      paginatedEmployeeIds.includes(session.employeeId)\r\n    );\r\n\r\n    // Group ALL meetings by employee\r\n    const allMeetingsByEmployee = new Map();\r\n    meetingsForPaginatedEmployees.forEach(meeting => {\r\n      if (!allMeetingsByEmployee.has(meeting.employeeId)) {\r\n        allMeetingsByEmployee.set(meeting.employeeId, []);\r\n      }\r\n      allMeetingsByEmployee.get(meeting.employeeId).push(meeting);\r\n    });\r\n\r\n    // Group attendance by employee-date\r\n    const attendanceByEmployee = new Map();\r\n    attendanceForPaginatedEmployees.forEach(att => {\r\n      const key = `${att.employeeId}-${att.date}`;\r\n      attendanceByEmployee.set(key, att);\r\n    });\r\n\r\n    // Group tracking sessions by employee and date\r\n    const sessionsByEmployeeDate = new Map();\r\n    trackingSessionsForPaginatedEmployees.forEach(session => {\r\n      try {\r\n        const dateStr = format(new Date(session.startTime), \"yyyy-MM-dd\");\r\n        const key = `${session.employeeId}-${dateStr}`;\r\n        if (!sessionsByEmployeeDate.has(key)) {\r\n          sessionsByEmployeeDate.set(key, []);\r\n        }\r\n        sessionsByEmployeeDate.get(key).push(session);\r\n      } catch (error) {\r\n        console.error('Error processing tracking session date:', error);\r\n      }\r\n    });\r\n\r\n    // Create user map for quick lookups\r\n    const userMap = new Map();\r\n    externalUsers.forEach(user => {\r\n      userMap.set(user._id, user);\r\n    });\r\n\r\n    // STEP 11: Build response with data\r\n    const allEmployeesData = paginatedEmployees.map((employee) => {\r\n      const employeeId = employee.userId || employee.id;\r\n      const allMeetings = allMeetingsByEmployee.get(employeeId) || [];\r\n\r\n      // Group ALL meetings by date for this employee\r\n      const meetingsByDate = new Map();\r\n      allMeetings.forEach(meeting => {\r\n        try {\r\n          if (meeting.startTime) {\r\n            const dateStr = format(new Date(meeting.startTime), \"yyyy-MM-dd\");\r\n            if (!meetingsByDate.has(dateStr)) {\r\n              meetingsByDate.set(dateStr, []);\r\n            }\r\n            meetingsByDate.get(dateStr).push(meeting);\r\n          }\r\n        } catch (error) {\r\n          // Skip invalid dates\r\n        }\r\n      });\r\n\r\n      // Get all unique dates from ALL meetings\r\n      const allDates = Array.from(meetingsByDate.keys())\r\n        .sort((a, b) => new Date(b).getTime() - new Date(a).getTime())\r\n        .slice(0, 10); // Limit to 10 most recent days for performance\r\n\r\n      // Generate day records from ALL meetings\r\n      const dayRecords = allDates.map(dateStr => {\r\n        const dateMeetings = meetingsByDate.get(dateStr) || [];\r\n        const totalMeetings = dateMeetings.length;\r\n\r\n        // Get first and last meeting\r\n        let firstMeeting = null;\r\n        let lastMeeting = null;\r\n        if (dateMeetings.length > 0) {\r\n          const sorted = [...dateMeetings].sort((a, b) => {\r\n            try {\r\n              return new Date(a.startTime).getTime() - new Date(b.startTime).getTime();\r\n            } catch {\r\n              return 0;\r\n            }\r\n          });\r\n          firstMeeting = sorted[0];\r\n          lastMeeting = sorted[sorted.length - 1];\r\n        }\r\n\r\n        // Calculate meeting time (sum of all meeting durations)\r\n        let meetingTime = 0;\r\n        dateMeetings.forEach(meeting => {\r\n          if (meeting.startTime && meeting.endTime) {\r\n            try {\r\n              const start = new Date(meeting.startTime);\r\n              const end = new Date(meeting.endTime);\r\n              const durationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\r\n              if (durationHours > 0) {\r\n                meetingTime += durationHours;\r\n              }\r\n            } catch (error) {\r\n              // Skip invalid dates\r\n            }\r\n          }\r\n        });\r\n\r\n        // Calculate total duty hours from first meeting start to last meeting end\r\n        let totalDutyHours = 0;\r\n        if (firstMeeting?.startTime && lastMeeting?.endTime) {\r\n          try {\r\n            const dutyStart = new Date(firstMeeting.startTime);\r\n            const dutyEnd = new Date(lastMeeting.endTime);\r\n            totalDutyHours = Math.max(0, (dutyEnd.getTime() - dutyStart.getTime()) / (1000 * 60 * 60));\r\n          } catch (error) {\r\n            console.error(`Error calculating duty hours for ${employeeId} on ${dateStr}:`, error);\r\n            totalDutyHours = 0;\r\n          }\r\n        } else if (firstMeeting?.startTime) {\r\n          // Only start time available (ongoing meeting)\r\n          try {\r\n            const dutyStart = new Date(firstMeeting.startTime);\r\n            const now = new Date();\r\n            totalDutyHours = Math.max(0, (now.getTime() - dutyStart.getTime()) / (1000 * 60 * 60));\r\n          } catch (error) {\r\n            totalDutyHours = 0;\r\n          }\r\n        }\r\n\r\n        // Use tracking sessions data if available and if no meetings exist\r\n        if (totalDutyHours === 0) {\r\n          const sessionKey = `${employeeId}-${dateStr}`;\r\n          const dateSessions = sessionsByEmployeeDate.get(sessionKey) || [];\r\n\r\n          if (dateSessions.length > 0) {\r\n            // Calculate from tracking sessions as fallback\r\n            dateSessions.forEach(session => {\r\n              if (session.startTime && session.endTime) {\r\n                try {\r\n                  const start = new Date(session.startTime);\r\n                  const end = new Date(session.endTime);\r\n                  const durationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\r\n                  if (durationHours > 0) {\r\n                    totalDutyHours += durationHours;\r\n                  }\r\n                } catch (error) {\r\n                  // Skip invalid dates\r\n                }\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        // Calculate travel and lunch time\r\n        const travelAndLunchTime = Math.max(0, totalDutyHours - meetingTime);\r\n\r\n        // Get attendance info\r\n        const attendanceKey = `${employeeId}-${dateStr}`;\r\n        const attendance = attendanceByEmployee.get(attendanceKey);\r\n\r\n        return {\r\n          date: dateStr,\r\n          totalMeetings,\r\n          startLocationTime: firstMeeting?.startTime ? format(new Date(firstMeeting.startTime), \"HH:mm:ss\") : \"\",\r\n          startLocationAddress: firstMeeting?.location?.address || \"\",\r\n          outLocationTime: lastMeeting?.endTime ? format(new Date(lastMeeting.endTime), \"HH:mm:ss\") : \"\",\r\n          outLocationAddress: lastMeeting?.location?.address || \"\",\r\n          totalDutyHours: parseFloat(totalDutyHours.toFixed(2)),\r\n          meetingTime: parseFloat(meetingTime.toFixed(2)),\r\n          travelAndLunchTime: parseFloat(travelAndLunchTime.toFixed(2)),\r\n          attendanceAddedBy: attendance?.attendenceCreated ?\r\n            (userMap.get(attendance.attendenceCreated)?.name || attendance.attendenceCreated) : \"Auto\"\r\n        };\r\n      });\r\n\r\n      // Generate meeting records from most recent meetings (max 3)\r\n      const recentMeetings = allMeetings.slice(0, 3);\r\n      const meetingRecords = recentMeetings.map(meeting => {\r\n        // Calculate individual meeting duration\r\n        let totalStayTime = 0;\r\n        if (meeting.startTime && meeting.endTime) {\r\n          try {\r\n            const start = new Date(meeting.startTime);\r\n            const end = new Date(meeting.endTime);\r\n            totalStayTime = (end.getTime() - start.getTime()) / (1000 * 60 * 60); // Convert to hours\r\n          } catch (error) {\r\n            totalStayTime = 0;\r\n          }\r\n        }\r\n\r\n        return {\r\n          employeeName: employee.name,\r\n          companyName: meeting.clientName || \"Unknown Company\",\r\n          date: meeting.startTime ? format(new Date(meeting.startTime), \"yyyy-MM-dd\") : \"\",\r\n          leadId: meeting.leadId || \"\",\r\n          meetingInTime: meeting.startTime ? format(new Date(meeting.startTime), \"HH:mm:ss\") : \"\",\r\n          meetingInLocation: meeting.location?.address || \"\",\r\n          meetingOutTime: meeting.endTime ? format(new Date(meeting.endTime), \"HH:mm:ss\") : \"In Progress\",\r\n          meetingOutLocation: meeting.location?.address || \"\",\r\n          totalStayTime: parseFloat(totalStayTime.toFixed(2)),\r\n          discussion: meeting.meetingDetails?.discussion || \"\",\r\n          meetingPerson: meeting.meetingDetails?.customerEmployeeName || \"\",\r\n          meetingStatus: meeting.status || \"completed\",\r\n          approvalStatus: meeting.approvalStatus,\r\n          approvalReason: meeting.approvalReason,\r\n          approvedBy: meeting.approvedBy,\r\n          approvedByName: meeting.approvedBy ?\r\n            (userMap.get(meeting.approvedBy)?.name || meeting.approvedBy) : undefined,\r\n          attachments: meeting.meetingDetails?.attachments || [],\r\n        };\r\n      });\r\n\r\n      // Calculate summary from ALL meetings\r\n      const totalMeetings = allMeetings.length;\r\n      const uniqueDates = new Set();\r\n      let totalMeetingHours = 0;\r\n\r\n      allMeetings.forEach(m => {\r\n        if (m.startTime) {\r\n          try {\r\n            uniqueDates.add(format(new Date(m.startTime), \"yyyy-MM-dd\"));\r\n            // Calculate meeting duration for summary\r\n            if (m.startTime && m.endTime) {\r\n              const start = new Date(m.startTime);\r\n              const end = new Date(m.endTime);\r\n              totalMeetingHours += (end.getTime() - start.getTime()) / (1000 * 60 * 60);\r\n            }\r\n          } catch (error) {\r\n            // Skip invalid dates\r\n          }\r\n        }\r\n      });\r\n\r\n      const daysWithMeetings = uniqueDates.size;\r\n\r\n      return {\r\n        employeeId: employee.id,\r\n        employeeName: employee.name,\r\n        email: employee.email,\r\n        phone: employee.phone,\r\n        designation: employee.designation,\r\n        department: employee.department,\r\n        companyName: employee.companyName,\r\n        reportTo: employee.reportTo,\r\n        status: employee.status,\r\n        summary: {\r\n          totalMeetings,\r\n          totalMeetingHours: parseFloat(totalMeetingHours.toFixed(2)),\r\n          daysWithMeetings,\r\n          avgMeetingsPerDay: daysWithMeetings > 0 ? parseFloat((totalMeetings / daysWithMeetings).toFixed(2)) : 0,\r\n        },\r\n        dayRecords: dayRecords,\r\n        meetingRecords: meetingRecords,\r\n      };\r\n    });\r\n\r\n    const endTime = Date.now();\r\n    console.log(`‚úÖ All employees details fetched in ${endTime - startTime}ms for ${paginatedEmployees.length} employees`);\r\n\r\n    // Calculate pagination info\r\n    const hasNextPage = pageNum < totalPages;\r\n    const hasPreviousPage = pageNum > 1;\r\n\r\n    res.json({\r\n      success: true,\r\n      dateRange: {\r\n        start: start.toISOString(),\r\n        end: end.toISOString(),\r\n        label: dateRange,\r\n      },\r\n      pagination: {\r\n        currentPage: pageNum,\r\n        pageSize: limitNum,\r\n        totalItems: totalEmployees,\r\n        totalPages: totalPages,\r\n        hasNextPage,\r\n        hasPreviousPage,\r\n        nextPage: hasNextPage ? pageNum + 1 : null,\r\n        previousPage: hasPreviousPage ? pageNum - 1 : null,\r\n      },\r\n      search: search || null,\r\n      sort: {\r\n        by: sortBy,\r\n        order: sortOrder\r\n      },\r\n      employees: allEmployeesData,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error fetching all employees details:\", error);\r\n    console.error(\"Error stack:\", error.stack);\r\n    res.status(500).json({\r\n      error: \"Failed to fetch all employees details\",\r\n      message: error.message\r\n    });\r\n  }\r\n};\r\n","import { RequestHandler } from \"express\";\nimport { Meeting, MeetingHistory, Employee, TrackingSession } from \"../models\";\n\n// Endpoint to synchronize all data sources and ensure consistency\nexport const syncAllData: RequestHandler = async (req, res) => {\n  try {\n    console.log(\"Starting data synchronization...\");\n    \n    const { employeeId } = req.query;\n    \n    // Get all data from MongoDB\n    const mongoMeetings = await Meeting.find(employeeId ? { employeeId } : {}).lean();\n    const mongoHistory = await MeetingHistory.find(employeeId ? { employeeId } : {}).lean();\n    \n    console.log(`Found ${mongoMeetings.length} meetings and ${mongoHistory.length} history entries in MongoDB`);\n    \n    // Get in-memory data for comparison\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    \n    console.log(`Found ${inMemoryMeetings.length} meetings in memory`);\n    \n    // Synchronize missing data\n    let syncedMeetings = 0;\n    let syncedHistory = 0;\n    \n    // Sync in-memory meetings to MongoDB\n    for (const meeting of inMemoryMeetings) {\n      if (employeeId && meeting.employeeId !== employeeId) continue;\n      \n      const exists = await Meeting.findOne({ \n        employeeId: meeting.employeeId,\n        startTime: meeting.startTime \n      });\n      \n      if (!exists) {\n        try {\n          const newMeeting = new Meeting({\n            employeeId: meeting.employeeId,\n            location: meeting.location,\n            startTime: meeting.startTime,\n            endTime: meeting.endTime,\n            clientName: meeting.clientName,\n            notes: meeting.notes,\n            status: meeting.status,\n            trackingSessionId: meeting.trackingSessionId,\n            leadId: meeting.leadId,\n            leadInfo: meeting.leadInfo,\n            meetingDetails: meeting.meetingDetails\n          });\n          \n          await newMeeting.save();\n          syncedMeetings++;\n          \n          // Also add to meeting history if completed\n          if (meeting.status === 'completed' && meeting.meetingDetails) {\n            const historyExists = await MeetingHistory.findOne({\n              employeeId: meeting.employeeId,\n              'meetingDetails.discussion': meeting.meetingDetails.discussion\n            });\n            \n            if (!historyExists) {\n              const newHistory = new MeetingHistory({\n                sessionId: meeting.trackingSessionId || `sync_${Date.now()}`,\n                employeeId: meeting.employeeId,\n                meetingDetails: meeting.meetingDetails,\n                timestamp: meeting.endTime || meeting.startTime,\n                leadId: meeting.leadId,\n                leadInfo: meeting.leadInfo\n              });\n              \n              await newHistory.save();\n              syncedHistory++;\n            }\n          }\n        } catch (syncError) {\n          console.warn(`Failed to sync meeting ${meeting.id}:`, syncError);\n        }\n      }\n    }\n    \n    // Get final counts\n    const finalMeetings = await Meeting.countDocuments(employeeId ? { employeeId } : {});\n    const finalHistory = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\n    \n    const result = {\n      success: true,\n      message: \"Data synchronization completed\",\n      stats: {\n        totalMeetingsInMongoDB: finalMeetings,\n        totalHistoryInMongoDB: finalHistory,\n        meetingsSynced: syncedMeetings,\n        historySynced: syncedHistory,\n        employeeId: employeeId || \"all\"\n      }\n    };\n    \n    console.log(\"Data sync result:\", result);\n    res.json(result);\n    \n  } catch (error) {\n    console.error(\"Error synchronizing data:\", error);\n    res.status(500).json({ \n      error: \"Failed to synchronize data\",\n      details: error.message \n    });\n  }\n};\n\n// Endpoint to get comprehensive data status\nexport const getDataStatus: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.query;\n    \n    // MongoDB counts\n    const mongoMeetingsCount = await Meeting.countDocuments(employeeId ? { employeeId } : {});\n    const mongoHistoryCount = await MeetingHistory.countDocuments(employeeId ? { employeeId } : {});\n    const mongoEmployeesCount = await Employee.countDocuments();\n    const mongoTrackingCount = await TrackingSession.countDocuments(employeeId ? { employeeId } : {});\n    \n    // In-memory counts\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    const filteredInMemoryMeetings = employeeId \n      ? inMemoryMeetings.filter(m => m.employeeId === employeeId)\n      : inMemoryMeetings;\n    \n    // Sample data for debugging\n    const sampleMongoMeeting = await Meeting.findOne(employeeId ? { employeeId } : {}).lean();\n    const sampleMongoHistory = await MeetingHistory.findOne(employeeId ? { employeeId } : {}).lean();\n    \n    const status = {\n      employeeId: employeeId || \"all\",\n      mongoDB: {\n        meetings: mongoMeetingsCount,\n        history: mongoHistoryCount,\n        employees: mongoEmployeesCount,\n        trackingSessions: mongoTrackingCount,\n        sampleMeeting: sampleMongoMeeting ? {\n          id: sampleMongoMeeting._id,\n          employeeId: sampleMongoMeeting.employeeId,\n          status: sampleMongoMeeting.status,\n          hasDetails: !!sampleMongoMeeting.meetingDetails,\n          leadId: sampleMongoMeeting.leadId\n        } : null,\n        sampleHistory: sampleMongoHistory ? {\n          id: sampleMongoHistory._id,\n          employeeId: sampleMongoHistory.employeeId,\n          hasCustomers: sampleMongoHistory.meetingDetails?.customers?.length > 0,\n          discussion: sampleMongoHistory.meetingDetails?.discussion?.substring(0, 100)\n        } : null\n      },\n      inMemory: {\n        meetings: filteredInMemoryMeetings.length,\n        sampleMeeting: filteredInMemoryMeetings[0] ? {\n          id: filteredInMemoryMeetings[0].id,\n          employeeId: filteredInMemoryMeetings[0].employeeId,\n          status: filteredInMemoryMeetings[0].status,\n          hasDetails: !!filteredInMemoryMeetings[0].meetingDetails\n        } : null\n      }\n    };\n    \n    res.json(status);\n    \n  } catch (error) {\n    console.error(\"Error getting data status:\", error);\n    res.status(500).json({ \n      error: \"Failed to get data status\",\n      details: error.message \n    });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { Meeting, MeetingHistory } from \"../models\";\n\nexport const debugEmployeeData: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.params;\n    \n    console.log(`Debugging data for employee: ${employeeId}`);\n    \n    // Get MongoDB meetings\n    const mongoMeetings = await Meeting.find({ employeeId }).lean();\n    console.log(`Found ${mongoMeetings.length} meetings in MongoDB for employee ${employeeId}`);\n    \n    // Get MongoDB meeting history\n    const mongoHistory = await MeetingHistory.find({ employeeId }).lean();\n    console.log(`Found ${mongoHistory.length} history entries in MongoDB for employee ${employeeId}`);\n    \n    // Get in-memory meetings\n    const { meetings: inMemoryMeetings } = await import(\"./meetings\");\n    const filteredInMemory = inMemoryMeetings.filter(m => m.employeeId === employeeId);\n    console.log(`Found ${filteredInMemory.length} meetings in memory for employee ${employeeId}`);\n    \n    const debugData = {\n      employeeId,\n      mongoDB: {\n        meetings: {\n          count: mongoMeetings.length,\n          data: mongoMeetings.map(m => ({\n            id: m._id.toString(),\n            startTime: m.startTime,\n            endTime: m.endTime,\n            status: m.status,\n            clientName: m.clientName,\n            leadId: m.leadId,\n            hasDetails: !!m.meetingDetails,\n            detailsCustomers: m.meetingDetails?.customers?.length || 0\n          }))\n        },\n        history: {\n          count: mongoHistory.length,\n          data: mongoHistory.map(h => ({\n            id: h._id.toString(),\n            timestamp: h.timestamp,\n            sessionId: h.sessionId,\n            leadId: h.leadId,\n            hasDetails: !!h.meetingDetails,\n            discussion: h.meetingDetails?.discussion?.substring(0, 100),\n            customers: h.meetingDetails?.customers?.length || 0,\n            customerNames: h.meetingDetails?.customers?.map(c => c.customerEmployeeName) || []\n          }))\n        }\n      },\n      inMemory: {\n        meetings: {\n          count: filteredInMemory.length,\n          data: filteredInMemory.map(m => ({\n            id: m.id,\n            startTime: m.startTime,\n            endTime: m.endTime,\n            status: m.status,\n            clientName: m.clientName,\n            leadId: m.leadId,\n            hasDetails: !!m.meetingDetails\n          }))\n        }\n      },\n      recommendations: []\n    };\n    \n    // Add recommendations based on data analysis\n    if (mongoMeetings.length === 0 && filteredInMemory.length > 0) {\n      debugData.recommendations.push(\"Meetings exist in memory but not in MongoDB - run data sync\");\n    }\n    \n    if (mongoMeetings.length > mongoHistory.length) {\n      debugData.recommendations.push(\"More meetings than history entries - some meetings may not have been completed properly\");\n    }\n    \n    if (mongoHistory.length === 0) {\n      debugData.recommendations.push(\"No meeting history found - check if meetings are being ended with proper details\");\n    }\n    \n    console.log(\"Debug data prepared:\", JSON.stringify(debugData, null, 2));\n    \n    res.json(debugData);\n    \n  } catch (error) {\n    console.error(\"Error in debug endpoint:\", error);\n    res.status(500).json({ error: \"Debug failed\", details: error.message });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { RouteSnapshot, IRouteSnapshot } from \"../models\";\n\n// In-memory fallback storage for route snapshots\nlet inMemorySnapshots: any[] = [];\nexport { inMemorySnapshots };\n\n// Get route snapshots with filtering\nexport const getRouteSnapshots: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      trackingSessionId,\n      status,\n      startDate,\n      endDate,\n      page = 1,\n      limit = 20\n    } = req.query;\n\n    console.log(\"Fetching route snapshots with query:\", { employeeId, trackingSessionId, status, startDate, endDate });\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const skip = (pageNum - 1) * limitNum;\n\n    try {\n      // Build MongoDB query\n      const query: any = {};\n\n      if (employeeId) {\n        query.employeeId = employeeId;\n      }\n\n      if (trackingSessionId) {\n        query.trackingSessionId = trackingSessionId;\n      }\n\n      if (status) {\n        query.status = status;\n      }\n\n      if (startDate || endDate) {\n        query.captureTime = {};\n        if (startDate) {\n          query.captureTime.$gte = new Date(startDate as string).toISOString();\n        }\n        if (endDate) {\n          query.captureTime.$lte = new Date(endDate as string).toISOString();\n        }\n      }\n\n      const snapshots = await RouteSnapshot.find(query)\n        .sort({ captureTime: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await RouteSnapshot.countDocuments(query);\n\n      const response = {\n        snapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${snapshots.length} route snapshots from MongoDB`);\n      res.json(response);\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      let filteredSnapshots = [...inMemorySnapshots];\n\n      // Apply filters\n      if (employeeId) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.employeeId === employeeId);\n      }\n\n      if (trackingSessionId) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.trackingSessionId === trackingSessionId);\n      }\n\n      if (status) {\n        filteredSnapshots = filteredSnapshots.filter(s => s.status === status);\n      }\n\n      if (startDate || endDate) {\n        filteredSnapshots = filteredSnapshots.filter(s => {\n          const captureTime = new Date(s.captureTime);\n          if (startDate && captureTime < new Date(startDate as string)) return false;\n          if (endDate && captureTime > new Date(endDate as string)) return false;\n          return true;\n        });\n      }\n\n      // Sort by capture time (newest first)\n      filteredSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\n\n      // Apply pagination\n      const total = filteredSnapshots.length;\n      const paginatedSnapshots = filteredSnapshots.slice(skip, skip + limitNum);\n\n      const response = {\n        snapshots: paginatedSnapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${paginatedSnapshots.length} route snapshots from memory (${total} total)`);\n      res.json(response);\n    }\n  } catch (error) {\n    console.error(\"Error fetching route snapshots:\", error);\n    res.status(500).json({ error: \"Failed to fetch route snapshots\" });\n  }\n};\n\n// Get a specific route snapshot by ID\nexport const getRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    try {\n      // Try MongoDB first\n      const snapshot = await RouteSnapshot.findOne({ id });\n\n      if (snapshot) {\n        console.log(\"Route snapshot found in MongoDB:\", snapshot.id);\n        return res.json(snapshot);\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memorySnapshot = inMemorySnapshots.find(s => s.id === id);\n\n    if (memorySnapshot) {\n      console.log(\"Route snapshot found in memory:\", memorySnapshot.id);\n      return res.json(memorySnapshot);\n    }\n\n    return res.status(404).json({ error: \"Route snapshot not found\" });\n  } catch (error) {\n    console.error(\"Error fetching route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to fetch route snapshot\" });\n  }\n};\n\n// Create a new route snapshot\nexport const createRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const {\n      employeeId,\n      employeeName,\n      trackingSessionId,\n      title,\n      description,\n      startLocation,\n      endLocation,\n      route,\n      meetings,\n      totalDistance,\n      duration,\n      status,\n      mapBounds\n    } = req.body;\n\n    if (!employeeId || !employeeName || !title || !startLocation || !route || !mapBounds) {\n      return res.status(400).json({\n        error: \"Employee ID, name, title, start location, route, and map bounds are required\",\n      });\n    }\n\n    // Generate unique snapshot ID\n    const snapshotId = `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Calculate snapshot metadata\n    const snapshotMetadata = {\n      routeColor: '#3b82f6',\n      mapZoom: 12,\n      routePointsCount: route.length,\n      meetingsCount: meetings ? meetings.length : 0\n    };\n\n    const snapshotData = {\n      id: snapshotId,\n      employeeId,\n      employeeName,\n      trackingSessionId,\n      captureTime: new Date().toISOString(),\n      title,\n      description,\n      startLocation: {\n        ...startLocation,\n        timestamp: startLocation.timestamp || new Date().toISOString(),\n      },\n      endLocation: endLocation ? {\n        ...endLocation,\n        timestamp: endLocation.timestamp || new Date().toISOString(),\n      } : undefined,\n      route: route.map((point: any) => ({\n        ...point,\n        timestamp: point.timestamp || new Date().toISOString(),\n      })),\n      meetings: meetings || [],\n      totalDistance: totalDistance || 0,\n      duration,\n      status: status || 'active',\n      mapBounds,\n      snapshotMetadata\n    };\n\n    try {\n      // Try to save to MongoDB first\n      const newSnapshot = new RouteSnapshot(snapshotData);\n      const savedSnapshot = await newSnapshot.save();\n\n      console.log(\"Route snapshot created in MongoDB:\", savedSnapshot.id);\n      res.status(201).json(savedSnapshot);\n    } catch (mongoError) {\n      console.error(\"MongoDB save failed, saving to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      inMemorySnapshots.push(snapshotData);\n\n      console.log(\"Route snapshot created in memory:\", snapshotData.id);\n      res.status(201).json(snapshotData);\n    }\n  } catch (error) {\n    console.error(\"Error creating route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to create route snapshot\" });\n  }\n};\n\n// Update a route snapshot\nexport const updateRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n    let updated = false;\n\n    try {\n      // Try MongoDB first\n      const updatedSnapshot = await RouteSnapshot.findOneAndUpdate(\n        { id },\n        { $set: updates },\n        { new: true, runValidators: true }\n      );\n\n      if (updatedSnapshot) {\n        console.log(\"Route snapshot updated in MongoDB:\", updatedSnapshot.id);\n        return res.json(updatedSnapshot);\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB update failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\n    if (memoryIndex !== -1) {\n      inMemorySnapshots[memoryIndex] = { ...inMemorySnapshots[memoryIndex], ...updates };\n      console.log(\"Route snapshot updated in memory:\", inMemorySnapshots[memoryIndex].id);\n      return res.json(inMemorySnapshots[memoryIndex]);\n    }\n\n    return res.status(404).json({ error: \"Route snapshot not found\" });\n  } catch (error) {\n    console.error(\"Error updating route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to update route snapshot\" });\n  }\n};\n\n// Delete a route snapshot\nexport const deleteRouteSnapshot: RequestHandler = async (req, res) => {\n  try {\n    const { id } = req.params;\n    let deleted = false;\n\n    try {\n      // Try MongoDB first\n      const deletedSnapshot = await RouteSnapshot.findOneAndDelete({ id });\n      if (deletedSnapshot) {\n        console.log(\"Route snapshot deleted from MongoDB:\", deletedSnapshot.id);\n        deleted = true;\n      }\n    } catch (mongoError) {\n      console.error(\"MongoDB delete failed, checking in-memory storage:\", mongoError);\n    }\n\n    // Check in-memory storage\n    const memoryIndex = inMemorySnapshots.findIndex(s => s.id === id);\n    if (memoryIndex !== -1) {\n      const deletedSnapshot = inMemorySnapshots.splice(memoryIndex, 1)[0];\n      console.log(\"Route snapshot deleted from memory:\", deletedSnapshot.id);\n      deleted = true;\n    }\n\n    if (!deleted) {\n      return res.status(404).json({ error: \"Route snapshot not found\" });\n    }\n\n    res.status(204).send();\n  } catch (error) {\n    console.error(\"Error deleting route snapshot:\", error);\n    res.status(500).json({ error: \"Failed to delete route snapshot\" });\n  }\n};\n\n// Get snapshots by employee\nexport const getEmployeeSnapshots: RequestHandler = async (req, res) => {\n  try {\n    const { employeeId } = req.params;\n    const { page = 1, limit = 10 } = req.query;\n\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const skip = (pageNum - 1) * limitNum;\n\n    try {\n      // Try MongoDB first\n      const snapshots = await RouteSnapshot.find({ employeeId })\n        .sort({ captureTime: -1 })\n        .skip(skip)\n        .limit(limitNum)\n        .lean();\n\n      const total = await RouteSnapshot.countDocuments({ employeeId });\n\n      const response = {\n        snapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${snapshots.length} snapshots for employee ${employeeId} from MongoDB`);\n      res.json(response);\n    } catch (mongoError) {\n      console.error(\"MongoDB query failed, falling back to in-memory storage:\", mongoError);\n\n      // Fallback to in-memory storage\n      const employeeSnapshots = inMemorySnapshots.filter(s => s.employeeId === employeeId);\n\n      // Sort by capture time (newest first)\n      employeeSnapshots.sort((a, b) => new Date(b.captureTime).getTime() - new Date(a.captureTime).getTime());\n\n      // Apply pagination\n      const total = employeeSnapshots.length;\n      const paginatedSnapshots = employeeSnapshots.slice(skip, skip + limitNum);\n\n      const response = {\n        snapshots: paginatedSnapshots,\n        total,\n        page: pageNum,\n        totalPages: Math.ceil(total / limitNum),\n      };\n\n      console.log(`Found ${paginatedSnapshots.length} snapshots for employee ${employeeId} from memory (${total} total)`);\n      res.json(response);\n    }\n  } catch (error) {\n    console.error(\"Error fetching employee snapshots:\", error);\n    res.status(500).json({ error: \"Failed to fetch employee snapshots\" });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport axios from 'axios';\n\n// Update follow-up meeting status\nexport const updateFollowUpStatus: RequestHandler = async (req, res) => {\n  try {\n    const { status, meetingDetails } = req.body;\n    // Allow followUpId to be passed either as URL param or in the body\n    const followUpId = (req.params && (req.params as any).id) || (req.body && req.body.followUpId);\n\n    if (!followUpId || !status) {\n      return res.status(400).json({\n        error: \"Missing required fields: followUpId and status are required\",\n      });\n    }\n\n    console.log(\"Updating follow-up status:\", {\n      followUpId,\n      status,\n      meetingDetails,\n    });\n\n    // Construct the external API URL for updating follow-up status\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\n    \n    // Prefer external endpoint updateFollowUp/:id if available\n    const updateUrl = `${baseUrl}/updateFollowUp/${followUpId}`;\n\n    const updatePayload = {\n      meetingStatus: status,\n      meetingDetails: meetingDetails,\n      updatedAt: new Date().toISOString(),\n    };\n\n    console.log(\"Sending update to external API (updateFollowUp/:id):\", {\n      url: updateUrl,\n      payload: updatePayload,\n    });\n\n    // Try calling the updateFollowUp/:id endpoint first\n    let response;\n    try {\n      response = await axios.put(updateUrl, updatePayload, {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        timeout: 10000,\n      });\n    } catch (err) {\n      console.warn(\"updateFollowUp/:id failed, falling back to updateFollowUpHistory\", err?.message || err);\n      // Fallback to older endpoint if available\n      const fallbackUrl = `${baseUrl}/updateFollowUpHistory`;\n      const fallbackPayload = {\n        id: followUpId,\n        status: status,\n        meetingDetails: meetingDetails,\n        updatedAt: new Date().toISOString(),\n      };\n      console.log(\"Sending update to external API (fallback):\", { url: fallbackUrl, payload: fallbackPayload });\n      response = await axios.put(fallbackUrl, fallbackPayload, {\n        headers: { \"Content-Type\": \"application/json\" },\n        timeout: 10000,\n      });\n    }\n\n    if (response.status === 200 || response.data.success) {\n      console.log(\"Follow-up status updated successfully:\", response.data);\n      return res.json({\n        message: \"Follow-up status updated successfully\",\n        data: response.data,\n      });\n    } else {\n      console.error(\"Failed to update follow-up status:\", response.data);\n      return res.status(400).json({\n        error: \"Failed to update follow-up status\",\n        details: response.data,\n      });\n    }\n  } catch (error) {\n    console.error(\"Error updating follow-up status:\", error);\n\n    if (axios.isAxiosError(error)) {\n      const errorMessage = error.response?.data?.message || error.message;\n      return res.status(error.response?.status || 500).json({\n        error: \"Failed to update follow-up status\",\n        details: errorMessage,\n      });\n    }\n\n    return res.status(500).json({\n      error: \"Internal server error\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n\n// Get follow-up history for a user\nexport const getFollowUpHistory: RequestHandler = async (req, res) => {\n  try {\n    const { userId } = req.query;\n\n    if (!userId) {\n      return res.status(400).json({\n        error: \"Missing required parameter: userId\",\n      });\n    }\n\n    console.log(\"Fetching follow-up history for user:\", userId);\n\n    const externalApiUrl = process.env.VITE_EXTERNAL_LEAD_API || \"https://jbdspower.in/LeafNetServer/api\";\n    const baseUrl = externalApiUrl.replace(\"/getAllLead\", \"\");\n    const url = `${baseUrl}/getFollowUpHistory?userId=${userId}`;\n\n    console.log(\"Fetching from external API:\", url);\n\n    const response = await axios.get(url, {\n      timeout: 10000,\n    });\n\n    if (response.status === 200 && response.data) {\n      console.log(`Fetched ${response.data.length || 0} follow-up records`);\n      return res.json(response.data);\n    } else {\n      console.error(\"Failed to fetch follow-up history:\", response.data);\n      return res.status(400).json({\n        error: \"Failed to fetch follow-up history\",\n        details: response.data,\n      });\n    }\n  } catch (error) {\n    console.error(\"Error fetching follow-up history:\", error);\n\n    if (axios.isAxiosError(error)) {\n      const errorMessage = error.response?.data?.message || error.message;\n      return res.status(error.response?.status || 500).json({\n        error: \"Failed to fetch follow-up history\",\n        details: errorMessage,\n      });\n    }\n\n    return res.status(500).json({\n      error: \"Internal server error\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n","import express from \"express\";\r\nimport cors from \"cors\";\r\nimport path from \"path\";\r\nimport Database from \"./config/database\";\r\nimport { handleDemo } from \"./routes/demo\";\r\nimport {\r\n  getEmployees,\r\n  getEmployee,\r\n  updateEmployeeLocation,\r\n  updateEmployeeStatus,\r\n  createEmployee,\r\n  updateEmployee,\r\n  deleteEmployee,\r\n  refreshEmployeeLocations,\r\n  clearLocationCache,\r\n} from \"./routes/employees\";\r\nimport {\r\n  getMeetings,\r\n  createMeeting,\r\n  updateMeeting,\r\n  getMeeting,\r\n  deleteMeeting,\r\n  getActiveMeeting,\r\n  updateMeetingApproval,\r\n  updateMeetingApprovalByDetails,\r\n  getTodaysMeetings,\r\n} from \"./routes/meetings\";\r\nimport {\r\n  getTrackingSessions,\r\n  createTrackingSession,\r\n  updateTrackingSession,\r\n  addLocationToRoute,\r\n  getTrackingSession,\r\n  deleteTrackingSession,\r\n  getMeetingHistory,\r\n  addMeetingToHistory,\r\n  saveIncompleteMeetingRemark,\r\n  getIncompleteMeetingRemark,\r\n} from \"./routes/tracking\";\r\nimport {\r\n  getEmployeeAnalytics,\r\n  getEmployeeDetails,\r\n  getLeadHistory,\r\n  saveAttendance,\r\n  getAttendance,\r\n  getMeetingTrends,\r\n  getAllEmployeesDetails,\r\n} from \"./routes/analytics\";\r\nimport {\r\n  syncAllData,\r\n  getDataStatus,\r\n} from \"./routes/data-sync\";\r\nimport {\r\n  debugEmployeeData,\r\n} from \"./routes/debug\";\r\nimport {\r\n  getRouteSnapshots,\r\n  getRouteSnapshot,\r\n  createRouteSnapshot,\r\n  updateRouteSnapshot,\r\n  deleteRouteSnapshot,\r\n  getEmployeeSnapshots,\r\n} from \"./routes/route-snapshots\";\r\nimport { updateFollowUpStatus, getFollowUpHistory } from \"./routes/follow-ups\";\r\nimport { fileURLToPath } from \"url\";\r\n\r\n// ES module equivalent of __dirname\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nexport function createServer() {\r\n  const app = express();\r\n\r\n  // Initialize database connection\r\n  const initializeDatabase = async () => {\r\n    try {\r\n      const db = Database.getInstance();\r\n      await db.connect();\r\n    } catch (error) {\r\n      console.error('Failed to initialize database:', error);\r\n      // Continue without database for development\r\n    }\r\n  };\r\n\r\n  // Start database connection (non-blocking)\r\n  initializeDatabase();\r\n\r\n  // Middleware\r\n  app.use(cors());\r\n  // Increase body size limit to handle file attachments (base64 encoded)\r\n  // 20MB limit allows for ~15MB of base64 data (which is ~11MB of original files)\r\n  app.use(express.json({ limit: '20mb' }));\r\n  app.use(express.urlencoded({ extended: true, limit: '20mb' }));\r\n\r\n  // Request logging\r\n  app.use((req, res, next) => {\r\n    console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);\r\n    next();\r\n  });\r\n\r\n  // Example API routes\r\n  app.get(\"/api/ping\", (_req, res) => {\r\n    console.log(\"Health check ping received\");\r\n    res.json({\r\n      message: \"Hello from Express server v2!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\",\r\n    });\r\n  });\r\n\r\n  app.get(\"/api/demo\", handleDemo);\r\n  \r\n  // Test endpoint for attendance\r\n  app.get(\"/api/test-attendance\", (_req, res) => {\r\n    console.log(\"Test attendance endpoint hit\");\r\n    res.json({\r\n      message: \"Attendance route is working!\",\r\n      timestamp: new Date().toISOString(),\r\n      status: \"ok\"\r\n    });\r\n  });\r\n\r\n  // Employee routes\r\n  app.get(\"/api/employees\", getEmployees);\r\n  app.post(\"/api/employees\", createEmployee);\r\n  app.get(\"/api/employees/:id\", getEmployee);\r\n  app.put(\"/api/employees/:id\", updateEmployee);\r\n  app.delete(\"/api/employees/:id\", deleteEmployee);\r\n  app.put(\"/api/employees/:id/location\", updateEmployeeLocation);\r\n  app.put(\"/api/employees/:id/status\", updateEmployeeStatus);\r\n  app.post(\"/api/employees/refresh-locations\", refreshEmployeeLocations);\r\n  app.post(\"/api/employees/clear-cache\", clearLocationCache);\r\n\r\n  // Meeting routes\r\n  app.get(\"/api/meetings\", getMeetings);\r\n  app.post(\"/api/meetings\", createMeeting);\r\n  app.get(\"/api/meetings/active\", getActiveMeeting); // üîπ NEW: Get active meeting\r\n  app.get(\"/api/meetings/today\", getTodaysMeetings); // üîπ NEW: Get today's meetings for duty summary\r\n  app.get(\"/api/meetings/:id\", getMeeting);\r\n  app.put(\"/api/meetings/:id\", updateMeeting);\r\n  app.put(\"/api/meetings/:id/approval\", updateMeetingApproval); // Meeting approval by ID\r\n  app.put(\"/api/meetings/approval-by-details\", updateMeetingApprovalByDetails); // Meeting approval by composite key\r\n  app.delete(\"/api/meetings/:id\", deleteMeeting);\r\n\r\n  // Tracking session routes\r\n  app.get(\"/api/tracking-sessions\", getTrackingSessions);\r\n  app.post(\"/api/tracking-sessions\", createTrackingSession);\r\n  app.get(\"/api/tracking-sessions/:id\", getTrackingSession);\r\n  app.put(\"/api/tracking-sessions/:id\", updateTrackingSession);\r\n  app.delete(\"/api/tracking-sessions/:id\", deleteTrackingSession);\r\n  app.post(\"/api/tracking-sessions/:id/location\", addLocationToRoute);\r\n\r\n  // Meeting history routes\r\n  app.get(\"/api/meeting-history\", getMeetingHistory);\r\n  app.post(\"/api/meeting-history\", addMeetingToHistory);\r\n  app.post(\"/api/incomplete-meeting-remarks\", saveIncompleteMeetingRemark);\r\n  // Expose both paths for backward compatibility and ease-of-use from the client\r\n  app.get(\"/api/get-incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n  // Preferred/clean path the frontend should call to fetch incomplete meeting remarks by employeeId\r\n  app.get(\"/api/incomplete-meeting-remarks\", getIncompleteMeetingRemark);\r\n\r\n  // Analytics routes\r\n  app.get(\"/api/analytics/employees\", getEmployeeAnalytics);\r\n  app.get(\"/api/analytics/employee-details/:employeeId\", getEmployeeDetails);\r\n  app.get(\"/api/analytics/all-employees-details\", getAllEmployeesDetails); // New endpoint for all employees\r\n  app.get(\"/api/analytics/lead-history/:leadId\", getLeadHistory);\r\n  app.post(\"/api/analytics/save-attendance\", saveAttendance);\r\n  app.get(\"/api/analytics/attendance\", (req, res, next) => {\r\n    console.log(\"üéØ Attendance route hit!\", {\r\n      query: req.query,\r\n      url: req.url,\r\n      method: req.method\r\n    });\r\n    getAttendance(req, res, next);\r\n  });\r\n  app.get(\"/api/analytics/trends\", getMeetingTrends);\r\n\r\n  // Data synchronization routes\r\n  app.post(\"/api/data-sync\", syncAllData);\r\n  app.get(\"/api/data-status\", getDataStatus);\r\n\r\n  // Debug routes\r\n  app.get(\"/api/debug/employee/:employeeId\", debugEmployeeData);\r\n\r\n  // Route snapshot routes\r\n  app.get(\"/api/route-snapshots\", getRouteSnapshots);\r\n  app.post(\"/api/route-snapshots\", createRouteSnapshot);\r\n  app.get(\"/api/route-snapshots/:id\", getRouteSnapshot);\r\n  app.put(\"/api/route-snapshots/:id\", updateRouteSnapshot);\r\n  app.delete(\"/api/route-snapshots/:id\", deleteRouteSnapshot);\r\n  app.get(\"/api/employees/:employeeId/snapshots\", getEmployeeSnapshots);\r\n\r\n  // Follow-up meeting routes\r\n  app.get(\"/api/follow-ups\", getFollowUpHistory);\r\n  app.put(\"/api/follow-ups/:id\", updateFollowUpStatus);\r\n\r\n  // Serve static files in production\r\n  if (process.env.NODE_ENV === 'production') {\r\n    const distPath = path.join(__dirname, '../spa');\r\n    \r\n    console.log('üì¶ Serving static files from:', distPath);\r\n    \r\n    // Serve static files\r\n    app.use(express.static(distPath));\r\n    \r\n    // Handle React Router - serve index.html for all non-API routes\r\n    app.get('*', (req, res) => {\r\n      // Don't serve index.html for API routes\r\n      if (req.path.startsWith('/api/')) {\r\n        return res.status(404).json({ error: 'API endpoint not found' });\r\n      }\r\n      \r\n      const indexPath = path.join(distPath, 'index.html');\r\n      console.log('üìÑ Serving index.html for:', req.path);\r\n      res.sendFile(indexPath);\r\n    });\r\n  }\r\n\r\n  return app;\r\n}\r\n","import path from \"path\";\nimport { createServer } from \"./index\";\nimport * as express from \"express\";\n\nconst app = createServer();\nconst port = process.env.PORT || 3000;\n\n// In production, serve the built SPA files\nconst __dirname = import.meta.dirname;\nconst distPath = path.join(__dirname, \"../spa\");\n\n// Serve static files\napp.use(express.static(distPath));\n\n// Handle React Router - serve index.html for all non-API routes\napp.get(\"*\", (req, res) => {\n  // Don't serve index.html for API routes\n  if (req.path.startsWith(\"/api/\") || req.path.startsWith(\"/health\")) {\n    return res.status(404).json({ error: \"API endpoint not found\" });\n  }\n\n  res.sendFile(path.join(distPath, \"index.html\"));\n});\n\napp.listen(port, () => {\n  console.log(`üöÄ Fusion Starter server running on port ${port}`);\n  console.log(`üì± Frontend: http://localhost:${port}`);\n  console.log(`üîß API: http://localhost:${port}/api`);\n});\n\n// Graceful shutdown\nprocess.on(\"SIGTERM\", () => {\n  console.log(\"üõë Received SIGTERM, shutting down gracefully\");\n  process.exit(0);\n});\n\nprocess.on(\"SIGINT\", () => {\n  console.log(\"üõë Received SIGINT, shutting down gracefully\");\n  process.exit(0);\n});\n"],"names":["CustomerContactSchema","MeetingDetailsSchema","LocationSchema","LeadInfoSchema","LocationDataSchema","EXTERNAL_API_URL","GEOCACHE_TTL","employeeStatuses","geocodeCache","EmployeeModel","fetchExternalUsers","mapExternalUserToEmployee","employee","lastGeocodingTime","GEOCODING_DELAY","reverseGeocode","response","meeting","TrackingSessionModel","newSession","session","startOfWeek","pageNum","limitNum","newHistoryEntry","incompleteMeetings","durationMs","inMemoryMeetings","meetings","trackingSessions","start","end","endTime","totalMeetings","__dirname","app","express","distPath"],"mappings":"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"}